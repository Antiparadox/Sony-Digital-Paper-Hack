/*
    connctrl.js
    
    created:    [2016-05-24 21:57:19+09:00]
    modified:   [2016-11-18 19:20:30+09:00]
    description:
    Connection Control Implementation.
*/

/**
 * This module must be loaded from Electron Renderer.
 * @module mw-conn-ctrl
 */

'use strict';

const EventEmitter = require('events').EventEmitter;

// Load in Renderer Process
const mwe = require('mw-error');

// Use from Main Process
const electron = require('electron');

if ( typeof electron.remote === 'undefined' ) {
  throw new Error('This module must be loaded from Electron Renderer');
  // [2016-06-01 14:02:51+09:00] kan.k: このモジュールは、
  // RendererProcessで動作させる必要がある。理由はXHRを通じてRenderer
  // 側のHTTPSスタックを利用して通信するため。
}

const remote = electron.remote;
const selector = remote.require('mw-conn-selector');
const discovery = remote.require('mw-discovery-ctrl');
const portfwdr = remote.require('mw-port-fwdr');
const authctrl = remote.require('mw-auth-ctrl');

// const discovery = require('mw-discovery-ctrl');
// const portfwdr = require('mw-port-fwdr');
// const authctrl = require('mw-auth-ctrl');


const WEBAPI_BASE_URL = 'https://digitalpaper.local';
const WEBAPI_CHECK_BASE_URL = 'http://digitalpaper.local';
const WEBAPI_HTTPS_PORT = 8443;


const WEBAPI_PING = '/ping';
const WEBAPI_CHECK_PATH = '/api_version';
const METHOD_GET = 'GET';

/// XHR default timeout value.
const XHR_TIMEOUT = 60000;

/**
 * Create ConnCtrl instance.
 */
exports.createConnCtrl = function() {
  return new ConnCtrl();
}

/** 
 * Connection Control class for MilkyWay
 * @class
 */
class ConnCtrl extends EventEmitter {
  constructor() {
    super();
    this.portfwdr_ = portfwdr.createPortFwdr();

    // 現在接続済みのデバイス
    this.device_ = null;

    // 接続しようとしているデバイスのデバイスID
    this.deviceId_ = null;

    // 接続処理中のターゲットのデバイス
    this.deviceConnecting_ = null;

    // 現在接続処理中かを表すフラグ。
    this.connecting_ = false;

    // 接続完了後にdeviceConnChangedか、deviceConnChangeFailedイベントを投げる場合のフラグ
    this.connectingThenEmit_ = false;

    // Selector

    this.deviceAppearHandler_ = (device) => {
      this.onDeviceAppear_(device);
    }
    this.deviceDisappearHandler_ = (device) => {
      this.onDeviceDisappear_(device);
    }
    this.deviceConnChangedHandler_ = (device) => {
      this.onDeviceConnChanged_(device);
    }
    
    selector.on('deviceAppear', this.deviceAppearHandler_);
    selector.on('deviceDisappear', this.deviceDisappearHandler_);
    selector.on('deviceConnChanged', this.deviceConnChangedHandler_);

    this.usbSerialConnectedHandler_ = (device) => {
      this.onUsbSerialConnected_(device);
    }
    this.usbSerialDisconnectedHandler_ = (device) => {
      this.onUsbSerialDisconnected_(device);
    }
    this.usbEtherConnectedHandler_ = (device) => {
      this.onUsbEtherConnected_(device);
    }
    this.usbEtherDisconnectedHandler_ = (device) => {
      this.onUsbEtherDisconnected_(device);
    }

    discovery.on('usbSerialConnected', this.usbSerialConnectedHandler_);
    discovery.on('usbSerialDisconnected', this.usbSerialDisconnectedHandler_);
    discovery.on('usbEtherConnected', this.usbEtherConnectedHandler_);
    discovery.on('usbEtherDisconnected', this.usbEtherDisconnectedHandler_);
    
    // discovery.on('deviceAppear', (device) => {
    //   this.onDeviceAppear_(device);
    // });
    // discovery.on('deviceDisappear', (device) => {
    //   this.onDeviceDisappear_(device);
    // });
  }

  /**
   * Connect to designated device. After this procedure succeed, Web
   * API will be able to triggered by using getBaseUrl() URL.
   *
   * Regarding authentication, first authentication will be done by this
   * procedure. But the credential of this auth may be expire by
   * opponent devices behavior. For such a case, the Web API will be
   * return such a status, please call auth().
   *
   * When more than one connection are detected for designated device,
   * the most appropriate connection is selected according to
   * following priority:
   * 1. Deneb direct USB-ether
   * 2. IPv4 of other network interface.
   * 3. IPv6 of other network interface.(should)
   *
   * Before this procedure succeed, getBaseUrl() and getDevice() will
   * return `null`.
   *
   * When device is not found, E_MW_DEVICE_NOT_FOUND will be returned
   * to callback function. In this case, getDeviceId() will be set to
   * last specified deviceId, and deviceAppear event is ready to be
   * emitted.
   *
   * 
   * 指定されたデバイスに接続する。この処理が完了すると、getBaseUrl()
   * のURLを通じてWeb APIを呼ぶことができる様になる。
   * 
   * 認証に関しては、初回の認証はこの処理の中で行われる。ただし、認証
   * のCredentialは、対向デバイスの動作によって期限切れになる場合があ
   * る。その場合は、Web APIが、認証が必要な旨のStatusを返すので、
   * auth() を呼び出す必要がある。
   * 
   * 指定したdeviceIdに対応する接続が複数検出できている場合には、その
   * 時点で接続に利用するべき情報を返す。
   * 優先順位は、次の順:
   * 1. Deneb直結 USB-ether
   * 2. 他のネットワークインターフェースのIPv4
   * 3. 他のネットワークインターフェースのIPv6 (できれば)
   *
   * この処理が、成功して完了するまで、getBaseUrl() と、getDevice() は
   * nullを返す。
   *
   * デバイスが見つからない場合には、E_MW_DEVICE_NOT_FOUND がCallback
   * に返ってくる。ただしこの場合には、 getDeviceId() は最後に指定され
   * たdeviceIdを返し、deviceAppearイベントは受信可能な状態になる。
   *
   * @param {string} deviceId The deviceId of the device to connect.
   *
   * @param {function(?Error)} callback The function to be called when
   *   connect is done. When failed to connect, the Error object will
   *   be passed as a first argument. The error code of Error object can be:
   *   - E_MW_ALREADY_RUNNING
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_PORTFWDR_PORT_UNAVAILABLE
   *   - E_MW_PORTFWDR_FAILED_TO_LISTEN_PORT
   *   - E_MW_DEVICE_CONN_FAILED
   *   - E_MW_AUTH_FAILED
   *   - E_MW_STORE_SET_DEVICE_ID_FAILED
   *   - E_MW_STORE_GET_DEVICE_ID_FAILED
   *   - E_MW_STORE_GET_PRIVKEY_FAILED
   *   - E_MW_STORE_GEN_KEYPAIR_FAILE
   *   <br>
   *   接続が完了したときに呼び出されるCallback関数。接続に失敗した場
   *   合、Errorオブジェクトが第一引数に渡される。Errorオブジェクトの
   *   エラーコードは次の値をとりうる:
   *   - E_MW_ALREADY_RUNNING
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_PORTFWDR_PORT_UNAVAILABLE
   *   - E_MW_PORTFWDR_FAILED_TO_LISTEN_PORT
   *   - E_MW_DEVICE_CONN_FAILED
   *   - E_MW_AUTH_FAILED
   *   - E_MW_STORE_SET_DEVICE_ID_FAILED
   *   - E_MW_STORE_GET_DEVICE_ID_FAILED
   *   - E_MW_STORE_GET_PRIVKEY_FAILED
   *   - E_MW_STORE_GEN_KEYPAIR_FAILE
   */
  connect(deviceId, callback) {
    if ( typeof deviceId !== 'string' ) {
      throw new TypeError('deviceId must be a string.');
    }
    
    if ( this.connecting_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'connect is already running.'));
      return;
    }
    if ( this.device_ !== null ) {
      this.device_ = null
    }
    this.deviceId_ = deviceId;
    var device = selector.selectConnection(deviceId);
    // var deviceList = discovery.getDeviceList();
    // var device = this.selectDevice_(deviceId, deviceList);
    if ( device === null ) {
      callback(mwe.genError(mwe.E_MW_DEVICE_NOT_FOUND, 'The designated device not found'));
      return;
    }

    this.deviceConnecting_ = device;
    this.connectInternal_(callback);
    return;
  }

  /**
   * @note 接続処理中にに接続先が切り替わったら再度頭から接続処理を流
   *   す。接続切り替えのフラグ(connectingThenEmit_)が立っていたら、最
   *   後に接続変更完了のイベントを発行する。
   *
   * @private
   */
  connectInternal_(callback) {
    var device = this.deviceConnecting_;
    this.connecting_ = true;
    var self = this;
    this.portfwdr_.start(device.remoteIp, device.remotePort, WEBAPI_HTTPS_PORT, (err) => {
      if ( err ) {
        self.connecting_ = false;
        self.deviceConnecting_ = null;
        if ( self.connectingThenEmit_ ) {
          self.connectingThenEmit_ = false;
          self.emit('deviceConnChangeFailed', err);
        }
        callback(err);
        return;
      }

      var baseUrl = self.getBaseUrlWithPort_(self.portfwdr_.getHttpsPort());
      var checkUrl = self.getCheckUrlWithPort_(self.portfwdr_.getHttpPort());
      self.authByBaseUrlAfterCheck_(baseUrl, checkUrl, (err) => {
      // self.authByBaseUrl_(self.getBaseUrlWithPort_(self.portfwdr_.getHttpsPort()), (err) => {
        if ( self.deviceConnecting_ ) { // self.deviceConnecting_ が null になっていることがあるので、事前チェックを行います。
          if ( self.deviceConnecting_.remoteIp !== device.remoteIp ||
              self.deviceConnecting_.phyType !== device.phyType ) {
            // When target device connection is changed on the way to
            // auth, rerun connection.
            process.nextTick(function() {
              self.connectInternal_(callback);
            });
            return;
          }
        } else {
          if ( !err ) {
            err = mwe.genError(mwe.E_MW_DEVICE_NOT_FOUND, 'Connecting device is lost.');
          }
        }
        if ( err ) {
          self.connecting_ = false;
          self.deviceConnecting_ = null;
          if ( self.connectingThenEmit_ ) {
            self.connectingThenEmit_ = false;
            self.emit('deviceConnChangeFailed', err);
          }
          callback(err);
          return;
        }
        self.connecting_ = false;
        self.deviceConnecting_ = null;
        self.device_ = device;
        if ( self.connectingThenEmit_ ) {
          self.connectingThenEmit_ = false;
          self.emit('deviceConnChanged', device);
        }
        callback(null);
      });
    });
    return;
  }

  /**
   * Get base URL to call Web API for current connected device.
   * <br>
   * 現在選択しているデバイスの、Web APIを呼び出すためのBase URLを取得する。
   *
   * @return {string|null} The base part of URL to call Web API. The
   *   scheme part and host name part is included. (e.g.:
   *   "https://opponent.device.local")
   *
   * @note BaseURL の特に、Host名は、通信仕様上AuthのCredentialと紐付
   *   けられている。そのため、BaseURLは、Authも行うこのモジュールから
   *   取得して利用する設計としている。
   */
  getBaseUrl() {
    if ( this.device_ === null ) {
      return null;
    }
    return this.getBaseUrlWithPort_(this.portfwdr_.getHttpsPort());
  }

  getBaseUrlWithPort_(port) {
	// return 'https://digitalpaper.local:50000';
    return WEBAPI_BASE_URL + ':' + port.toString();
  }

  /**
   * HTTP
   * @private
   */
  getCheckUrlWithPort_(port) {
    return WEBAPI_CHECK_BASE_URL + ':' + port.toString() + WEBAPI_CHECK_PATH;
  }

  /**
   * HTTP
   * @private
   */
  getCheckUrl() {
    if ( this.device_ === null ) {
      return null;
    }
    return this.getCheckUrlWithPort_(this.portfwdr_.getHttpPort());
  }
  
  /**
   * 
   * @return {string} The deviceId of the device currently selected.
   */
  getDeviceId() {
    // if ( this.device_ === null ) {
    //   return null;
    // }
    return this.deviceId_;
  }

  /**
   * Rerun authentication procedure. This assumed to be called when
   * Web API returns status indicates authentication required.
   * <br>
   * 認証手続きを再度行う。このメソッドは、Web APIが認証が必要な旨のス
   * テータスを返した場合に呼び出される事を想定している。
   *
   * @param {function(?Error)} callback The function to be called when
   *   authentication is done. When failed to auth, the Error object
   *   will be passed as a first argument. The error code of Error
   *   object definition is same as `connect()`
   *   <br>
   *   認証手続きが完了したことを受け取るためのコールバック関数。認証
   *   に失敗した場合には、Errorオブジェクトが第一引数として返る。エラー
   *   コードの定義は、`connect()`と同じ。
   */
  auth(callback) {
    var baseUrl = this.getBaseUrl();
    var checkUrl = this.getCheckUrl();
    this.authByBaseUrlAfterCheck_(baseUrl, checkUrl, callback);
  }

  /**
   * @private
   */
  authByBaseUrlAfterCheck_(baseUrl, checkUrl, callback) {
    if ( this.authenticating_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'auth is already running.'));
      return;
    }
    this.authenticating_ = true;
    
    var self = this;
    
    var xhrReq0 = new XMLHttpRequest();
    xhrReq0.timeout = XHR_TIMEOUT;
    xhrReq0.responseType = "json";
    xhrReq0.open('GET', checkUrl, true);
    xhrReq0.ontimeout = function(err) {
      self.authenticating_ = false;
	  callback(mwe.genWebApiError(
        mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed',
		'GET', checkUrl, xhrReq0.status, err));
      return;
    };
    xhrReq0.onabort = function(err) {
      self.authenticating_ = false;
	  callback(mwe.genWebApiError(
        mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed',
		'GET', checkUrl, xhrReq0.status, err));
      return;
    };
    xhrReq0.onerror = function(err) {
      self.authenticating_ = false;
	  callback(mwe.genWebApiError(
        mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed',
		'GET', checkUrl, xhrReq0.status, err));
      return;
    };
    xhrReq0.onload = function() {
      if ( xhrReq0.status !== 200 ) {
        self.authenticating_ = false;
        callback(mwe.genWebApiError(
          mwe.E_MW_DEVICE_CONN_FAILED, 'Wrong status returned for connection check.',
		  'GET', checkUrl, xhrReq0.status, err));
        return;
      }
      
      var xhrReq1 = new XMLHttpRequest();
      xhrReq1.timeout = XHR_TIMEOUT;
      xhrReq1.responseType = "json";
      xhrReq1.open(METHOD_GET, baseUrl + WEBAPI_PING, true);
      xhrReq1.ontimeout = function(err) {
        self.authenticating_ = false;
	    callback(mwe.genWebApiError(
          mwe.E_MW_AUTH_FAILED, 'XHR failed',
		  'GET', baseUrl + WEBAPI_PING, xhrReq1.status, err));
        return;
      };
      xhrReq1.onabort = function(err) {
        self.authenticating_ = false;
	    callback(mwe.genWebApiError(
          mwe.E_MW_AUTH_FAILED, 'XHR failed',
		  'GET', baseUrl + WEBAPI_PING, xhrReq1.status, err));
        return;
      };
      xhrReq1.onerror = function(err) {
        self.authenticating_ = false;
	    callback(mwe.genWebApiError(
          mwe.E_MW_AUTH_FAILED, 'XHR failed',
		  'GET', baseUrl + WEBAPI_PING, xhrReq1.status, err));
        return;
      };
      xhrReq1.onload = function() {
        if ( xhrReq1.status >= 200 && xhrReq1.status < 300 ) {
          self.authenticating_ = false;
          // Already authenticated.
          callback(null);
          return;
        }
        // xhrReq1.response;
        // [2016-09-21 12:57:36+09:00] kan.k: Currently not checking
        // response. If version need to be checked insert checking code
        // here.
        self.authByBaseUrl_(baseUrl, function(err) {
          self.authenticating_ = false;
          callback(err);
        });
      };
      xhrReq1.send();
      // // xhrReq0.response;
      // // [2016-09-21 12:57:36+09:00] kan.k: Currently not checking
      // // response. If version need to be checked insert checking code
      // // here.
      // self.authByBaseUrl_(baseUrl, function(err) {
      //   self.authenticating_ = false;
      //   callback(err);
      // });
    };
    xhrReq0.send();
  }
    
  /**
   * @private
   */
  authByBaseUrl_(baseUrl, callback) {
    // if ( this.authenticating_ ) {
    //   callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'auth is already running.'));
    //   return;
    // }
    // this.authenticating_ = true;
    var self = this;
    authctrl.genAuthPrepare(baseUrl, function(err, reqProp1) {
      if ( err ) {
        // self.authenticating_ = false;
        callback(err);
        return;
      }
      var xhrReq1 = new XMLHttpRequest();
      xhrReq1.timeout = XHR_TIMEOUT;
      xhrReq1.responseType = "json";
      xhrReq1.open(reqProp1.method, reqProp1.url, true);
      xhrReq1.ontimeout = function(err) {
		callback(mwe.genWebApiError(mwe.E_MW_AUTH_FAILED, 'XHR failed',
									reqProp1.method, reqProp1.url, xhrReq1.status, err));
        return;
      };
      xhrReq1.onabort = function(err) {
		callback(mwe.genWebApiError(mwe.E_MW_AUTH_FAILED, 'XHR failed',
									reqProp1.method, reqProp1.url, xhrReq1.status, err));
        return;
      };
      xhrReq1.onerror = function(err) {
        // self.authenticating_ = false;
        // [2016-05-31 16:51:39+09:00] kan.k: [TODO] Handle authentication failer
        // callback(mwe.genError(mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed', err));
		// callback(mwe.genWebApiError(mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed',
		// 							reqProp1.method, reqProp1.url, xhrReq1.status, err));
		callback(mwe.genWebApiError(mwe.E_MW_AUTH_FAILED, 'XHR failed',
									reqProp1.method, reqProp1.url, xhrReq1.status, err));
        // [2016-09-21 12:59:20+09:00] kan.k: もし、証明書チェックで失
        // 敗した場合も、一番最初のHTTPS通信であるこの場所で失敗する。
        // ここでの情報では、証明書検証に失敗したのか、単に接続に失敗
        // したのか区別がつかない。対策として、直前に通信チェックを入
        // れ、ここで失敗した場合には証明書エラーと見なす対応を入れた。
        // ただしこれ以降のHTTPSの通信に失敗した場合は、証明書検証は通っ
        // ているものと仮定して、HTTPSの通信に失敗しても単なる接続エラー
        // として戻している。
        return;
      };
      xhrReq1.onload = function() {
        // debugger;
        authctrl.genAuth(baseUrl, xhrReq1.status, xhrReq1.response, function(err, reqProp2) {
          if ( err ) {
            // self.authenticating_ = false;
            callback(err);
            return;
          }
          var xhrReq2 = new XMLHttpRequest();
          xhrReq2.timeout = XHR_TIMEOUT;
          xhrReq2.responseType = "json";
          xhrReq2.open(reqProp2.method, reqProp2.url, true);
          xhrReq2.ontimeout = function(err) {
			callback(mwe.genWebApiError(mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed',
										reqProp2.method, reqProp2.url, xhrReq2.status, err));
            return;
          };
          xhrReq2.onabort = function(err) {
			callback(mwe.genWebApiError(mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed',
										reqProp2.method, reqProp2.url, xhrReq2.status, err));
            return;
          };
          xhrReq2.onerror = function(err) {
            // self.authenticating_ = false;
			// callback(mwe.genError(mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed', err));
			callback(mwe.genWebApiError(mwe.E_MW_DEVICE_CONN_FAILED, 'XHR failed',
										reqProp2.method, reqProp2.url, xhrReq2.status, err));
            return;
          };
          xhrReq2.onload = function() {
            // self.authenticating_ = false;
            authctrl.handleAuthRes(baseUrl, xhrReq2.status, xhrReq2.response, function(err) {
              if ( err ) {
                // self.authenticating_ = false;
                callback(err);
                return;
              }
              // self.authenticating_ = false;
              callback(null);
            });
          }
          var body = JSON.stringify(reqProp2.body);
          xhrReq2.send(body);
        });
      };
      xhrReq1.send();
    });
  }
  
  /**
   * Actively check connection between selected device.
   *
   * It is assumed that device disappear being detected by failer to
   * call Web API in most case. This function is prepared for the case
   * UI want to know the device connectivity without any operating functional
   * Web API call.
   *
   * <br>
   * 能動的に対向デバイスとの接続を確認する。
   *
   * ほとんどのケースでは、Web APIの呼び出しの失敗によって、デバイスが
   * 接続できなくなった事を検知すると想定される。この関数は、UIが、通常のWeb APIによる操作を
   * 
   * @param {function(?Error)} callback The function to be called when
   *   checking is done. When the device could not be connected, the
   *   Error object will be passed as a first argument.
   *   <br>
   *   接続確認がが完了したことを受け取るためのコールバック関数。接続
   *   できない場合には、Errorオブジェクトが第一引数として返る。
   */
  checkConnection(callback) {
    var baseUrl = this.getBaseUrl();
    if ( baseUrl === null ) {
      callback(mwe.genError(mwe.E_ERROR, 'This is wrong call'));
      return;
    }
    var xhrReq = new XMLHttpRequest();
    xhrReq.timeout = XHR_TIMEOUT;
    xhrReq.responseType = "json";
    xhrReq.open(METHOD_GET, baseUrl + WEBAPI_PING, true);
    xhrReq.ontimeout = function(err) {
      callback(err);
    };
    xhrReq.onabort = function(err) {
      callback(err);
    };
    xhrReq.onerror = function(err) {
      callback(err);
    };
    xhrReq.onload = function() {
      callback(null, xhrReq.response);
    };
    xhrReq.send();
  }

  /**
   * The function to notify that the target device is disconnected.
   * When calling Web API from upper layer, the caller may know device
   * is no longer connectable by result of XHR. In this case the
   * caller should call this function.
   * <br>
   * 指定したデバイスへの接続が切断された事を通知するための関数。より
   * 上位レイヤーからWeb APIを呼び出した場合に、XHRからの戻り値等で対
   * 象のデバイスがすでに接続できなくなっている事を検出できる。
   * その場合に呼び出し側でこの関数を呼んでデバイスが消えたことを通知
   * する。
   *
   * @param {string} deviceId
   * @param {string} remoteIp
   */
  detectDisconnected() {
    if ( this.device_ === null ) {
      return;
    }
    discovery.detectDisconnected(this.device_.deviceId, this.device_.remoteIp);
    return;
  }

  
  /**
   * Get device object that currently selected.
   *
   * @return {{deviceId: string, name: string, phyType: PhyType,
   *   remoteIp: string, remotePort: number, localIp: string}} Device
   *   information, The list of scanned devices. When remoteIp is IPv6
   *   Link Local address, scope Id also be set.
   *   <br>
   *   スキャンされているデバイスのPropertyを返す。remoteIpが、IPv6 Link
   *   Local Addressである場合には、スコープID付きのIPが返される。
   *   `deviceId`は、デバイスユニークなID。`name` は、デバイスのホスト名。
   *   `phyType`は、物理的な接続方式で、discovery.PHY_TYPE_USB か、
   *   discovery.PHY_TYPE_OTHER を返す。
   */
  getDevice() {
    return this.device_;
  }

  /**
   * Indicates a selected device appear. The object with deviceId will
   * be passed. Even when this event is issued, the module will not
   * connect until connect() is explicitly called.
   * <br>
   * 選択されているデバイスが、登場したことを示す。deviceId付きのオブ
   * ジェクトが渡される。このイベントが発行されても、connect()が明示的
   * に呼び出されるまで、このモジュールはデバイスに接続しない。
   *
   * @event deviceAppear
   * @param {{deviceId: string, name: string, phyType: PhyType, remoteIp:
   *     string, remotePort: number, localIp: string}} device
   */

  /**
   * Indicates the device disappear is detected. The object with
   * deviceId will be passed. After this event received all Web API
   * call assumed to fail.
   * <br>
   * デバイスが、見えなくなったことが検知された事を示す。deviceId付き
   * のオブジェクトが渡される。このイベントの後は全てのWeb API呼び出し
   * は失敗する事が想定される。
   *
   * @event deviceDisappear
   * @param {{deviceId: string, name: string, phyType: PhyType, remoteIp:
   *     string, remotePort: number, localIp: string}} device
   */
  
  /**
   * Indicate a way to connection is changing. After this event is
   * issued, the module attempt to reconnect by new connection. Before
   * deviceConnChanged event is issued, Web API call may be fail.
   * <br>
   * デバイスへの接続方法が切り替わる事を示す。このイベントが発行され
   * てから、 モジュールは新しい接続での接続処理を行う。deviceConnChanged
   * イベントが受信できるまでは、Web APIは失敗する場合がある。
   *
   * @event deviceConnChanging
   * @param {{deviceId: string, name: string, phyType: PhyType, remoteIp:
   *     string, remotePort: number, localIp: string}} device
   */
  
  /**
   * Indicate a way to connection has been changed. After this event
   * is received caller should get getBaseUrl() again to call Web API.
   * <br>
   * デバイスへの接続方法が切り替わったことを示す。このイベントを受信
   * してから、呼び出し元は getBaseUrl() を再度呼び出して、Web APIをコー
   * ルする。
   *
   * @event deviceConnChanged
   * @param {{deviceId: string, name: string, phyType: PhyType, remoteIp:
   *     string, remotePort: number, localIp: string}} device
   */

  /**
   * Connection change failed. When this event is issued, the module
   * will be disconnected status. But the 'deviceDisappear' event will
   * not be emit.
   * <br>
   * デバイスへの接続方法の切り替えが失敗した。このイベントがとんだ場
   * 合は、モジュールは切断状態になる。ただし、'deviceDisappear'イベン
   * トは発行されない。
   *
   * @event deviceConnChangeFailed
   * @param {Error} error The reason why device connection change failed.
   */
  onDeviceAppear_(device) {
    if ( this.deviceId_ === null ) {
      return;
    }
    if ( device.deviceId !== this.deviceId_ ) {
      return;
    }

    this.device_ = device;
    
    this.emit('deviceAppear', device);
  }

  onDeviceDisappear_(device) {
    if ( this.deviceId_ === null ) {
      return;
    }
    if ( device.deviceId !== this.deviceId_ ) {
      return;
    }

    this.device_ = null;

    this.emit('deviceDisappear', device);
  }

  onDeviceConnChanged_(device) {
    if ( this.deviceId_ === null ) {
      return;
    }
    if ( device.deviceId !== this.deviceId_ ) {
      return;
    }

    this.emit('deviceConnChanging', device);

    this.deviceConnecting_ = device;
    this.connectingThenEmit_ = true;
    if ( ! this.connecting_ ) {
      this.connectInternal_(function(err) {});
    }
  }
  
  onUsbSerialConnected_(device) {
    if ( this.deviceId_ === null ) {
      return;
    }
    if ( device.deviceId !== this.deviceId_ ) {
      return;
    }
    // this.emit('deviceInitiating');
  }
  
  onUsbSerialDisconnected_(device) {
  }

  onUsbEtherConnected_(device) {
  }

  onUsbEtherDisconnected_(device) {
  }

  /**
   *
   */
  close() {
    // discovery.removeListener('deviceAppear', this.deviceAppearHandler_);
    // discovery.removeListener('deviceDisappear', this.deviceDisappearHandler_);
    selector.removeListener('deviceAppear', this.deviceAppearHandler_);
    selector.removeListener('deviceDisappear', this.deviceDisappearHandler_);
    selector.removeListener('deviceConnChanged', this.deviceConnChangedHandler_);
    discovery.removeListener('usbSerialConnected', this.usbSerialConnectedHandler_);
    discovery.removeListener('usbSerialDisconnected', this.usbSerialDisconnectedHandler_);
    discovery.removeListener('usbEtherConnected', this.usbEtherConnectedHandler_);
    discovery.removeListener('usbEtherDisconnected', this.usbEtherDisconnectedHandler_);
  }
}

