//
//  UsbDetector.cpp
//
//  Copyright 2016 Sony Corporation
//

#include "UsbDetector.h"
#include "UsbDeviceFinder.h"
#include "WmDeviceChangeHandler.h"
#include "AutoCriticalSection.h"
#include "macro.h"

#include <tchar.h>
#include <dbt.h>
#include <map>

static CriticalSection sApiCriticalSection;
static CriticalSection cs_sDeviceMap;
static CriticalSection cs_sEventQueue;


// USB機器の接続/切断イベントのobserver一覧
static std::vector<IUsbDetectObserver*> sDetectEventObservers;

// WM_DEVICECHANGE のイベントハンドラー
static WmDeviceChangeHandler sWmDeviceChangeHandler;

// PnP Device ID と USB機器情報 との Map
static std::map<tstring, std::shared_ptr<UsbDevice>> sDeviceMap;

// USB機器の接続/切断のイベントキュー
static std::deque<std::shared_ptr<DeviceEvent>> sEventQueue;

/**
 * イベントキューに未だイベントオブジェクトが残っているか？
 */
bool UsbDetector::HasEvent()
{
	AutoCriticalSection lock(&cs_sEventQueue);
	return !sEventQueue.empty();
}

/**
 * イベントキュー内の全てのイベントオブジェクトを取得する。
 *
 * @param rEventQueue イベントキュー
 */
void UsbDetector::GetAllEvents(
	/*[out]*/ std::deque<std::shared_ptr<DeviceEvent>>& rEventQueue
	)
{
	AutoCriticalSection lock(&cs_sEventQueue);
	rEventQueue = sEventQueue;
	sEventQueue.clear();
}

/**
 * USBの接続/切断検知用のobserverの登録を追加する。
 *
 * @param pObserver USBの接続/切断通知を受け取るobserver
 */
void UsbDetector::AddObserver(/*[in]*/ IUsbDetectObserver* pObserver)
{
	if (std::find(sDetectEventObservers.begin(), sDetectEventObservers.end(), pObserver) == sDetectEventObservers.end()) {
		sDetectEventObservers.push_back(pObserver);
	}
}

/**
 * USBの接続/切断検知用のobserverの登録を削除する。
 *
 * @param pObserver USBの接続/切断通知を受け取るobserver
 */
void UsbDetector::RemoveObserver(/*[in]*/ IUsbDetectObserver* pObserver)
{
	auto it = std::find(sDetectEventObservers.begin(), sDetectEventObservers.end(), pObserver);
	if (it != sDetectEventObservers.end()) {
		sDetectEventObservers.erase(it);
	}
}


/**
 * USB機器の接続/切断の検出処理を開始する。
 * 既にUSB機器の検出を開始済みの場合には一旦終了し、再度開始する。
 */
bool UsbDetector::StartDeteciton(void)
{
	AutoCriticalSection lock(&sApiCriticalSection);

	HRESULT hr = S_OK;
	try {
		// 現在PCに接続されているUSB機器の一覧を作成する
		std::vector<std::shared_ptr<UsbDeviceFinder::USB_DEVICE>> vUsbDeviceList;
		hr = UsbDeviceFinder::EnumUsbDevices(vUsbDeviceList);
		VERIFY(SUCCEEDED(hr), hr, ::_tprintf(_T("[ERROR] UsbDeviceFinder::EnumUsbDevices() failed. [0x%08X]\n"), hr));

		std::vector<std::shared_ptr<UsbDevice>> vDeviceList;
		{
			AutoCriticalSection lock(&cs_sDeviceMap);
			UsbDetector::CreateDeviceMap(vUsbDeviceList, sDeviceMap, vDeviceList);
		}

		// イベントキューに追加
		std::shared_ptr<DeviceEvent> spDeviceEvent = std::make_shared<DeviceEvent>();
		spDeviceEvent->mEventType = DeviceEvent::DETECT_STARTED;
		spDeviceEvent->mDeviceList = vDeviceList;
		{
			AutoCriticalSection lock(&cs_sEventQueue);
			sEventQueue.push_back(spDeviceEvent);
		}

		// USB機器の接続検出を開始する
		hr = sWmDeviceChangeHandler.Start(&UsbDetector::OnStart, &UsbDetector::OnDeviceChange);
		VERIFY(SUCCEEDED(hr), hr, ::_tprintf(_T("[ERROR] sWmDeviceChangeHandler::Start() failed. [0x%08X]\n"), hr));
	}
	catch (const HRESULT hrException) {
		hr = hrException;
	}
	if (FAILED(hr)) {
		AutoCriticalSection lock(&cs_sDeviceMap);
		sDeviceMap.clear();
	}
	return SUCCEEDED(hr);
}

/**
 * WmDeviceChangeHandlerでのイベント検出の準備ができたら呼び出される。
 */
void __stdcall UsbDetector::OnStart(
	/*[in]*/ HRESULT result
	)
{
	// ���o�J�n�C�x���g���ʒm
	for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
		IUsbDetectObserver* pObserver = *it;
		if (pObserver) {
			pObserver->OnDetectStarted(result);
		}
	}
}

/**
 * WmDeviceChangeHandlerでのイベント検出が終了したら呼び出される。
 */
void __stdcall UsbDetector::OnStop(
	/*[in]*/ HRESULT result
	)
{
	// ���o�I���C�x���g���ʒm
	for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
		IUsbDetectObserver* pObserver = *it;
		if (pObserver) {
			pObserver->OnDetectStopped(result);
		}
	}
}


/**
 * USB機器の接続/切断の検出処理を終了する。
 */
void UsbDetector::StopDeteciton(void)
{
	AutoCriticalSection lock(&sApiCriticalSection);

	sWmDeviceChangeHandler.Stop(&UsbDetector::OnStop);

	{
		AutoCriticalSection lock(&cs_sDeviceMap);
		sDeviceMap.clear();
	}

	{
		AutoCriticalSection lock(&cs_sEventQueue);
		sEventQueue.clear();
	}
}

/**
 * PnP Device ID と USB機器情報 との Map を作成する。
 */
void UsbDetector::CreateDeviceMap(
	/*[in]*/ const std::vector<std::shared_ptr<UsbDeviceFinder::USB_DEVICE>>& srcDeviceList,
	/*[out]*/ std::map<tstring, std::shared_ptr<UsbDevice>>& dstDeviceMap,
	/*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& dstDeviceList
	)
{
	dstDeviceMap.clear();
	dstDeviceList.clear();
	for (auto it = srcDeviceList.cbegin(); it != srcDeviceList.cend(); it++) {
		auto spSrcDevice = *it;
		if (!spSrcDevice) {
			::_tprintf(_T("[ERROR] spSrcDevice == null\n"));
			continue;
		}
		if (spSrcDevice->sPnpDeviceId.empty()) {
			::_tprintf(_T("[ERROR] spSrcDevice->sPnpDeviceId == empty\n"));
			continue;
		}

		auto spDstDevice = UsbDetector::ConvertUsbDevice(spSrcDevice);
		dstDeviceMap.insert(std::make_pair(spDstDevice->deviceId, spDstDevice));
		dstDeviceList.push_back(spDstDevice);
	}
}

std::shared_ptr<UsbDevice> UsbDetector::ConvertUsbDevice(
	/*[in]*/ const std::shared_ptr<UsbDeviceFinder::USB_DEVICE>& srcDevice
	)
{
	auto dstDevice = std::make_shared<UsbDevice>();
	dstDevice->deviceId = srcDevice->sPnpDeviceId;
	dstDevice->vendorId = srcDevice->idVendor;
	dstDevice->productId = srcDevice->idProduct;
	dstDevice->vendorName = srcDevice->sManufacturer;
	dstDevice->deviceName = (!srcDevice->sFriendlyName.empty()) ? srcDevice->sFriendlyName : srcDevice->sDeviceDesc;
	dstDevice->serialNumber = srcDevice->sSerialNumber;
	return dstDevice;
}


void __stdcall UsbDetector::OnDeviceChange(
	/*[in]*/ WPARAM wParam,
	/*[in]*/ LPARAM lParam
	)
{
	if (wParam != DBT_DEVICEARRIVAL && wParam != DBT_DEVICEREMOVECOMPLETE) {
		return;
	}

	DEV_BROADCAST_HDR* pHdr = (DEV_BROADCAST_HDR*)lParam;
	if (!pHdr || pHdr->dbch_devicetype != DBT_DEVTYP_DEVICEINTERFACE) {
		return;
	}

	DEV_BROADCAST_DEVICEINTERFACE* pDevInf = (DEV_BROADCAST_DEVICEINTERFACE*)pHdr;
	if (!pDevInf || !pDevInf->dbcc_name) {
		return;
	}

	// PNP Device ID を取得する
	//
	// dbcc_name:
	//		\\?\USB#VID_054C&PID_0BE5#012345678900002#{a5dcbf10-6530-11d2-901f-00c04fb951ed}
	// convert to
	//		USB\VID_054C&PID_0BE5\012345678900002
	//
	tstring sDeviceName = pDevInf->dbcc_name + 4;
	std::string::size_type index = sDeviceName.rfind(_T('#'));
	if (index == std::string::npos) {
		::_tprintf(_T("[ERROR] invalid device ID : %s"), sDeviceName.c_str());
		return;
	}
	tstring sPnpDeviceId = sDeviceName.substr(0, index);
	tstring::size_type pos = sPnpDeviceId.find_first_of(_T('#'));
	while (pos != std::string::npos)
	{
		sPnpDeviceId.replace(pos, 1, _T("\\"));
		pos = sPnpDeviceId.find_first_of(_T('#'), pos + 1);
	}

	// callback する
	if (wParam == DBT_DEVICEARRIVAL) {
		UsbDetector::OnDeviceAdded(sPnpDeviceId);
	}
	else {
		UsbDetector::OnDeviceRemoved(sPnpDeviceId);
	}
}

void UsbDetector::OnDeviceAdded(
	/*[in]*/ tstring& sPnpDeviceId
	)
{
	try {
		// 現在PCに接続されているUSB機器の一覧を取得する
		std::vector<std::shared_ptr<UsbDeviceFinder::USB_DEVICE>> srcDeviceList;
		HRESULT hr = UsbDeviceFinder::FindUsbDevices(sPnpDeviceId, srcDeviceList);
		VERIFY(SUCCEEDED(hr), hr, ::_tprintf(_T("[ERROR] UsbDeviceFinder::FindUsbDevices() failed. [0x%08X]\n"), hr));

		// UsbDevice オブジェクトに変換して通知する
		std::vector<std::shared_ptr<UsbDevice>> dstDeviceList;
		AutoCriticalSection lock(&cs_sDeviceMap);
		for (auto it = srcDeviceList.cbegin(); it != srcDeviceList.cend(); it++) {
			auto spSrcDevice = *it;
			if (!spSrcDevice) {
				::_tprintf(_T("[ERROR] spSrcDevice == null\n"));
				continue;
			}
			if (spSrcDevice->sPnpDeviceId.empty()) {
				::_tprintf(_T("[ERROR] spSrcDevice->sPnpDeviceId == empty\n"));
				continue;
			}

			auto spDstDevice = UsbDetector::ConvertUsbDevice(spSrcDevice);
			sDeviceMap.insert(std::make_pair(spDstDevice->deviceId, spDstDevice));
			dstDeviceList.push_back(spDstDevice);
		}

		// イベントキューに追加
		std::shared_ptr<DeviceEvent> spDeviceEvent = std::make_shared<DeviceEvent>();
		spDeviceEvent->mEventType = DeviceEvent::DEVICE_ADDED;
		spDeviceEvent->mDeviceList = dstDeviceList;
		{
			AutoCriticalSection lock(&cs_sEventQueue);
			sEventQueue.push_back(spDeviceEvent);
		}

		// USB接続イベントを通知
		for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
			IUsbDetectObserver* pObserver = *it;
			if (pObserver) {
				pObserver->OnDeviceAdded();
			}
		}
	}
	catch (...) {
	}
}

void UsbDetector::OnDeviceRemoved(
	/*[in]*/ tstring& sPnpDeviceId
	)
{
	try {
		AutoCriticalSection lock(&cs_sDeviceMap);
		std::shared_ptr<UsbDevice> spDevice;

		// UsbDevice オブジェクトがMapに登録済みか確認する
		tstring deviceId = sPnpDeviceId;
		auto it = sDeviceMap.find(deviceId);
		if (it != sDeviceMap.end()) {
			// 登録済みの場合にはMapから削除する
			spDevice = it->second;
			sDeviceMap.erase(it);
		}
		else {
			// 未登録の場合には通知用にオブジェクトを生成する
			spDevice = std::make_shared<UsbDevice>();
			spDevice->deviceId = sPnpDeviceId;
			spDevice->vendorName = _T("");
			spDevice->deviceName = _T("");

			UINT16	idVendor = 0;
			UINT16	idProduct = 0;
			tstring	sSerialNumber;

			UsbDeviceFinder::ExtractVidPidSerial(sPnpDeviceId, idVendor, idProduct, &sSerialNumber);
			spDevice->vendorId = idVendor;
			spDevice->productId = idProduct;
			spDevice->serialNumber = sSerialNumber;
		}

		// イベントキューに追加
		std::shared_ptr<DeviceEvent> spDeviceEvent = std::make_shared<DeviceEvent>();
		spDeviceEvent->mEventType = DeviceEvent::DEVICE_REMOVED;
		spDeviceEvent->mDeviceList.push_back(spDevice);
		{
			AutoCriticalSection lock(&cs_sEventQueue);
			sEventQueue.push_back(spDeviceEvent);
		}

		// USB切断イベントを通知
		for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
			IUsbDetectObserver* pObserver = *it;
			if (pObserver) {
				pObserver->OnDeviceRemoved();
			}
		}
	}
	catch (...) {
	}
}

/**
 * 指定したVID/PIDを持つUSB機器の一覧を取得する。
 *
 * @param pIdVendor     検索対象のVID (opttional)
 * @param pIdProduct    検索対象のVID (opttional)
 * @param deviceList    検索結果のUSB機器の一覧
 */
void UsbDetector::FindDevice(
	/*[in]*/ const int* pIdVendor,
	/*[in]*/ const int* pIdProduct,
	/*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& deviceList
	) {
	deviceList.clear();
	AutoCriticalSection lock(&cs_sDeviceMap);
	for (auto it = sDeviceMap.cbegin(); it != sDeviceMap.cend(); it++) {
		auto spUsbDevice = it->second;
		if (!spUsbDevice) {
			continue;
		}
		if (pIdVendor && *pIdVendor != spUsbDevice->vendorId) {
			continue;
		}
		if (pIdProduct && *pIdProduct != spUsbDevice->productId) {
			continue;
		}
		deviceList.push_back(spUsbDevice);
	}
}
