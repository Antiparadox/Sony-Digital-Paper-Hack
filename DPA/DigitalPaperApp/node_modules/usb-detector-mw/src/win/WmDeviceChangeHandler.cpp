//
//  WmDeviceChangeHandler.cpp
// 
//  Copyright 2016 Sony Corporation
//

#include "WmDeviceChangeHandler.h"
#include "macro.h"
#include "../Log.h"
#include "WinErrorCode.h"
#include "UsbDeviceFinder.h"

#include <windows.h>
#include <dbt.h>
#include <initguid.h>
#include <usbiodef.h>
#include <tchar.h>


#define WINDOW_NAME _T("WmDeviceChangeHandler::Window")

static OnStart s_fpOnStartCallback = nullptr;
static OnStop s_fpOnStopCallback = nullptr;
static OnWmDeviceChange s_fpCallback = nullptr;

WmDeviceChangeHandler::WmDeviceChangeHandler()
	: hMsgThread(NULL)
	, uMsgThreadId(0)
	, hDevNotify(NULL)
{
}

WmDeviceChangeHandler::~WmDeviceChangeHandler()
{
	this->Stop(nullptr);
}

std::string WmDeviceChangeHandler::Start(
	/*[in]*/ OnStart pOnStartCallback,
	/*[in]*/ OnWmDeviceChange pCallback
	) {
	std::string errMsg;

	try {
		s_fpOnStartCallback = pOnStartCallback;
		s_fpCallback = pCallback;

		this->Stop(nullptr);

		this->hMsgThread = (HANDLE)::_beginthreadex(
			NULL,
			0,
			&WmDeviceChangeHandler::StartMessageThread,
			this,
			0,
			&this->uMsgThreadId
			);
		if (!this->hMsgThread) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("::_beginthreadex() failed. [%S]"), errMsg.c_str());
			throw E_FAIL;
		}
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}

	if (!errMsg.empty() && s_fpOnStartCallback) {
		s_fpOnStartCallback(errMsg);
		s_fpOnStartCallback = nullptr;
	}

	return errMsg;
}

std::string WmDeviceChangeHandler::Stop(
	/*[in]*/ OnStop pOnStopCallback
	)
{
	std::string errMsg;

	try {
		s_fpOnStopCallback = pOnStopCallback;

		while (this->hMsgThread)
		{
			if (!::PostThreadMessage(this->uMsgThreadId, WM_QUIT, 0, 0)) {
				ULONG error = ::GetLastError();
				if (error == ERROR_INVALID_THREAD_ID) {
					// スレッドの起動中の可能性
				}
			}

			ULONG ulResult = ::WaitForSingleObject(this->hMsgThread, 1000);
			if (ulResult == WAIT_OBJECT_0) {
				if (this->hMsgThread) {
					::CloseHandle(this->hMsgThread);
					this->hMsgThread = NULL;
				}
				this->uMsgThreadId = 0;
			}
		}

		if (this->hDevNotify) {
			if (!::UnregisterDeviceNotification(this->hDevNotify)) {
				errMsg = WinErrorCode::GetLastError();
				LOG_ERROR(_T("::UnregisterDeviceNotification() failed. [%S]"), errMsg.c_str());
				throw E_FAIL;
			}
			this->hDevNotify = NULL;
		}
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}

	if (s_fpOnStopCallback) {
		s_fpOnStopCallback(errMsg);
		s_fpOnStopCallback = nullptr;
	}
	if (this->hMsgThread) {
		::CloseHandle(this->hMsgThread);
		this->hMsgThread = NULL;
	}

	return errMsg;
}

UINT __stdcall WmDeviceChangeHandler::StartMessageThread(void* pval) {
	WmDeviceChangeHandler* pThis = (WmDeviceChangeHandler*)pval;
	pThis->MessageThread();
	return 0;
}


UINT WmDeviceChangeHandler::MessageThread(
	) {	
	std::string errMsg;
	try {
		WNDCLASSEX wc = { 0 };
		wc.cbSize = sizeof(WNDCLASSEX);
		wc.lpszClassName = WINDOW_NAME;
		wc.hInstance = ::GetModuleHandle(NULL);
		wc.lpfnWndProc = WmDeviceChangeHandler::WindowProc;
		if (!::RegisterClassEx(&wc)) {
			const ULONG error = ::GetLastError();
			if (error != ERROR_CLASS_ALREADY_EXISTS) {
				errMsg = WinErrorCode::ToString(error);
				LOG_ERROR(_T("::RegisterClassEx() failed. [%S]"), errMsg.c_str());
			}
		}

		HWND hwnd = ::CreateWindowEx(
			/* dwExStyle =		*/ 0,
			/* lpClassName =	*/ WINDOW_NAME,
			/* lpWindowName =	*/ NULL,
			/* dwStyle =		*/ WS_OVERLAPPEDWINDOW,
			/* x =				*/ 0,
			/* y =				*/ 0,
			/* nWidth =			*/ 0,
			/* nHeight =		*/ 0,
			/* hWndParent =		*/ NULL,
			/* hMenu =			*/ 0,
			/* hInstance =		*/ 0,
			/* lpParam =		*/ 0
			);
		if (!hwnd) {
			const ULONG error = ::GetLastError();
			LOG_ERROR(_T("::CreateWindowEx() failed [0x%x]"), error);
			throw HRESULT_FROM_WIN32(error);
		}

		DEV_BROADCAST_DEVICEINTERFACE notifyFilter = { 0 };
		notifyFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
		notifyFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
		notifyFilter.dbcc_classguid = GUID_DEVINTERFACE_USB_DEVICE;

		this->hDevNotify = ::RegisterDeviceNotification(hwnd, &notifyFilter, DEVICE_NOTIFY_WINDOW_HANDLE);
		if (!this->hDevNotify) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("::CreateWindowEx() failed. [%S]"), errMsg.c_str());
			throw E_FAIL;
		}

		if (s_fpOnStartCallback) {
			s_fpOnStartCallback(errMsg);
			s_fpOnStartCallback = nullptr;
		}

		while (TRUE) {
			MSG msg = { 0 };
			if (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
				if (msg.message == WM_QUIT) {
					break;
				}
				else {
					::TranslateMessage(&msg);
					::DispatchMessage(&msg);
				}
			}
			else {
				::WaitMessage();
			}
		}
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}

	if (!errMsg.empty() && s_fpOnStartCallback) {
		s_fpOnStartCallback(errMsg);
		s_fpOnStartCallback = nullptr;
	}

	return 0;
}


LRESULT CALLBACK WmDeviceChangeHandler::WindowProc(
	/*[in]*/ HWND hwnd,
	/*[in]*/ UINT uMsg,
	/*[in]*/ WPARAM wParam,
	/*[in]*/ LPARAM lParam
	) {
	switch (uMsg) {
	case WM_DEVICECHANGE:
		OnDeviceChange(wParam, lParam);
		return 0;

	case WM_DESTROY:
		::PostQuitMessage(0);
		return 0;

	default:
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


void WmDeviceChangeHandler::OnDeviceChange(
	/*[in]*/ WPARAM wParam,
	/*[in]*/ LPARAM lParam
	) {
	if (s_fpCallback) {
		s_fpCallback(wParam, lParam);
	}
}
