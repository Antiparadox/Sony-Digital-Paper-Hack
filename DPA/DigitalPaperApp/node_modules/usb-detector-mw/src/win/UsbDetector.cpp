//
//  UsbDetector.cpp
//
//  Copyright 2016 Sony Corporation
//

#include "UsbDetector.h"
#include "UsbDeviceFinder.h"
#include "WmDeviceChangeHandler.h"
#include "AutoCriticalSection.h"
#include "macro.h"
#include "Utility.h"
#include "../Log.h"
#include "WinErrorCode.h"

#include <tchar.h>
#include <dbt.h>
#include <map>

static CriticalSection cs_sApi;
static CriticalSection cs_sDeviceMap;
static CriticalSection cs_sEventQueue;
static CriticalSection cs_sDetectEventObservers;
static bool sIsRunning = false;

// USB機器の接続/切断イベントのobserver一覧
static std::vector<IUsbDetectObserver*> sDetectEventObservers;

// WM_DEVICECHANGE のイベントハンドラー
static WmDeviceChangeHandler sWmDeviceChangeHandler;

// PnP Device ID と USB機器情報 との Map
static std::map<tstring, std::shared_ptr<UsbDevice>> sDeviceMap;

// USB機器の接続/切断のイベントキュー
static std::deque<std::shared_ptr<DeviceEvent>> sEventQueue;

/**
 * イベントキューに未だイベントオブジェクトが残っているか？
 */
bool UsbDetector::HasEvent()
{
	AutoCriticalSection lock(&cs_sEventQueue);
	return !sEventQueue.empty();
}

/**
 * イベントキュー内の全てのイベントオブジェクトを取得する。
 *
 * @param rEventQueue イベントキュー
 */
void UsbDetector::GetAllEvents(
	/*[out]*/ std::deque<std::shared_ptr<DeviceEvent>>& rEventQueue
	)
{
	AutoCriticalSection lock(&cs_sEventQueue);
	rEventQueue = sEventQueue;
	sEventQueue.clear();
}

/**
 * USBの接続/切断検知用のobserverの登録を追加する。
 *
 * @param pObserver USBの接続/切断通知を受け取るobserver
 */
void UsbDetector::AddObserver(/*[in]*/ IUsbDetectObserver* pObserver)
{
	AutoCriticalSection lock(&cs_sDetectEventObservers);

	if (std::find(sDetectEventObservers.begin(), sDetectEventObservers.end(), pObserver) == sDetectEventObservers.end()) {
		sDetectEventObservers.push_back(pObserver);
	}
}

/**
 * USBの接続/切断検知用のobserverの登録を削除する。
 *
 * @param pObserver USBの接続/切断通知を受け取るobserver
 */
void UsbDetector::RemoveObserver(/*[in]*/ IUsbDetectObserver* pObserver)
{
	AutoCriticalSection lock(&cs_sDetectEventObservers);

	auto it = std::find(sDetectEventObservers.begin(), sDetectEventObservers.end(), pObserver);
	if (it != sDetectEventObservers.end()) {
		sDetectEventObservers.erase(it);
	}
}


/**
 * USB機器の接続/切断の検出処理を開始する。
 * 既にUSB機器の検出を開始済みの場合には一旦終了し、再度開始する。
 */
std::string UsbDetector::StartDeteciton(void)
{
	AutoCriticalSection lock(&cs_sApi);
	std::string errMsg;

	try {
		// 現在PCに接続されているUSB機器の一覧を作成する
		std::vector<std::shared_ptr<UsbDeviceFinder::USB_DEVICE>> vUsbDeviceList;
		errMsg = UsbDeviceFinder::EnumUsbDevices(vUsbDeviceList);
		if (!errMsg.empty()) {
			LOG_ERROR(_T("UsbDeviceFinder::EnumUsbDevices() failed. [%S]"), errMsg.c_str());
			throw E_FAIL;
		}

		std::vector<std::shared_ptr<UsbDevice>> vDeviceList;
		{
			AutoCriticalSection lock(&cs_sDeviceMap);
			UsbDetector::CreateDeviceMap(vUsbDeviceList, sDeviceMap, vDeviceList);
		}

		// イベントキューに追加
		std::shared_ptr<DeviceEvent> spDeviceEvent = std::make_shared<DeviceEvent>();
		spDeviceEvent->mEventType = DeviceEvent::DETECT_STARTED;
		spDeviceEvent->mDeviceList = vDeviceList;
		{
			AutoCriticalSection lock(&cs_sEventQueue);
			sEventQueue.push_back(spDeviceEvent);
		}

		// USB機器の接続検出を開始する
		errMsg = sWmDeviceChangeHandler.Start(&UsbDetector::OnStart, &UsbDetector::OnDeviceChange);
		if (!errMsg.empty()) {
			LOG_ERROR(_T("WmDeviceChangeHandler::Start() failed. [%S]"), errMsg.c_str());
			throw E_FAIL;
		}
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}

	if (!errMsg.empty()) {
		AutoCriticalSection lock(&cs_sDeviceMap);
		sDeviceMap.clear();
	}

	return errMsg;
}

/**
 * WmDeviceChangeHandlerでのイベント検出の準備ができたら呼び出される。
 */
void __stdcall UsbDetector::OnStart(
	/*[in]*/ std::string errMsg
	)
{
	// USB機器の接続/切断イベント検出開始を通知する
	AutoCriticalSection lock(&cs_sDetectEventObservers);
	for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
		IUsbDetectObserver* pObserver = *it;
		if (pObserver) {
			pObserver->OnDetectStarted(errMsg);
		}
	}
	sIsRunning = true;
}

/**
 * WmDeviceChangeHandlerでのイベント検出が終了したら呼び出される。
 */
void __stdcall UsbDetector::OnStop(
	/*[in]*/ std::string errMsg
	)
{
	// USB機器の接続/切断イベント検出終了を通知する
	AutoCriticalSection lock(&cs_sDetectEventObservers);
	for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
		IUsbDetectObserver* pObserver = *it;
		if (pObserver) {
			pObserver->OnDetectStopped(errMsg);
		}
	}
	sIsRunning = false;
}

/**
 * イベント検出処理が動作中か？
 */
bool UsbDetector::IsRunning() {
	return sIsRunning;
}

/**
 * USB機器の接続/切断の検出処理を終了する。
 */
std::string UsbDetector::StopDeteciton(void)
{
	AutoCriticalSection lock(&cs_sApi);

	std::string error;

	sWmDeviceChangeHandler.Stop(&UsbDetector::OnStop);

	{
		AutoCriticalSection lock(&cs_sDeviceMap);
		sDeviceMap.clear();
	}

	{
		AutoCriticalSection lock(&cs_sEventQueue);
		sEventQueue.clear();
	}

	return error;
}

/**
 * PnP Device ID と USB機器情報 との Map を作成する。
 */
void UsbDetector::CreateDeviceMap(
	/*[in]*/ const std::vector<std::shared_ptr<UsbDeviceFinder::USB_DEVICE>>& srcDeviceList,
	/*[out]*/ std::map<tstring, std::shared_ptr<UsbDevice>>& dstDeviceMap,
	/*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& dstDeviceList
	)
{
	dstDeviceMap.clear();
	dstDeviceList.clear();
	for (auto it = srcDeviceList.cbegin(); it != srcDeviceList.cend(); it++) {
		auto spSrcDevice = *it;
		if (!spSrcDevice) {
			LOG_ERROR(_T("spSrcDevice == null"));
			continue;
		}
		if (spSrcDevice->sPnpDeviceId.empty()) {
			LOG_ERROR(_T("spSrcDevice->sPnpDeviceId == empty"));
			continue;
		}

		auto spDstDevice = UsbDetector::ConvertUsbDevice(spSrcDevice);
		dstDeviceMap.insert(std::make_pair(spDstDevice->deviceId, spDstDevice));
		dstDeviceList.push_back(spDstDevice);
	}
}

std::shared_ptr<UsbDevice> UsbDetector::ConvertUsbDevice(
	/*[in]*/ const std::shared_ptr<UsbDeviceFinder::USB_DEVICE>& srcDevice
	)
{
	auto dstDevice = std::make_shared<UsbDevice>();
	dstDevice->deviceId = Utility::ToUpper(srcDevice->sPnpDeviceId);
	dstDevice->vendorId = srcDevice->idVendor;
	dstDevice->productId = srcDevice->idProduct;
	dstDevice->vendorName = srcDevice->sManufacturer;
	dstDevice->deviceName = (!srcDevice->sFriendlyName.empty()) ? srcDevice->sFriendlyName : srcDevice->sDeviceDesc;
	dstDevice->serialNumber = srcDevice->sSerialNumber;
	return dstDevice;
}


void __stdcall UsbDetector::OnDeviceChange(
	/*[in]*/ WPARAM wParam,
	/*[in]*/ LPARAM lParam
	)
{
	if (wParam != DBT_DEVICEARRIVAL && wParam != DBT_DEVICEREMOVECOMPLETE) {
		return;
	}

	DEV_BROADCAST_HDR* pHdr = (DEV_BROADCAST_HDR*)lParam;
	if (!pHdr || pHdr->dbch_devicetype != DBT_DEVTYP_DEVICEINTERFACE) {
		return;
	}

	DEV_BROADCAST_DEVICEINTERFACE* pDevInf = (DEV_BROADCAST_DEVICEINTERFACE*)pHdr;
	if (!pDevInf || !pDevInf->dbcc_name) {
		return;
	}

	// PNP Device ID を取得する
	//
	// dbcc_name:
	//		\\?\USB#VID_054C&PID_0BE5#012345678900002#{a5dcbf10-6530-11d2-901f-00c04fb951ed}
	// convert to
	//		USB\VID_054C&PID_0BE5\012345678900002
	//
	tstring sDeviceName = pDevInf->dbcc_name + 4;
	std::string::size_type index = sDeviceName.rfind(_T('#'));
	if (index == std::string::npos) {
		LOG_ERROR(_T("invalid device ID : %s"), sDeviceName.c_str());
		return;
	}

	tstring sPnpDeviceId = sDeviceName.substr(0, index);
	tstring::size_type pos = sPnpDeviceId.find_first_of(_T('#'));
	while (pos != std::string::npos)
	{
		sPnpDeviceId.replace(pos, 1, _T("\\"));
		pos = sPnpDeviceId.find_first_of(_T('#'), pos + 1);
	}

	sPnpDeviceId = Utility::ToUpper(sPnpDeviceId);

	// callback する
	if (wParam == DBT_DEVICEARRIVAL) {
		UsbDetector::OnDeviceAdded(sPnpDeviceId);
	}
	else {
		UsbDetector::OnDeviceRemoved(sPnpDeviceId);
	}
}

void UsbDetector::OnDeviceAdded(
	/*[in]*/ tstring& sPnpDeviceId
	) {
	tstring sUpperCasePnpDeviceId = Utility::ToUpper(sPnpDeviceId);

	std::string errMsg;
	try {
		// 現在PCに接続されているUSB機器の一覧を取得する
		std::vector<std::shared_ptr<UsbDeviceFinder::USB_DEVICE>> srcDeviceList;
		errMsg = UsbDeviceFinder::FindUsbDevices(sUpperCasePnpDeviceId, srcDeviceList);
		if (!errMsg.empty()) {
			LOG_ERROR(_T("UsbDeviceFinder::FindUsbDevices(%s) failed. [%S]"), sUpperCasePnpDeviceId.c_str(), errMsg.c_str());
			throw E_FAIL;
		}

		// UsbDevice オブジェクトに変換して通知する
		std::vector<std::shared_ptr<UsbDevice>> dstDeviceList;
		AutoCriticalSection lock(&cs_sDeviceMap);
		for (auto it = srcDeviceList.cbegin(); it != srcDeviceList.cend(); it++) {
			auto spSrcDevice = *it;
			if (!spSrcDevice) {
				LOG_ERROR(_T("spSrcDevice == null"));
				continue;
			}
			if (spSrcDevice->sPnpDeviceId.empty()) {
				LOG_ERROR(_T("spSrcDevice->sPnpDeviceId == empty"));
				continue;
			}

			auto spDstDevice = UsbDetector::ConvertUsbDevice(spSrcDevice);
			sDeviceMap.insert(std::make_pair(spDstDevice->deviceId, spDstDevice));
			dstDeviceList.push_back(spDstDevice);
		}

		// イベントキューに追加
		std::shared_ptr<DeviceEvent> spDeviceEvent = std::make_shared<DeviceEvent>();
		spDeviceEvent->mEventType = DeviceEvent::DEVICE_ADDED;
		spDeviceEvent->mDeviceList = dstDeviceList;
		
		{
			AutoCriticalSection lock(&cs_sEventQueue);
			sEventQueue.push_back(spDeviceEvent);
		}

		// USB接続イベントを通知
		{
			AutoCriticalSection lock(&cs_sDetectEventObservers);
			for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
				IUsbDetectObserver* pObserver = *it;
				if (pObserver) {
					pObserver->OnDeviceAdded();
				}
			}
		}
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}
}

void UsbDetector::OnDeviceRemoved(
	/*[in]*/ tstring& sPnpDeviceId
	)
{
	tstring sUpperCasePnpDeviceId = Utility::ToUpper(sPnpDeviceId);

	try {
		AutoCriticalSection lock(&cs_sDeviceMap);
		std::shared_ptr<UsbDevice> spDevice;

		// UsbDevice オブジェクトがMapに登録済みか確認する
		auto it = sDeviceMap.find(sUpperCasePnpDeviceId);
		if (it != sDeviceMap.end()) {
			// 登録済みの場合にはMapから削除する
			spDevice = it->second;
			sDeviceMap.erase(it);
		}
		else {
			// 未登録の場合には通知用にオブジェクトを生成する
			spDevice = std::make_shared<UsbDevice>();
			spDevice->deviceId = sUpperCasePnpDeviceId;
			spDevice->vendorName = _T("");
			spDevice->deviceName = _T("");

			UINT16	idVendor = 0;
			UINT16	idProduct = 0;
			tstring	sSerialNumber;

			UsbDeviceFinder::ExtractVidPidSerial(sUpperCasePnpDeviceId, idVendor, idProduct, &sSerialNumber);
			spDevice->vendorId = idVendor;
			spDevice->productId = idProduct;
			spDevice->serialNumber = sSerialNumber;
		}

		// イベントキューに追加
		std::shared_ptr<DeviceEvent> spDeviceEvent = std::make_shared<DeviceEvent>();
		spDeviceEvent->mEventType = DeviceEvent::DEVICE_REMOVED;
		spDeviceEvent->mDeviceList.push_back(spDevice);

		{
			AutoCriticalSection lock(&cs_sEventQueue);
			sEventQueue.push_back(spDeviceEvent);
		}

		// USB切断イベントを通知
		{
			AutoCriticalSection lock(&cs_sDetectEventObservers);
			for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
				IUsbDetectObserver* pObserver = *it;
				if (pObserver) {
					pObserver->OnDeviceRemoved();
				}
			}
		}
	}
	catch (...) {
		std::string errMsg = WinErrorCode::GetLastError();
		LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
	}
}

/**
 * 指定したVID/PIDを持つUSB機器の一覧を取得する。
 *
 * @param pIdVendor     検索対象のVID (opttional)
 * @param pIdProduct    検索対象のVID (opttional)
 * @param deviceList    検索結果のUSB機器の一覧
 */
std::string UsbDetector::FindDevice(
	/*[in]*/ const int* pIdVendor,
	/*[in]*/ const int* pIdProduct,
	/*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& deviceList
	) {
	deviceList.clear();

	if (!sIsRunning) {
		return std::string("USB detector is not running.");
	} else {
		AutoCriticalSection lock(&cs_sDeviceMap);
		
		for (auto it = sDeviceMap.cbegin(); it != sDeviceMap.cend(); it++) {
			auto spUsbDevice = it->second;
			if (!spUsbDevice) {
				continue;
			}

			if ((pIdVendor != nullptr) && (*pIdVendor != spUsbDevice->vendorId)) {
				continue;
			}

			if ((pIdProduct != nullptr) && (*pIdProduct != spUsbDevice->productId)) {
				continue;
			}

			deviceList.push_back(spUsbDevice);
		}

		return std::string();
	}
}
