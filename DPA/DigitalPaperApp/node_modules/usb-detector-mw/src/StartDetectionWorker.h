//
//  StartDetectionWorker.h
//
//  Copyright 2016 Sony Corporation
//

#pragma once

#include <nan.h>
#include "UsbDetectManager.h"
#include "WaitDetectionWorker.h"
#include "Event.h"

class StartDetectionWorker : public Nan::AsyncWorker, IUsbDetectObserver
{
private:
	Event mDetectEvent;
    Nan::Callback* mStartCallback;
    Nan::Callback* mAddCallback;
    Nan::Callback* mRemoveCallback;
	int mIdVendor;
	int mIdProduct;

public:    
    /**
     * Constructor
     *
	 * @param idVendor			検索対象のUSB機器のVID (0の場合には全てのidVendorが対象)
	 * @param idProduct			検索対象のUSB機器のPID (0の場合には全てのidProductが対象)
	 * @param startCallback     USB機器の接続/切断検出処理が開始された際のcallback
     * @param addCallback       USB機器が接続された際のcallback
     * @param removeCallback    USB機器が切断された際のcallback
     */
    StartDetectionWorker(
		/*[in]*/ int idVendor,
		/*[in]*/ int idProduct,
        /*[in]*/ Nan::Callback* startCallback,
        /*[in]*/ Nan::Callback* addCallback,
        /*[in]*/ Nan::Callback* removeCallback
		) :
		Nan::AsyncWorker(startCallback),
		mStartCallback(startCallback),
		mAddCallback(addCallback),
		mRemoveCallback(removeCallback),
		mIdVendor(idVendor),
		mIdProduct(idProduct)
	{
	}

	/**
	 * Destructor
	 */ 
	virtual ~StartDetectionWorker()
	{
		// USB機器の接続/切断イベントのcallbackを解放する
		UsbDetectManager::RemoveObserver(this);
	}

	/**
	 * Executed inside the worker-thread.
	 * It is not safe to access V8, or V8 data structures
	 * here, so everything we need for input and output
	 * should go on `this`.
	 */
    virtual void Execute()
    {
		// USB機器の接続/切断イベントのcallbackを設定する
        UsbDetectManager::AddObserver(this);
        
        // USB機器の接続/切断検出処理を開始する
		const std::string error = UsbDetectManager::StartDeteciton();
		if (!error.empty()) {
			this->SetErrorMessage(error.c_str());
			return;
		}

		// 開始処理を待機する
    	this->mDetectEvent.Wait();
    }
    
	/**
	 * Executed when the async work is complete
	 * this function will be run inside the main event loop
	 * so it is safe to use V8 again
	 */
    virtual void HandleOKCallback()
    {
		Nan::HandleScope scope;

		// USB機器の接続/切断イベントのcallbackを解放する
        UsbDetectManager::RemoveObserver(this);
        
        // イベントキューを取得する
        std::deque<std::shared_ptr<DeviceEvent>> eventQueue;
        UsbDetectManager::GetAllEvents(eventQueue);
        
        // イベントキューを順番に読み込んで、イベントをcallbackする
        for (auto it = eventQueue.cbegin(); it != eventQueue.cend(); it++) {
            std::shared_ptr<DeviceEvent> spEvent = *it;
            
            // USB機器の接続/切断検出開始時
            if (spEvent->mEventType == DeviceEvent::DETECT_STARTED) {
                int i = 0;
                v8::Local<v8::Array> array = Nan::New<v8::Array>();
                for (auto it = spEvent->mDeviceList.begin(); it != spEvent->mDeviceList.end(); it++) {
					std::shared_ptr<UsbDevice> spDevice = (*it);
					if (this->mIdVendor != 0 && this->mIdVendor != spDevice->vendorId) {
						continue;
					}
					if (this->mIdProduct != 0 && this->mIdProduct != spDevice->productId) {
						continue;
					}
					v8::Local<v8::Object> item = spDevice->genV8Object();
                    array->Set(i++, item);
                }
                const unsigned argc = 2;
                v8::Local<v8::Value> argv[] = {
					Nan::Null(),
					array,
                };
				this->mStartCallback->Call(argc, argv);
                continue;
            }
            
            // USB機器の接続/切断検出時            
            for (auto it = spEvent->mDeviceList.begin(); it != spEvent->mDeviceList.end(); it++) {
                v8::Local<v8::Object> item = (*it)->genV8Object();
                
                const unsigned argc = 1;
                v8::Local<v8::Value> argv[] = {
                    item,
                };
            
                // コールバック呼び出し
                switch (spEvent->mEventType) {
                    case DeviceEvent::DEVICE_ADDED:
                        this->mAddCallback->Call(argc, argv);
                        break;
                    case DeviceEvent::DEVICE_REMOVED:
                        this->mRemoveCallback->Call(argc, argv);
                        break;
                    default:
                        break;
                }
            }
        }
        
		// 次のイベント検出を開始する
        Nan::AsyncQueueWorker(
			new WaitDetectionWorker(
                this->mAddCallback,
                this->mRemoveCallback
                ));        
    }    

	/**
	 * Executed when the async work is failed
	 * this function will be run inside the main event loop
	 * so it is safe to use V8 again
	 */
	virtual void HandleErrorCallback()
	{
		Nan::HandleScope scope;

		const int argc = 2;
		v8::Local<v8::Value> argv[] = {
			Nan::Error(this->ErrorMessage()),
			Nan::Undefined(),
		};
		
		callback->Call(argc, argv);
	}


    /**
     * USB機器の接続/切断検出処理が開始された際に呼び出される。
     */
	virtual void OnDetectStarted(/*[in]*/ std::string error)
	{
		if (!error.empty()) {
			this->SetErrorMessage(error.c_str());
		}
		this->mDetectEvent.Signal();
    }
    
    /**
     * USB機器の接続/切断検出処理が終了された場合に呼び出される。
     */
	virtual void OnDetectStopped(/*[in]*/ std::string error) {
    }
    
    /**
     * USB機器の接続が検出された場合に呼び出される。
     */
    virtual void OnDeviceAdded(void) {
    }
    
    /**
     * USB機器の切断が検出された場合に呼び出される。
     */
    virtual void OnDeviceRemoved(void) {
    }
};
