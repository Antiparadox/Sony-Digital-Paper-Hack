//
//  UsbDetector.cpp
//
//  Copyright 2016 Sony Corporation
//

#include "UsbDetector.h"
#include "AutoCFString.h"
#include "MacErrorCode.h"
#include "../Log.h"

#include <IOKit/IOKitLib.h>
#include <IOKit/IOMessage.h>
#include <IOKit/IOCFPlugIn.h>
#include <IOKit/IOBSD.h>
#include <mach/mach.h>
#include <map>


static IONotificationPort*	sNotifyPort = nullptr;
static io_iterator_t		sDeviceAddedIterator = 0;
static __CFRunLoop*         sRunLoop = nullptr;
static pthread_t            sRunLoopThreadId;
static pthread_mutex_t      sApiMutex           = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;
static pthread_mutex_t      sEventQueueMutex    = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;
static pthread_mutex_t      sDeviceMapMutex     = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;
static pthread_mutex_t      sShutdownMutex      = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;
static pthread_cond_t       sShutdownCompleted  = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;
static bool                 sIsRunning = false;

// USBの接続/切断通知用のobserver一覧
static std::vector<IUsbDetectObserver*> sDetectEventObservers;

// Device ID (Path Name) と USB機器情報 との Map
static std::map<std::string, std::shared_ptr<UsbDevice>> sDeviceMap;

// USB機器の接続/切断のイベントキュー
static std::deque<std::shared_ptr<DeviceEvent>> sEventQueue;

/**
 * IOServiceAddMatchingNotification(),IOServiceAddInterestNotification() に登録した
 */
class NotificationData {
public:
    io_object_t                 notification;
    IOUSBDeviceInterface**      ppDeviceInterface;
    std::shared_ptr<UsbDevice>  spUsbDevice;
    
    NotificationData() : notification(0), ppDeviceInterface(NULL) {
    }
    
    ~NotificationData() {
        if (ppDeviceInterface) {
            (*ppDeviceInterface)->Release(ppDeviceInterface);
            ppDeviceInterface = NULL;
        }
        if (notification) {
            IOObjectRelease(notification);
            notification = 0;
        }
    }
};
static std::map<std::string, std::shared_ptr<NotificationData>> sNotificationMap;


/**
 * イベントキューに未だイベントオブジェクトが残っているか？
 */
bool UsbDetector::HasEvent() {
    bool isEmpty = false;
    ::pthread_mutex_lock(&sEventQueueMutex);
    isEmpty = sEventQueue.empty();
    ::pthread_mutex_unlock(&sEventQueueMutex);
    return !isEmpty;
}

/**
 * イベントキュー内の全てのイベントオブジェクトを取得する。
 *
 * @param rEventQueue イベントキュー
 */
void UsbDetector::GetAllEvents(/*[out]*/ std::deque<std::shared_ptr<DeviceEvent>>& rEventQueue) {
    ::pthread_mutex_lock(&sEventQueueMutex);
    rEventQueue = sEventQueue;
    sEventQueue.clear();
    ::pthread_mutex_unlock(&sEventQueueMutex);
}

/**
 * USBの接続/切断通知用のobserverを追加する。
 *
 * @param pObserver USB接続/切断の通知先obaserver
 */
void UsbDetector::AddObserver(/*[in]*/ IUsbDetectObserver* pObserver)
{
	if (std::find(sDetectEventObservers.begin(), sDetectEventObservers.end(), pObserver) == sDetectEventObservers.end()) {
		sDetectEventObservers.push_back(pObserver);
	}
}

/**
* USBの接続/切断通知用のobserverを削除する。
* USBの接続/切断検知用のcallbackを登録する。
*
* @param pObserver USB接続/切断の通知先obaserver
*/
void UsbDetector::RemoveObserver(/*[in]*/ IUsbDetectObserver* pObserver)
{
	auto it = std::find(sDetectEventObservers.begin(), sDetectEventObservers.end(), pObserver);
	if (it != sDetectEventObservers.end()) {
		sDetectEventObservers.erase(it);
	}
}


/**
 * USB機器の接続/切断の検出処理を開始する。
 * 既にUSB機器の検出を開始済みの場合には一旦終了し、再度開始する。
 */
std::string UsbDetector::StartDeteciton(void)
{
    std::string errMsg;
    ::pthread_mutex_lock(&sApiMutex);
    try {
        bool isStarted = false;
        ::pthread_mutex_lock(&sShutdownMutex);
        isStarted =  sIsRunning;
        ::pthread_mutex_unlock(&sShutdownMutex);

        if (isStarted) {
            StopDeteciton();
        }

        const int result = ::pthread_create(&sRunLoopThreadId, NULL, &UsbDetector::StartRunLoop, NULL);
        if (result) {
            errMsg = MacErrorCode::ToString(result);
            LOG_ERROR("pthread_create() failed. [%s]", errMsg.c_str());
            throw result;
        }
    } catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
            LOG_ERROR("Unknown error occurred. [%s]", errMsg.c_str());
        }
    }
    ::pthread_mutex_unlock(&sApiMutex);
    return errMsg;
}

/**
 * USB機器の検出を開始する。
 */
void* UsbDetector::StartRunLoop(/*[in]*/ void* param)
{
    std::string errMsg;
    kern_return_t kr = kIOReturnSuccess;
    mach_port_t masterPort = 0;
    
    ::pthread_mutex_lock(&sShutdownMutex);
    sIsRunning = true;
    ::pthread_mutex_unlock(&sShutdownMutex);
    
    try {
        // Master IOKit Port の作成
        kr = IOMasterPort(MACH_PORT_NULL, &masterPort);
        if (kIOReturnSuccess != kr || !masterPort) {
            errMsg = std::to_string(kr) + ": IOMasterPort(MACH_PORT_NULL) failed.";
            LOG_ERROR(errMsg.c_str());
            throw kr;
        }
        
        // USB matching dictionary の作成
        CFMutableDictionaryRef matchingDict = IOServiceMatching(kIOUSBDeviceClassName);
        if (!matchingDict) {
            errMsg = std::to_string(kr) + ": IOServiceMatching(kIOUSBDeviceClassName)failed.";
            LOG_ERROR(errMsg.c_str());
            throw kr;
        }
        
        // Notfication Port の作成
        sNotifyPort = IONotificationPortCreate(masterPort);
        CFRunLoopSourceRef runLoopSource = IONotificationPortGetRunLoopSource(sNotifyPort);
        
        sRunLoop = CFRunLoopGetCurrent();
        CFRunLoopAddSource(sRunLoop, runLoopSource, kCFRunLoopDefaultMode);
        
        // USB機器の接続検出用のcallbackを登録する
        kr = IOServiceAddMatchingNotification(sNotifyPort,                  // notifyPort
                                              kIOFirstMatchNotification,	// notificationType
                                              matchingDict,                 // matching
                                              OnDeviceAdded,                // callback
                                              NULL,                         // refCon
                                              &sDeviceAddedIterator         // notification
                                              );
        // 現在Macに接続されているUSB機器を検出する
        EnumDevices(sDeviceAddedIterator, /* isAdded = */ false);
        
        // Master IOKit Port の解放
        mach_port_deallocate(mach_task_self(), masterPort);
        masterPort = 0;
        
        // 検出開始イベントを通知
        for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
            IUsbDetectObserver* pObserver = *it;
            if (pObserver) {
                pObserver->OnDetectStarted(errMsg);
            }
        }

        // Run Loop を開始
        CFRunLoopRun();
        
        kr = kIOReturnSuccess;
    }
    catch (kern_return_t krException) {
        if (krException == kIOReturnSuccess) {
            kr = kIOReturnError;
        }
    }
    catch (...) {
        kr = kIOReturnError;
    }

    if (kr != kIOReturnSuccess) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
            LOG_ERROR("Unknown error occurred. [%s]", errMsg.c_str());
        }
        
        // 検出開始イベントを通知
        for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
            IUsbDetectObserver* pObserver = *it;
            if (pObserver) {
                pObserver->OnDetectStarted(errMsg);
            }
        }
    }
    
    if (masterPort) {
        mach_port_deallocate(mach_task_self(), masterPort);
        masterPort = 0;
    }
    
    ::pthread_mutex_lock(&sShutdownMutex);
    sIsRunning = false;
    ::pthread_cond_signal(&sShutdownCompleted);
    ::pthread_mutex_unlock(&sShutdownMutex);
    
    return 0;
}

/**
 * USB機器の接続/切断の検出処理を終了する。
 */
std::string UsbDetector::StopDeteciton()
{
    std::string errMsg;
    ::pthread_mutex_lock(&sApiMutex);
    try {
        if (sNotifyPort) {
            IONotificationPortDestroy(sNotifyPort);
        }
        
        ::pthread_mutex_lock(&sShutdownMutex);
        if (sIsRunning) {
            pthread_cond_wait(&sShutdownCompleted, &sShutdownMutex);
        }
        ::pthread_mutex_unlock(&sShutdownMutex);
        
        sNotifyPort = nullptr;
        
        if (sDeviceAddedIterator) {
            IOObjectRelease(sDeviceAddedIterator);
            sDeviceAddedIterator = 0;
        }

        ::pthread_mutex_lock(&sDeviceMapMutex);
        sDeviceMap.clear();
        ::pthread_mutex_unlock(&sDeviceMapMutex);
        
        ::pthread_mutex_lock(&sEventQueueMutex);
        sEventQueue.clear();
        ::pthread_mutex_unlock(&sEventQueueMutex);

        sNotificationMap.clear();
	}
    catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
            LOG_ERROR("Unknown error occurred. [%s]", errMsg.c_str());
        }
    }
    // 検出終了イベントを通知
    for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
        IUsbDetectObserver* pObserver = *it;
        if (pObserver) {
            pObserver->OnDetectStopped(errMsg);
        }
    }
    ::pthread_mutex_unlock(&sApiMutex);
    return errMsg;
}

/**
 * USB機器の接続/切断の検出処理が動作中か？
 */
bool UsbDetector::IsRunning() {
    return sIsRunning;
}

/**
 * MacにUSB機器が接続された場合に呼び出される。
 *
 * IOServiceAddMatchingNotification に登録したcallbak関数。
 */
void UsbDetector::OnDeviceAdded(
                                /*[in]*/ void* refCon,
                                /*[in]*/ io_iterator_t iterator
                                )
{
    UsbDetector::EnumDevices(iterator, /* isAdded = */ true);
}

void UsbDetector::EnumDevices(
                              /*[in]*/ io_iterator_t iterator,
                              /*[in]*/ bool isAdded
                                )
{
    kern_return_t kr = kIOReturnSuccess;
    
    io_service_t device;
    std::vector<std::shared_ptr<UsbDevice>> vDeviceList;
    while ( (device = IOIteratorNext(iterator)) )
    {
        std::shared_ptr<NotificationData> spNotification = std::make_shared<NotificationData>();
        
        std::shared_ptr<UsbDevice> spUsbDevice = std::make_shared<UsbDevice>();
        kr = UsbDetector::GetDeviceInfo(device, spUsbDevice, &spNotification->ppDeviceInterface);
        if (kr != kIOReturnSuccess || spUsbDevice->deviceId.empty()) {
            LOG_ERROR("UsbDetector::GetDeviceInfo() failed [0x%08X]", kr);
            IOObjectRelease(device);
            continue;
        }
        
        ::pthread_mutex_lock(&sDeviceMapMutex);
        sDeviceMap.insert(std::make_pair(spUsbDevice->deviceId, spUsbDevice));
        ::pthread_mutex_unlock(&sDeviceMapMutex);

        spNotification->spUsbDevice = spUsbDevice;
        vDeviceList.push_back(spUsbDevice);
        
        // USB切断の検出用のcallbackを登録する
        kr = IOServiceAddInterestNotification(
                                              sNotifyPort,                      // notifyPort
                                              device,                           // service
                                              kIOGeneralInterest,               // interestType
                                              UsbDetector::OnDeviceRemoved,     // callback
                                              spNotification.get(),                    // refCon
                                              &(spNotification->notification)	// notification
                                              );
        
        if (kr == kIOReturnSuccess) {
            sNotificationMap.insert(std::make_pair(spUsbDevice->deviceId, spNotification));
        } else {
            LOG_ERROR("IOServiceAddInterestNotification() failed. [0x%08X]", kr);
        }
        
        // io_service_t の解放
        IOObjectRelease(device);
    }

    // イベントキューに追加
    std::shared_ptr<DeviceEvent> spDeviceEvent = std::make_shared<DeviceEvent>();
    spDeviceEvent->mEventType = isAdded ? DeviceEvent::DEVICE_ADDED : DeviceEvent::DETECT_STARTED;
    spDeviceEvent->mDeviceList = vDeviceList;    
    {
        ::pthread_mutex_lock(&sEventQueueMutex);
        sEventQueue.push_back(spDeviceEvent);
        ::pthread_mutex_unlock(&sEventQueueMutex);
    }
    
    // USB接続検出イベントを通知
    if (isAdded) {
        for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
            IUsbDetectObserver* pObserver = *it;
            if (pObserver) {
                pObserver->OnDeviceAdded();
            }
        }
    }
}


/**
 * MacからUSB機器が切断された場合などに呼び出される。
 * IOServiceAddInterestNotification に登録したcallbak関数。
 */
void UsbDetector::OnDeviceRemoved(
                            void *          refCon,
                            io_service_t 	service,
                            natural_t       messageType,
                            void *          messageArgument
                            )
{
    NotificationData* pNotification = (NotificationData*)refCon;
    if (!pNotification) {
        LOG_ERROR("pNotification == null");
        return ;
    }
    
    if (messageType != kIOMessageServiceIsTerminated)
    {
        return ;
    }

    if (!pNotification->spUsbDevice) {
        LOG_ERROR("spUsbDevice == null");
        return ;
    }
    
    std::string deviceId = pNotification->spUsbDevice->deviceId;
    std::shared_ptr<NotificationData> spNotifcation = sNotificationMap.at(deviceId);

    ::pthread_mutex_lock(&sDeviceMapMutex);
    auto itDevice = sDeviceMap.find(deviceId);
    if (itDevice != sDeviceMap.end()) {
        sDeviceMap.erase(itDevice);
    }
    ::pthread_mutex_unlock(&sDeviceMapMutex);
    
    auto itNotification = sNotificationMap.find(deviceId);
    if (itNotification != sNotificationMap.end()) {
        sNotificationMap.erase(itNotification);
    }
    
    // Event Queue に追加
    std::shared_ptr<DeviceEvent> spDeviceEvent = std::make_shared<DeviceEvent>();
    spDeviceEvent->mEventType = DeviceEvent::DEVICE_REMOVED;
    spDeviceEvent->mDeviceList.push_back(spNotifcation->spUsbDevice);

    ::pthread_mutex_lock(&sEventQueueMutex);
    sEventQueue.push_back(spDeviceEvent);
    ::pthread_mutex_unlock(&sEventQueueMutex);

    // USB切断検出イベントを通知
    for (auto it = sDetectEventObservers.begin(); it != sDetectEventObservers.end(); it++) {
        IUsbDetectObserver* pObserver = *it;
        if (pObserver) {
            pObserver->OnDeviceRemoved();
        }
    }
}


/**
 * USB機器の情報を取得する。
 * 
 * @param   ioDevice            対象のUSB機器
 * @param   spDevice            取得した情報の格納先
 * @param   pppDeviceInterface  取得したIOUSBDeviceInterfaceのpointer
 * @return  kr                  処理結果
 */
kern_return_t UsbDetector::GetDeviceInfo(
                                         /*[in]*/ io_service_t ioDevice,
                                         /*[out]*/ std::shared_ptr<UsbDevice>& spDevice,
                                         /*[out]*/ IOUSBDeviceInterface*** pppDeviceInterface
                                         )
{
    kern_return_t kr = kIOReturnSuccess;
    
    IOCFPlugInInterface** ppPlugInInterface = NULL;
    IOUSBDeviceInterface** ppDeviceInterface = NULL;
    
    try {
        // デバイス名
        io_name_t deviceName = {0};
        kr = IORegistryEntryGetName(ioDevice, deviceName);
        if (kr != kIOReturnSuccess)
        {
            LOG_ERROR("IORegistryEntryGetName() failed [0x%08X]", kr);
        }
        spDevice->deviceName = deviceName;
        
        // パス名
        io_string_t pathName = {0};
        kr = IORegistryEntryGetPath(ioDevice, kIOServicePlane, pathName);
        if (kr != kIOReturnSuccess)
        {
            LOG_ERROR("IORegistryEntryGetName() failed [0x%08X]", kr);
        }
        spDevice->deviceId = pathName;
        
        // IOCFPlugInInterface の取得
        SInt32 score = 0;
        kr = IOCreatePlugInInterfaceForService(
                                               ioDevice,
                                               kIOUSBDeviceUserClientTypeID,
                                               kIOCFPlugInInterfaceID,
                                               &ppPlugInInterface,
                                               &score
                                               );
        if (kr != kIOReturnSuccess || !ppPlugInInterface)
        {
            LOG_ERROR("IOCreatePlugInInterfaceForService(kIOUSBDeviceUserClientTypeID) failed [0x%08X]", kr);
            throw kr;
        }
        
        // IOUSBDeviceInterface の取得
        HRESULT hr = (*ppPlugInInterface)->QueryInterface(
                                                          ppPlugInInterface,
                                                          CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID),
                                                          (void**)&ppDeviceInterface
                                                          );
        if (FAILED(hr) || !ppDeviceInterface)
        {
            LOG_ERROR("QueryInterface(kIOUSBDeviceInterfaceID) failed [0x%08X]", hr);
            throw kIOReturnError;
        }
        
        // Vendor ID
        UInt16 vendorId = 0;
        kr = (*ppDeviceInterface)->GetDeviceVendor(ppDeviceInterface, &vendorId);
        if (kr != kIOReturnSuccess)
        {
            LOG_ERROR("IOUSBDeviceInterface::GetDeviceVendor() failed [0x%08X]", kr);
        }
        spDevice->vendorId = vendorId;
        
        // Product ID
        UInt16 productId = 0;
        kr = (*ppDeviceInterface)->GetDeviceProduct(ppDeviceInterface, &productId);
        if (kr != kIOReturnSuccess)
        {
            LOG_ERROR("IOUSBDeviceInterface::GetDeviceProduct() failed [0x%08X]", kr);
        }
        spDevice->productId = productId;
        
        // Serial Nuber
        AutoCFString vendorName =
        (CFStringRef)IORegistryEntrySearchCFProperty(
                                                     ioDevice,
                                                     kIOServicePlane,
                                                     CFSTR(kUSBVendorString),
                                                     kCFAllocatorDefault,
                                                     kIORegistryIterateRecursively
                                                     );
        if (vendorName) {
            vendorName.copy(spDevice->vendorName);
        }
        
        // Serial Nuber
        AutoCFString serialNumber =
        (CFStringRef)IORegistryEntrySearchCFProperty(
                                                     ioDevice,
                                                     kIOServicePlane,
                                                     CFSTR(kUSBSerialNumberString),
                                                     kCFAllocatorDefault,
                                                     kIORegistryIterateRecursively
                                                     );
        if (serialNumber) {
            serialNumber.copy(spDevice->serialNumber);
        }
        
        *pppDeviceInterface = ppDeviceInterface;
        
        kr = kIOReturnSuccess;
    }
    catch (kern_return_t krException) {
        if (krException == kIOReturnSuccess) {
            kr = kIOReturnError;
        }
    }
    catch (...) {
        kr = kIOReturnError;
    }
    
    if (ppPlugInInterface && *ppPlugInInterface) {
        (*ppPlugInInterface)->Release(ppPlugInInterface);
        *ppPlugInInterface = NULL;
    }
    
    if (kr != kIOReturnSuccess) {
        if (ppDeviceInterface && *ppDeviceInterface) {
            (*ppDeviceInterface)->Release(ppDeviceInterface);
            *ppDeviceInterface = NULL;
        }
    }
    
    return kr;
}

/**
 * 指定したVID/PIDを持つUSB機器の一覧を取得する。
 * 
 * @param pIdVendor     検索対象のVID (opttional)
 * @param pIdProduct    検索対象のPID (opttional)
 * @param deviceList    検索結果のUSB機器の一覧
 */
std::string UsbDetector::FindDevice(
    /*[in]*/ const int* pIdVendor,
    /*[in]*/ const int* pIdProduct,
    /*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& deviceList
    ) {
    std::string errMsg;

    deviceList.clear();
    if (!sIsRunning) {
        return errMsg = "USB detector is not running.";
    }

    ::pthread_mutex_lock(&sDeviceMapMutex);
    for (auto it = sDeviceMap.cbegin(); it != sDeviceMap.cend(); it++) {
        auto spUsbDevice = it->second;
        if (!spUsbDevice) {
            continue;
        }
        if (pIdVendor && *pIdVendor != spUsbDevice->vendorId) {
            continue;
        }
        if (pIdProduct && *pIdProduct != spUsbDevice->productId) {
            continue;
        }
        deviceList.push_back(spUsbDevice);
    }
    ::pthread_mutex_unlock(&sDeviceMapMutex);
    
    return errMsg;
}


