//
//  WaitDetectionWorker.h
//
//  Copyright 2016 Sony Corporation
//

#pragma once

#include <nan.h>
#include "UsbDetectManager.h"
#include "Event.h"

class WaitDetectionWorker : public Nan::AsyncWorker, IUsbDetectObserver
{
private:
	std::shared_ptr<Event> mDetectEvent;
	Nan::Callback* mAddCallback;
	Nan::Callback* mRemoveCallback;
	bool mIsStopped;

public:
	/**
	 * Constructor
	 *
	 * @param addCallback       USB機器が接続された際のcallback
	 * @param removeCallback    USB機器が切断された際のcallback
	 */
	WaitDetectionWorker(
		/*[in]*/ Nan::Callback* addCallback,
		/*[in]*/ Nan::Callback* removeCallback
		) :
		Nan::AsyncWorker(nullptr),
		mAddCallback(addCallback),
		mRemoveCallback(removeCallback),
		mIsStopped(false)
	{
		this->mDetectEvent = std::make_shared<Event>();
	}

	/**
	 * Destructor
	 */
	virtual ~WaitDetectionWorker()
	{
		// USB機器の接続/切断イベントのcallbackを解放する
		UsbDetectManager::RemoveObserver(this);
	}

	/**
	 * 非同期処理
	 */
	virtual void Execute()
	{
		// USB機器の接続/切断イベントのcallbackを設定する
		UsbDetectManager::AddObserver(this);

		if (!UsbDetectManager::HasEvent())
		{
			// 接続/切断検出処理を開始後の場合
			// 接続/切断イベントを待機する
			UsbDetectManager::AddObserver(this);
			this->mDetectEvent->Wait();
		}
		else {
			// 未処理の接続/切断イベントが存在する場合
			// 非同期処理を終了して、イベントキューを処理する
			;
		}
	}

	/**
	* 非同期処理が完了した際に呼び出される。
	*/
	virtual void HandleOKCallback()
	{
		// USB機器の接続/切断イベントのcallbackを解放する
		UsbDetectManager::RemoveObserver(this);

		Nan::HandleScope scope;

		// イベントキューを取得する
		std::deque<std::shared_ptr<DeviceEvent>> eventQueue;
		UsbDetectManager::GetAllEvents(eventQueue);

		// イベントキューを順番に読み込んで、イベントをcallbackする
		for (auto it = eventQueue.cbegin(); it != eventQueue.cend(); it++) {
			std::shared_ptr<DeviceEvent> spEvent = *it;
			for (auto it = spEvent->mDeviceList.begin(); it != spEvent->mDeviceList.end(); it++) {
				v8::Local<v8::Object> item = (*it)->genV8Object();

				const unsigned argc = 1;
				v8::Local<v8::Value> argv[] = {
					item,
				};

				// コールバック呼び出し
				switch (spEvent->mEventType) {
				case DeviceEvent::DEVICE_ADDED:
					this->mAddCallback->Call(argc, argv);
					break;
				case DeviceEvent::DEVICE_REMOVED:
					this->mRemoveCallback->Call(argc, argv);
					break;
				default:
					break;
				}
			}
		}

		if (!this->mIsStopped) {
			// 次のイベント検出を開始する
			Nan::AsyncQueueWorker(
				new WaitDetectionWorker(
				this->mAddCallback,
				this->mRemoveCallback
				));

			// Nan::AsyncWorkerによって、callback が deleteされるのを防ぐ
			// 同一callbackを使用して、Nan::AsyncQueueWorkerを繰り返し生成するため
			callback = nullptr;
		}
		else {
			// USB機器の接続/切断検出処理が終了された場合
			delete this->mAddCallback;
			this->mAddCallback = nullptr;

			delete this->mRemoveCallback;
			this->mRemoveCallback = nullptr;
		}
	}

	/**
	* USB機器の接続/切断検出処理が開始された際に呼び出される。
	*/
	virtual void OnDetectStarted(/*[in]*/ std::string error)
	{
	}

	/**
	* USB機器の接続/切断検出処理が終了された場合に呼び出される。
	*/
	virtual void OnDetectStopped(/*[in]*/ std::string error) {
		this->mIsStopped = true;
		this->mDetectEvent->Signal();
	}

	/**
	* USB機器の接続が検出された場合に呼び出される。
	*/
	virtual void OnDeviceAdded(void) {
		this->mDetectEvent->Signal();
	}

	/**
	* USB機器の切断が検出された場合に呼び出される。
	*/
	virtual void OnDeviceRemoved(void) {
		this->mDetectEvent->Signal();
	}
};
