//
//  ResolveProxyWorker.h
//
//  Copyright 2016 Sony Corporation
//

#pragma once

#include <nan.h>
#include <string>

#ifdef _MSC_VER
// Windows
#include "win/ProxyResolver.h"
#else
// Mac OS X
#include "mac/ProxyResolver.h"
#endif


class ResolveProxyWorker : public Nan::AsyncWorker
{
private:
	std::string targetUrl;
	std::string userAgent;
	std::string proxy;

public:
	/**
	* Constructor
	*/
	ResolveProxyWorker(
		/*[in]*/ std::string& rsTargetUrl,
		/*[in]*/ std::string& rsUserAgent,
		/*[in]*/ Nan::Callback* callback
		)
		: Nan::AsyncWorker(callback)
		, targetUrl(rsTargetUrl)
		, userAgent(rsUserAgent)
	{}

	/**
	* Executed inside the worker-thread.
	* It is not safe to access V8, or V8 data structures
	* here, so everything we need for input and output
	* should go on `this`.
	*/
	virtual void Execute()
	{
		const std::string error = ProxyResolver::GetProxy(targetUrl, userAgent, proxy);
		if (!error.empty()) {
			this->SetErrorMessage(error.c_str());
		}
	}

	/**
	* Executed when the async work is complete
	* this function will be run inside the main event loop
	* so it is safe to use V8 again
	*/
	virtual void HandleOKCallback()
	{
		Nan::HandleScope scope;

		const int argc = 2;
		v8::Local<v8::Value> argv[] = {
			Nan::Null(),
			Nan::New<v8::String>(proxy).ToLocalChecked()
		};

		callback->Call(argc, argv);
	}

	/**
	* Executed when the async work is failed
	* this function will be run inside the main event loop
	* so it is safe to use V8 again
	*/
	virtual void HandleErrorCallback()
	{
		Nan::HandleScope scope;

		const int argc = 1;
		v8::Local<v8::Value> argv[] = {
			Nan::Error(this->ErrorMessage()),
		};

		callback->Call(argc, argv);
	}

};
