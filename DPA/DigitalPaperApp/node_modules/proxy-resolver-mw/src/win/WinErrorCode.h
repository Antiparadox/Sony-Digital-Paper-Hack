//
//  WinErrorCode.h
//
//  Copyright 2016 Sony Corporation
//

#pragma once

#include <winerror.h>
#include <windows.h>
#include <winhttp.h>
#include <string>

class WinErrorCode
{
public:

	static std::string GetWinHttpError(/*[in]*/ ULONG winHttpErr) {

		std::string message;

		switch (winHttpErr) {
		case ERROR_WINHTTP_OUT_OF_HANDLES:
			message = "ERROR_WINHTTP_OUT_OF_HANDLES";
			break;
		case ERROR_WINHTTP_TIMEOUT:
			message = "ERROR_WINHTTP_TIMEOUT";
			break;
		case ERROR_WINHTTP_INTERNAL_ERROR:
			message = "ERROR_WINHTTP_INTERNAL_ERROR";
			break;
		case ERROR_WINHTTP_INVALID_URL:
			message = "ERROR_WINHTTP_INVALID_URL";
			break;
		case ERROR_WINHTTP_UNRECOGNIZED_SCHEME:
			message = "ERROR_WINHTTP_UNRECOGNIZED_SCHEME";
			break;
		case ERROR_WINHTTP_NAME_NOT_RESOLVED:
			message = "ERROR_WINHTTP_NAME_NOT_RESOLVED";
			break;
		case ERROR_WINHTTP_INVALID_OPTION:
			message = "ERROR_WINHTTP_INVALID_OPTION";
			break;
		case ERROR_WINHTTP_OPTION_NOT_SETTABLE:
			message = "ERROR_WINHTTP_OPTION_NOT_SETTABLE";
			break;
		case ERROR_WINHTTP_SHUTDOWN:
			message = "ERROR_WINHTTP_SHUTDOWN";
			break;
		case ERROR_WINHTTP_LOGIN_FAILURE:
			message = "ERROR_WINHTTP_LOGIN_FAILURE";
			break;
		case ERROR_WINHTTP_OPERATION_CANCELLED:
			message = "ERROR_WINHTTP_OPERATION_CANCELLED";
			break;
		case ERROR_WINHTTP_INCORRECT_HANDLE_TYPE:
			message = "ERROR_WINHTTP_INCORRECT_HANDLE_TYPE";
			break;
		case ERROR_WINHTTP_INCORRECT_HANDLE_STATE:
			message = "ERROR_WINHTTP_INCORRECT_HANDLE_STATE";
			break;
		case ERROR_WINHTTP_CANNOT_CONNECT:
			message = "ERROR_WINHTTP_CANNOT_CONNECT";
			break;
		case ERROR_WINHTTP_CONNECTION_ERROR:
			message = "ERROR_WINHTTP_CONNECTION_ERROR";
			break;
		case ERROR_WINHTTP_RESEND_REQUEST:
			message = "ERROR_WINHTTP_RESEND_REQUEST";
			break;
		case ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED:
			message = "ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED";
			break;
		case ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN:
			message = "ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN";
			break;
		case ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND:
			message = "ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND";
			break;
		case ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND:
			message = "ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND";
			break;
		case ERROR_WINHTTP_CANNOT_CALL_AFTER_OPEN:
			message = "ERROR_WINHTTP_CANNOT_CALL_AFTER_OPEN";
			break;
		case ERROR_WINHTTP_HEADER_NOT_FOUND:
			message = "ERROR_WINHTTP_HEADER_NOT_FOUND";
			break;
		case ERROR_WINHTTP_INVALID_SERVER_RESPONSE:
			message = "ERROR_WINHTTP_INVALID_SERVER_RESPONSE";
			break;
		case ERROR_WINHTTP_INVALID_HEADER:
			message = "ERROR_WINHTTP_INVALID_HEADER";
			break;
		case ERROR_WINHTTP_INVALID_QUERY_REQUEST:
			message = "ERROR_WINHTTP_INVALID_QUERY_REQUEST";
			break;
		case ERROR_WINHTTP_HEADER_ALREADY_EXISTS:
			message = "ERROR_WINHTTP_HEADER_ALREADY_EXISTS";
			break;
		case ERROR_WINHTTP_REDIRECT_FAILED:
			message = "ERROR_WINHTTP_REDIRECT_FAILED";
			break;
		case ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR:
			message = "ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR";
			break;
		case ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT:
			message = "ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT";
			break;
		case ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT:
			message = "ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT";
			break;
		case ERROR_WINHTTP_UNHANDLED_SCRIPT_TYPE:
			message = "ERROR_WINHTTP_UNHANDLED_SCRIPT_TYPE";
			break;
		case ERROR_WINHTTP_SCRIPT_EXECUTION_ERROR:
			message = "ERROR_WINHTTP_SCRIPT_EXECUTION_ERROR";
			break;
		case ERROR_WINHTTP_NOT_INITIALIZED:
			message = "ERROR_WINHTTP_NOT_INITIALIZED";
			break;
		case ERROR_WINHTTP_SECURE_FAILURE:
			message = "ERROR_WINHTTP_SECURE_FAILURE";
			break;
		case ERROR_WINHTTP_SECURE_CERT_DATE_INVALID:
			message = "ERROR_WINHTTP_SECURE_CERT_DATE_INVALID";
			break;
		case ERROR_WINHTTP_SECURE_CERT_CN_INVALID:
			message = "ERROR_WINHTTP_SECURE_CERT_CN_INVALID";
			break;
		case ERROR_WINHTTP_SECURE_INVALID_CA:
			message = "ERROR_WINHTTP_SECURE_INVALID_CA";
			break;
		case ERROR_WINHTTP_SECURE_CERT_REV_FAILED:
			message = "ERROR_WINHTTP_SECURE_CERT_REV_FAILED";
			break;
		case ERROR_WINHTTP_SECURE_CHANNEL_ERROR:
			message = "ERROR_WINHTTP_SECURE_CHANNEL_ERROR";
			break;
		case ERROR_WINHTTP_SECURE_INVALID_CERT:
			message = "ERROR_WINHTTP_SECURE_INVALID_CERT";
			break;
		case ERROR_WINHTTP_SECURE_CERT_REVOKED:
			message = "ERROR_WINHTTP_SECURE_CERT_REVOKED";
			break;
		case ERROR_WINHTTP_SECURE_CERT_WRONG_USAGE:
			message = "ERROR_WINHTTP_SECURE_CERT_WRONG_USAGE";
			break;
		case ERROR_WINHTTP_AUTODETECTION_FAILED:
			message = "ERROR_WINHTTP_AUTODETECTION_FAILED";
			break;
		case ERROR_WINHTTP_HEADER_COUNT_EXCEEDED:
			message = "ERROR_WINHTTP_HEADER_COUNT_EXCEEDED";
			break;
		case ERROR_WINHTTP_HEADER_SIZE_OVERFLOW:
			message = "ERROR_WINHTTP_HEADER_SIZE_OVERFLOW";
			break;
		case ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW:
			message = "ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW";
			break;
		case ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW:
			message = "ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW";
			break;
		case ERROR_WINHTTP_CLIENT_CERT_NO_PRIVATE_KEY:
			message = "ERROR_WINHTTP_CLIENT_CERT_NO_PRIVATE_KEY";
			break;
		case ERROR_WINHTTP_CLIENT_CERT_NO_ACCESS_PRIVATE_KEY:
			message = "ERROR_WINHTTP_CLIENT_CERT_NO_ACCESS_PRIVATE_KEY";
			break;
		}

		return message;
	}

	/**
	 * Converts a Win32 system error code to a formatted string object .
	 * 
	 * @param win32Error A Win32 system error code.
	 * @return A formatted error string object.
	 * 		e.g.) "WIN:2:Incorrect function."
	 * @see https://msdn.microsoft.com/ja-jp/library/windows/desktop/ms681381(v=vs.85).aspx
	 */
	static std::string ToString(/*[in]*/ ULONG win32Err)
	{
		std::string message;

		LPVOID lpMsgBuf = NULL;		
		::FormatMessageA(
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			win32Err,
			MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
			(LPSTR)&lpMsgBuf,
			0,
			NULL
			);
		if (lpMsgBuf) {
			message = (LPSTR)lpMsgBuf;
			::LocalFree(lpMsgBuf);
			lpMsgBuf = NULL;
		}
		if (message.empty()) {
			message = GetWinHttpError(win32Err);
		}

		return "WIN:" + std::to_string(win32Err) + ":" + message;
	}


	static std::string GetLastError()
	{
		const ULONG errCode = ::GetLastError();
		return WinErrorCode::ToString(errCode);
	}



};

