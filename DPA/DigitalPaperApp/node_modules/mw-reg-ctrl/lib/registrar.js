/**
    registration.js
    
    created:    [2016-04-25 12:47:09+09:00]
    modified:   [2016-11-18 19:25:07+09:00]
    description:
    Do registration process.
*/


const request = require('request');
const atob = require('atob');
const btoa = require('btoa');

const store = require('reg-store-mw');
const authadpt = require('auth-adpt-mw');
const mwe = require('mw-error');
const debug = require('debug')('mw-reg-ctrl');

const registrar = exports;

const REQUEST_TIMEOUT = 60000;

if ( typeof process.env.NO_PROXY !== 'string' ) {
  console.warn('NO_PROXY environment varialble should be set');
}

/**
 * Device登録処理は、アプリケーションの処理の中で同時に一つ以上動かさない。
 */

registrar.onPinRequest_ = null;

/**
 * @param {function(number, function(object, string))} fnPinRequest A
 *   callback function to input PIN.
 */
registrar.setOnPinRequest = function(fnPinRequest) {
  if ( typeof fnPinRequest !== 'function' ) {
    console.error('fnPinRequest is not a function.');
    return false;
  }
  this.onPinRequest_ = fnPinRequest;
  return true;
}

registrar.onBeforeStoreCert_ = null;

/**
 * Set cert
 * @param {function(number, function(object, string))} fnPinRequest A
 *   callback function to input PIN.
 */
registrar.setOnBeforeStoreCert = function(fnBeforeStoreCert) {
  if ( typeof fnBeforeStoreCert !== 'function' ) {
    console.error('fnBeforeStoreCert is not a function.');
    return false;
  }
  this.onBeforeStoreCert_ = fnBeforeStoreCert;
  return true;
}

registrar.registering_ = false;

const WEBAPI_REGISTER_PIN = '/register/pin';
const WEBAPI_REGISTER_HASH = '/register/hash';
const WEBAPI_REGISTER_CA = '/register/ca';
const WEBAPI_REGISTER = '/register';
const WEBAPI_REGISTER_CLEANUP = '/register/cleanup';

/**
 * Start registration process.
 *
 * @param {string} deviceId A deviceId of the opponent device.
 *
 * @param {string} baseUrl A base URL to call registration Web API.
 *
 * @param {function(object)} callback The callback function to be
 *   called when registration process is done. First argument
 *   indicates error. When first argument is null, the call succeed.
 */
registrar.register = function (deviceId, baseUrl, callback) {
  if ( typeof baseUrl !== 'string' ) {
    throw new TypeError('baseUrl is not a string');
  }
  debug('baseUrl: ', baseUrl);
  if ( typeof callback !== 'function' ) {
    throw new TypeError('callback is not a function');
  }
  if ( typeof this.onPinRequest_ !== 'function' ) {
    callback(new Error('onPinRequest is not set.'));
    return;
  }
  if ( this.registering_ ) {
    // callback(new Error('registration is already running'));
    callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'registration is already running'));
    return;
  }
  this.registering_ = true;

  var n1 = null;
  var mac = null;
  var ya = null;
  var yb = null;
  var n2 = null;
  var authKey = null;
  var keyWrapKey = null;
  var cert = null;
  var keyPubC = null;

  const self = this;
  var psk = null;

  var eHash = null;
  var rHash = null;
  var wrappedRs = null;
  var wrappedEsCert = null;

  var m2hmac = null;
  var m3hmac = null;
  var m4hmac = null;
  var m5hmac = null;

  /**
   * @function clearThumbprint_
   * @param {function} clearThumbprintCallback as (error|null, response, body) optional
   * denebに表示中の拇印を非表示にする。
   */
  function clearThumbprint_ (clearThumbprintCallback) {
    request.put(
      {
        url: baseUrl + WEBAPI_REGISTER_CLEANUP,
        timeout: REQUEST_TIMEOUT
      },
      clearThumbprintCallback
    );
  }
  
  new Promise(function(resolve, reject) {
	debug('attempt to post ', WEBAPI_REGISTER_PIN);
    // request.post(baseUrl + WEBAPI_REGISTER_PIN, function(err, response, body) {
    request.post({
      url: baseUrl + WEBAPI_REGISTER_PIN,
      timeout: REQUEST_TIMEOUT
    }, function(err, response, body) {
      if ( err ) {
        // reject(err);
        reject(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_FAIL, 'request failed',
          'POST', WEBAPI_REGISTER_PIN, null, err));
        return;
      }
      if ( response.statusCode !== 200 ) {
        console.error('Wrong status code: ', response.statusCode);
        reject(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Wrong status code: '+ baseUrl,
          'POST', WEBAPI_REGISTER_PIN, response.statusCode, body));
        // reject(new Error('Wrong status code'));
        
        // [2016-06-01 12:02:42+09:00] kan.k: [TODO] PortForwarderの宛
        // 先が間違っている場合に、301が返るときがある。request の動作
        // 仕様かと考えられる。
        return;
      }
      
      var m1 = JSON.parse(body);
	  debug('response received from: ', WEBAPI_REGISTER_PIN);
      debug(JSON.stringify(m1, null, "  "));

	  if ( typeof m1.a !== 'string' || typeof m1.b !== 'string' || typeof m1.c !== 'string' ) {
		reject(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Wrong response value.',
          'POST', WEBAPI_REGISTER_PIN, response.statusCode, body));
		return;
	  }
	  
      resolve(m1);
    });
  }).then(function(m1) {
    n1 = atob(m1.a);
    mac = atob(m1.b);
    yb = atob(m1.c);
    n2 = authadpt.generateNonce();

    return new Promise(function(resolve, reject) {
      debug('generating key');
      authadpt.generateKeys(yb, n1, mac, n2, function(err, ya_, authKey_, keyWrapKey_) {
        if ( err ) {
          reject(err);
          return;
        }
        ya = ya_;
        authKey = authKey_;
        keyWrapKey = keyWrapKey_;
        resolve();
      });
    });
  }).then(function() {
    // ya = '\x00' + dh.getPublicKey('binary');
	// [2016-07-01 10:53:35+09:00] kan.k: [TODO] GenerateKeys or
	// GenerateHmac

	// return Promise.reject();

    m2hmac = authadpt.generateHmac(n1 + mac + yb + n1 + n2 + mac + ya, authKey);
    var m2 = {
      a: btoa(n1),
      b: btoa(n2),
      c: btoa(mac),
      d: btoa(ya),
      e: btoa(m2hmac)
    };
    debug('attempt to post /register/hash');
    debug(JSON.stringify(m2, null, "  "));

    return new Promise(function(resolve, reject) {
      request.post({
        url: baseUrl + WEBAPI_REGISTER_HASH,
        json: m2,
        timeout: REQUEST_TIMEOUT
      }, function(err, response, body) {
        if ( err ) {
          debug(err);
          reject(err);
          return;
        }
        if ( response.statusCode !== 200 ) {
          console.error('Wrong status code: ', response.statusCode);
          reject(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Wrong status code',
            'POST', WEBAPI_REGISTER_HASH, response.statusCode, body));
          return;
        }
        
        debug('successfully got response for /register/hash');
        debug(body);
        var m3 = body;
        debug(JSON.stringify(m3, null, "  "));
        resolve(m3);
      });
    });
  }).then(function(m3) {
    if ( atob(m3.a) !== n2 ) {
      console.error('N2 does not match!');
      return Promise.reject(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'N2 does not match!',
        'POST', WEBAPI_REGISTER_HASH, response.statusCode));
      return;
    }
    eHash = atob(m3.b);
    m3hmac = atob(m3.e);
    if ( m3hmac !== authadpt.generateHmac(n1 + n2 + mac + ya + m2hmac + n2 + eHash, authKey) ) {
      console.error('HMAC does not match!');
      debug('generated HMAC is : ', btoa(authadpt.generateHmac(n1 + n2 + mac + ya + n2 + eHash, authKey)));
      // callback(new Error('HMAC does not match!'));
      return Promise.reject(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'HMAC does not match!',
        'POST', WEBAPI_REGISTER_HASH, response.statusCode));
    }

    return new Promise(function(resolve, reject) {
      self.onPinRequest_(120 * 1000, function(err, pin) {
        if ( err ) {
          console.error(err);
          reject(err);
          return;
        }
        resolve(pin);
      });
    });
  }).then(function(pin) {
    psk = authadpt.generateHmac(pin, authKey);
    debug('psk: ', psk);

    var rs = authadpt.generateNonce();
    rHash = authadpt.generateHmac(rs + psk + yb + ya, authKey);
    debug('rHash: ', Buffer.from(rHash).toString('hex'));

    debug(typeof rs);
    debug(typeof authKey);
    debug(typeof keyWrapKey);
    wrappedRs = authadpt.wrap(rs, authKey, keyWrapKey);
    debug('wrappedRs: ', Buffer.from(wrappedRs).toString('hex'));

    m4hmac = authadpt.generateHmac(n2 + eHash + m3hmac + n1 + rHash + wrappedRs, authKey);

    var m4 = {
      a: btoa(n1),
      b: btoa(rHash),
      d: btoa(wrappedRs),
      e: btoa(m4hmac)
    };

    return new Promise(function(resolve, reject) {
      request.post({
        url: baseUrl + WEBAPI_REGISTER_CA,
        json: m4,
        timeout: REQUEST_TIMEOUT
      }, function(err, response, body) {
        if ( err ) {
          console.error(err);
          reject(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_FAIL, 'request failed',
            'POST', WEBAPI_REGISTER_CA, null, err));
          return;
        }
        if ( response.statusCode !== 200 ) {
          if ( response.statusCode === 403 &&
               typeof body.error_code === 'string' && body.error_code === '40301' ) {
            
            console.error('Wrong status code: ', response.statusCode);
            reject(mwe.genWebApiError(
              mwe.E_MW_REG_PIN_MAY_BE_WRONG, 'PIN could be wrong',
              'POST', WEBAPI_REGISTER_CA, response.statusCode, body));
            return;
          }
            
          console.error('Wrong status code: ', response.statusCode);
          reject(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Wrong status code',
            'POST', WEBAPI_REGISTER_CA, response.statusCode, body));
          return;
        }
        
        var m5 = body;
        debug(JSON.stringify(m5, null, "  "));
        resolve(m5);
      })
    });
  }).then(function(m5) {
    // Verify n2
    if ( atob(m5.a) !== n2 ) {
      console.error('N2 does not match!');
      return;
    }

    wrappedEsCert = atob(m5.d);
    m5hmac = atob(m5.e);
    
    // Verify HMAC
    if ( m5hmac !== authadpt.generateHmac(n1 + rHash + wrappedRs + m4hmac + n2 + wrappedEsCert, authKey) ) {
      console.error('HMAC does not match!');
      debug('generated HMAC is : ',
                  btoa(authadpt.generateHmac(n1 + rHash + wrappedRs + m4hmac + n2 + wrappedEsCert, authKey)));
      // return Promise.reject(new Error('HMAC does not match!'));
      return Promise.reject(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'HMAC does not match!',
        'POST', WEBAPI_REGISTER_CA, response.statusCode));
    }

    var esCert = authadpt.unwrap(wrappedEsCert, authKey, keyWrapKey);
    if ( typeof esCert !== 'string' ) {
      return Promise.reject(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'esCert kwa does not match!',
        'POST', WEBAPI_REGISTER_CA, response.statusCode));
    }
    var es = esCert.slice(0, 128 / 8);
    cert = esCert.slice(128 / 8);

    if ( eHash !== authadpt.generateHmac(es + psk + yb + ya, authKey) ) {
      console.error('eHash does not match!');
      // return Promise.reject(new Error('eHash does not match!'));
      return Promise.reject(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'eHash does not match!',
        'POST', WEBAPI_REGISTER_CA, response.statusCode));
    }

    debug('cert: ', cert);

    return new Promise(function(resolve, reject) {
      if ( typeof self.onBeforeStoreCert_ !== 'function' ) {
        resolve();
        return;
      }
      // 拇印表示後、証明書導入をキャンセルした場合の処理を入れておく
      self.onBeforeStoreCert_(120 * 1000, function(err, approved) {
        if ( typeof approved !== 'boolean' ) {
          reject(new TypeError('type of approved is wrong'));
          // reject(new Error('type is wrong'));
          return;
        }
        // キャンセルした場合は拇印を消す
        if ( ! approved ) {
          clearThumbprint_( (err, response, body) => {
            // Ignores any error from cleanup api.
            reject(mwe.genError(mwe.E_MW_CANCELLED, 'onBeforeStoreCert returns false'));
          });
          return;
        }

        resolve();
      });
    });
  }).then(function() {
    return Promise.all([new Promise(function(resolve, reject) {
      store.addServerCert(cert, function(err) {
        if ( err ) {
          // OSダイアログでキャンセル押下時もここに入る
          clearThumbprint_( (err, response, body) => {
            reject(mwe.genError(mwe.E_MW_STORE_SET_CERT_FAILED, 'failed to write store', err));
          });
          return;
        }
        debug('wrote deneb.pem');
        resolve();
      });
      // 以降、Denebに拇印が表示されている
    }), new Promise(function(resolve, reject) {
      store.getClientPublicKey(function(err, data) {
        if ( err ) {
          console.error('failed to read from altair.pub', err);
          // reject(err);
          reject(mwe.genError(mwe.E_MW_STORE_GET_PUBKEY_FAILED, 'failed to read from altair.pub', err));
          return;
        }
        keyPubC = data;
        resolve();
      });
    })]);
  }).then(function() {
	return new Promise(function(resolve, reject) {
      store.getClientDeviceId(function(err, selfDeviceId) {
		if ( err ) {
		  reject(err);
		  return;
		}
		resolve(selfDeviceId);
	  });
	});
  }).then(function(selfDeviceId) {
    // var selfDeviceId = store.genClientDeviceId();
    var wrappedDIDKPUBC = authadpt.wrap(selfDeviceId + keyPubC, authKey, keyWrapKey);
    var m6hmac = authadpt.generateHmac(n2 + wrappedEsCert + m5hmac + n1 + wrappedDIDKPUBC, authKey);
    var m6 = {
      a: btoa(n1),
      d: btoa(wrappedDIDKPUBC),
      e: btoa(m6hmac)
    };

    return new Promise(function(resolve, reject) {
      request.post({
        url: baseUrl + WEBAPI_REGISTER,
        json: m6,
        timeout: REQUEST_TIMEOUT
      }, function(err, response, body) {
        if ( err ) {
          console.error(err);
          return;
        }
        if ( response.statusCode !== 204 ) {
          console.error('Wrong status code: ', response.statusCode);
          // callback(new Error('Wrong status code'));
          // return;
          // return Promise.reject(new Error('Wrong status code'));
          reject(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Wrong status code',
            'POST', WEBAPI_REGISTER, response.statusCode, body));
          return;
        }
        
        debug('succeed to register.');
        debug('body: ', body);
        resolve();
      });
    });
  })
  // 最後に、Deneb表示中の拇印を消す
  .then(function(){
    return new Promise(function(resolve, reject) {
      clearThumbprint_( (err, response, body) => {
        // Ignores any error from cleanup api.
        resolve();
      });
    })
  })
  .then(function() {
    self.registering_ = false;
    callback(null);
    return;
  }, function(err) {
    debug('ERROR captured: ', err);
	if ( ! err ) {
	  err = mwe.genError(mwe.E_MW_WEBAPI_ERROR, 'Wrong error without error object.');
	}
    self.registering_ = false;
    callback(err);
    return;
  });
}

