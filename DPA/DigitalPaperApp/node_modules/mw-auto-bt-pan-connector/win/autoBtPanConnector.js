'use strict';


const logE = require('debug')('mw-auto-bt-pan-connector:win:autoBtPanConnector:error');
const logD = require('debug')('mw-auto-bt-pan-connector:win:autoBtPanConnector:debug');

const EventEmitter = require('events').EventEmitter;
const emitter = new EventEmitter();

const BtModule = require('./btModule').BtModule;
const btModule = new BtModule();

const NativeModule = require('./nativeModule');

const DeviceType = require('../lib/define').DeviceType;
const LogLevel = require('../lib/define').LogLevel;

const ErrorManager = require('../lib/error_manager');

const deviceMap = require('../lib/device_map');

const PERIODIC_TASK_INTERVAL_MILLISECONDS = 1000 * 5;

const ScanState = {
    STOPPED: 0,
    STARTED: 1,
    STOPPING: 2,
    STARTING: 3
};


var autoConnectEnabled = false;

var oldConnectableDenebCount = -1;

var connectionErrorCount = 0;

var nowConnecting = false;

var scanState = ScanState.STOPPED;

var intervalId = undefined;

var lastEventDateTime = new Date(0);

var targetedDenebDeviceId = undefined;

//////////////// 非公開メソッド ////////////////


/**
 * 非同期関数呼び出し
 */
var asyncCall = function (func) {
    if (typeof func !== 'function') {
        throw new Error('Invalid aragument.');
    }

    setTimeout(func, 0);
};


/**
 * デバイスが BT ペアリングされたときに呼ばれます。
 */
var onDevicePaired = function (deviceInfo) {
    logD('onDevicePaired()');
    if (LogLevel.SHOW_SCAN_DATA) {
        logD('%o', deviceInfo);
    }

    deviceInfo.paired = true;
    deviceInfo.found = true;
    deviceMap.updateItem(deviceInfo);

    lastEventDateTime = new Date();
};


/**
 * デバイスの BT ペアリングが解除されたときに呼ばれます。
 */
var onDeviceUnpaired = function (deviceInfo) {
    logD('onDeviceUnpaired()');
    if (LogLevel.SHOW_SCAN_DATA) {
        logD('%o', deviceInfo);
    }

    deviceInfo.paired = false;
    deviceInfo.found = false;  // 一旦 false にしておく。
    deviceMap.updateItem(deviceInfo);

    lastEventDateTime = new Date();
};


/**
 * デバイス スキャンでデバイスが見つかったときに呼ばれます。
 */
var onDeviceFound = function (deviceInfo) {
    logD('onDeviceFound()');
    if (LogLevel.SHOW_SCAN_DATA) {
        logD('%o', deviceInfo);
    }

    deviceInfo.found = true;
    deviceMap.updateItem(deviceInfo);

    lastEventDateTime = new Date();
};


/**
 * デバイス スキャンでデバイスを見失ったときに呼ばれます。
 */
var onDeviceLost = function (deviceInfo) {
    logD('onDeviceLost()');
    if (LogLevel.SHOW_SCAN_DATA) {
        logD('%o', deviceInfo);
    }

    deviceInfo.found = false;
    deviceMap.updateItem(deviceInfo);

    lastEventDateTime = new Date();
};


/**
 * デバイス スキャンでデバイスの状態変化を検出したときに呼ばれます。
 */
var onDeviceStatusChanged = function (deviceInfo) {
    logD('onDeviceStatusChanged()');
    if (LogLevel.SHOW_SCAN_DATA) {
        logD('%o', deviceInfo);
    }

    deviceInfo.found = true;
    deviceMap.updateItem(deviceInfo);
};


/**
 * PAN ネットワークの状態変化を検出したときに呼ばれます。
 */
var onPanStatusChanged = function (networkInfo) {
    logD('onPanStatusChanged()');

    networkInfo.found = (NativeModule.BtPanStatus.Connected !== undefined) && (networkInfo.status === NativeModule.BtPanStatus.Connected);
    deviceMap.updateItem(networkInfo);
};


/**
 * PAN ネットワークに接続します。
 * @param {boolean} isStartEmitRequired true:無条件に接続開始イベントが必要／false(default):接続するときだけ接続開始イベントを出す
 */
var connect = function (isStartEmitRequired) {
    logD('connect()');

    if (!nowConnecting) {
        // ここで必ず接続開始イベントを出してしまうと、PAN関数でエラーがあって接続できない場面で、
        // 接続開始イベント　→　非同期処理　→　接続終了イベント
        // この繰り返しになるので、UIではぐるぐるから抜けれない

        var emitStarting = function() {
            emitter.emit('connectStart');
            logD('* [EVENT] connectStart');
        }

        var done = function (error) {
            emitter.emit('connectEnd', ErrorManager.convertForAltair(error));
            logD('* [EVENT] connectEnd');
            nowConnecting = false;
        };

        // 処理の排他
        nowConnecting = true;

        // 接続開始イベント必須の場合だけここでイベント発火
        if (isStartEmitRequired===true) {
            emitStarting();
        }

        btModule.findConnectedNetwork(function (error, networkInfo) {
            if (!error) {
                var btAddress = networkInfo ? networkInfo.btAddress : '';

                var deviceType = deviceMap.lookupDeviceType(btAddress);
                if (deviceType === DeviceType.DENEB) {
                    logD('Already has been connected to Deneb.');
                    done();
                    return;
                }

                var connectableDenebList = deviceMap.getConnectableDenebListEx(targetedDenebDeviceId);
                if (connectableDenebList.length === 0) {
                    logD('Connectable-Deneb was not found.');
                    done('Connectable-Deneb was not found.');
                    return;
                } else if (connectableDenebList.length >= 2) {
                    logD('Some connectable-Denebs were found.');
                    done('Some connectable-Denebs were found.');
                    return;
                }

                var btAddressToConnect = connectableDenebList[0].btAddress;
                var btAddressToDisconnect = btAddress;

                if (!deviceMap.canConnect(btAddressToConnect)) {
                    logD('It is not in state to connect to Deneb.');
                    done('It is not in state to connect to Deneb.');
                    return;      
                }

                var now = new Date();
                var elapsedMilliseconds = now.getTime() - lastEventDateTime.getTime();
                if ((elapsedMilliseconds >= 0) && (elapsedMilliseconds < (1000 * 3))) {
                    logD('It is too early to connect to Deneb. Event is not cold yet.');
                    done('It is too early to connect to Deneb. Event is not cold yet.');
                    return;            
                }

                // networkInfoがない場合はゾンビを確認する。
                // ※ゾンビはDisconnectできない
                if (networkInfo == null && deviceMap.getZombieList().length) {
                    var msg = 'There is a zombie.';
                    logD(msg);
                    done(msg);
                    return;
                }

                // ここでようやくStartConnectイベント発火
                if (!isStartEmitRequired) {//isStartEmitRequired==true の場合は↑で発火済み
                    emitStarting();
                }

                asyncCall(function () {
                    btModule.connectToNetworkEx(btAddressToConnect, btAddressToDisconnect, function (error, functionName) {
                        done(error);

                        if (error) {
                            logD('connectToNetworkEx() failed. %o', error);

                            if ((functionName === 'connectToNetwork') || (functionName === 'disconnectFromNetwork')) {
                                connectionErrorCount = (connectionErrorCount < 10) ? ++connectionErrorCount : connectionErrorCount;
                                if (connectionErrorCount >= 10) {
                                    emitter.emit('abnormalConditionOfPan');
                                    logD('* [EVENT] abnormalConditionOfPan');
                                    connectionErrorCount = 0;
                                }
                            }
                        } else {
                            connectionErrorCount = 0;
                        }
                    });
                });
            } else {
                done(error);
            }
        });
    } else {
        emitter.emit('connectBusy');
        logD('* [EVENT] connectBusy');
    }
};


/**
 * 必要なら、PAN ネットワークに接続します。
 */
var connectIfNeeded = function () {
    btModule.findConnectedNetwork(function (error, networkInfo) {
        if (!error) {
            var btAddress = networkInfo ? networkInfo.btAddress : '';
            var deviceType = deviceMap.lookupDeviceType(btAddress);
            if (deviceType === DeviceType.DENEB) {
                var device = deviceMap.findDevice(btAddress);
                var deviceName = (device && device.name) ? device.name : 'Unknown Device';
                logD('[CONNECTION] Connected to ' + deviceName + '.');
            } else {
                logD('[CONNECTION] Not connected.');
                asyncCall(connect);
            }
        }
    });
};


/**
 * 状態チェックを行います。
 */
var checkCondition = function () {
    if (scanState === ScanState.STARTED) {
        btModule.findNetworks(function (error, networkInfoList) {
            if (!error) {
                deviceMap.clearAllPairedFlags();
                if (networkInfoList) {
                    networkInfoList.map(function (item) { item.paired = true; });
                    deviceMap.updateItem(networkInfoList);
                }
                
                var pairedDenebList = deviceMap.getPairedDenebList();
                var pairedDenebCount = pairedDenebList.length;

                var connectableDenebList = deviceMap.getConnectableDenebListEx(targetedDenebDeviceId);
                var connectableDenebCount = connectableDenebList.length;

                var zombieList = deviceMap.getZombieList();
                var zombieCount = zombieList.length;

                logD('[STATE] autoConnectEnabled: ' + autoConnectEnabled.toString());
                logD('[STATE] pairedDenebCount: ' + pairedDenebCount.toString());
                logD('[STATE] connectableDenebCount: ' + connectableDenebCount.toString());
                logD('[STATE] zombieCount: ' + zombieCount.toString());
                logD('[SETTING] targetedDenebDeviceId: ' + targetedDenebDeviceId);

                if (autoConnectEnabled) {
                    if (connectableDenebCount != oldConnectableDenebCount) {
                        oldConnectableDenebCount = connectableDenebCount;
                        emitter.emit('connectableDenebCountChanged', connectableDenebCount);
                        logD('* [EVENT] connectableDenebCountChanged: ' + connectableDenebCount.toString())
                    }

                    if (connectableDenebCount === 1) {
                        asyncCall(connectIfNeeded);
                    }
                }
            }
        });
    }
};


/**
 * 定期実行タスク
 */
var periodicTask = function () {
    logD('periodicTask()');

    try {
        checkCondition();
    } catch (ex) {
        logE('periodicTask() - Failed. %o', ex);
    }
};


/**
 * 定期実行タスクを開始します。
 */
var startPeriodicTask = function () {
    logD('startPeriodicTask()');

    if (!intervalId) {
        intervalId = setInterval(periodicTask, PERIODIC_TASK_INTERVAL_MILLISECONDS);
    }
};


/**
 * 定期実行タスクを停止します。
 */
var stopPeriodicTask = function () {
    logD('stopPeriodicTask()');

    if (intervalId) {
        clearInterval(intervalId);
        intervalId = undefined;
    }
};


/**
 * イベント受信を有効化します。
 */
var enableListenEvents = function () {
    logD('enableListenEvents()');

    btModule.setDeviceRegisteredEventListener(onDevicePaired);
    btModule.setDeviceUnregisteredEventListener(onDeviceUnpaired);
    btModule.setDeviceFoundEventListener(onDeviceFound);
    btModule.setDeviceLostEventListener(onDeviceLost);
    btModule.setDeviceStatusChangedEventListener(onDeviceStatusChanged);
    btModule.setPanStatusChangedEventListener(onPanStatusChanged);
};


/**
 * イベント受信を無効化します。
 */
var disableListenEvents = function () {
    logD('disableListenEvents()');

    btModule.clearAllDeviceRegisteredEventListeners();
    btModule.clearAllDeviceUnregisteredEventListeners();
    btModule.clearAllDeviceFoundEventListeners();
    btModule.clearAllDeviceLostEventListeners();
    btModule.clearAllDeviceStatusChangedEventListeners();
    btModule.clearAllPanStatusChangedEventListeners();
};


//////////////// 公開クラス ////////////////


class AutoBtPanConnector {
    /**
     * コンストラクタ
     */
    constructor() {
        logD('* constructor()');

        btModule.initialize();
    }


    /**
     * オブジェクトを破棄します。
     * PAN接続中のDenebがある場合は、そのPANを切断してから、オブジェクトを破棄します。
     */
    destroy(callback) {
        logD('* destroy()');

        if (typeof callback !== 'function') {
            throw new Error('Invalid argument.');
        }

        // DenebにPAN接続済みの場合は、切断してからオブジェクト破棄の処理。
        // PANなしの場合はオブジェクト破棄の処理のみ。

        // オブジェクト破棄の処理
        function innerDestroy() {
            btModule.destroy(function (error) {
                callback(ErrorManager.convertForAltair(error));
            });
        }

        // PAN接続中のDenebがいるかどうかで分岐
        this.isConnectedToDeneb( (error, isConnected, networkInfo) => {
            // PAN接続中のDenebがある場合
            if (!error && isConnected) {
                // PAN切断呼び出しの後にオブジェクト破棄を呼ぶ
                btModule.disconnectFromNetwork(networkInfo.btAddress, () => {
                    innerDestroy();
                });
            }
            // PAN接続中のDenebがない場合は、オブジェクト破棄のみ。
            else {
                innerDestroy();
            }
        });
    }


    /**
     * イベントを発行します。
     */
    emit(eventName, value) {
        logD('* emit()');

        return emitter.emit(eventName, value);
    }


    /**
     * イベント リスナーを登録します。
     */
    on(eventName, listener) {
        logD('* on()');

        return emitter.on(eventName, listener);
    }


    /**
     * 一回しか使用されないイベント リスナーを登録します。
     */
    once(eventName, listener) {
        logD('* once()');
        
        return emitter.once(eventName, listener);
    }


    /**
     * イベント リスナーを削除します。
     */
    removeListener(eventName, listener) {
        logD('* removeListener()');

        return emitter.removeListener(eventName, listener);
    }


    /**
     * mw-auto-bt-pan-connector モジュールが利用可能かどうかを判定します。
     */
    isAvailable() {
        logD('* isAvailable()');

        return btModule.isInitialized();
    }


    /**
     * デバイス スキャンを開始します。
     */
    startScanDevice(callback) {
        logD('* startScanDevice()');

        if (typeof callback !== 'function') {
            throw new Error('Invalid argument.');
        }

        if (scanState === ScanState.STOPPED) {
            scanState = ScanState.STARTING;
            // PANモジュールが感知できないタイミングなどでPAN接続状態が変更されると、
            // findConnectedNetwork が最新のPAN接続状態を返さなくなることがあるため、
            // 強制的に再作成
            btModule.unlock();
            btModule.reinitialize();
            // スキャン開始
            btModule.startScanDevice(function (error) {
                if (!error) {
                    deviceMap.clearAllFlags();
                    deviceMap.enableUpdateItem();
                    enableListenEvents();
                    startPeriodicTask();

                    scanState = ScanState.STARTED;
                    callback(ErrorManager.convertForAltair(error));
                } else {
                    stopPeriodicTask();
                    disableListenEvents();
                    deviceMap.disableUpdateItem();
                    deviceMap.clearAllFlags();

                    scanState = ScanState.STOPPED;
                    callback(ErrorManager.convertForAltair(error));
                }
            });
        } else if (scanState === ScanState.STARTED) {
            asyncCall(function () {
                callback(ErrorManager.convertForAltair('Already started.'));
            });
        } else {
            asyncCall(function () {
                callback(ErrorManager.convertForAltair('Switching now.'));
            });
        }
    }


    /**
     * デバイス スキャンを停止します。
     */
    stopScanDevice(callback) {
        logD('* stopScanDevice()');

        if (typeof callback !== 'function') {
            throw new Error('Invalid argument.');
        }

        if (scanState === ScanState.STARTED) {
            scanState = ScanState.STOPPING;

            stopPeriodicTask();
            disableListenEvents();
            deviceMap.disableUpdateItem();
            deviceMap.clearAllFlags();

            oldConnectableDenebCount = -1;
            connectionErrorCount = 0;

            btModule.stopScanDevice(function (error) {
                var reinitializeRetryCount = 30;  // 3 秒間 (100ms * 30回)、reinitialize() が成功するまで試します。

                var reinitializeDone = function () {
                    scanState = ScanState.STOPPED;
                    callback(ErrorManager.convertForAltair(error));
                };

                var reinitializer = function () {
                    var result = btModule.reinitialize();
                    if (result) {
                        reinitializeDone();
                    } else {
                        logD('reinitializeRetryCount: ' + reinitializeRetryCount.toString());
                        if (--reinitializeRetryCount >= 0) {
                            setTimeout(reinitializer, 100);
                        } else {
                            reinitializeDone();
                        }
                    }
                };

                asyncCall(reinitializer);
            });
        } else if (scanState === ScanState.STOPPED) {
            asyncCall(function () {
                callback(ErrorManager.convertForAltair('Already stopped.'));
            });
        } else {
            asyncCall(function () {
                callback(ErrorManager.convertForAltair('Switching now.'));
            });
        }
    }


    /**
     * 自動 BT PAN 接続を有効化します。
     */
    enableAutoConnect() {
        logD('* enableAutoConnect()');

        if (!autoConnectEnabled) {
            autoConnectEnabled = true;
            oldConnectableDenebCount = -1;
        }
    }


    /**
     * 自動 BT PAN 接続を無効化します。
     */
    disableAutoConnect() {
        logD('* disableAutoConnect()');
        
        if (autoConnectEnabled) {
            autoConnectEnabled = false;
            oldConnectableDenebCount = -1;
        }
    }


    /**
     * BT PAN 接続の要求を行います。
     */
    doConnect() {
        logD('* doConnect()');

        // UIから呼ばれるので、実際に接続する｜しない、に係らず、接続開始イベントは必ず発火させる
        connect(true);
    }


    /**
     * DENEB と BT PAN 接続されているかどうかを判定します。
     * @param {function(optError,isConnected,optNetworkInfo)} callback(エラー情報 or undefined, 接続フラグ, 接続中のDenebのネットワーク情報)
     */
    isConnectedToDeneb(callback) {
        logD('* isConnectedToDeneb()');

        if (typeof callback !== 'function') {
            throw new Error('Invalid argument.');
        }

        // UIから呼ばれるので、待機ロック防止のために、必ずコールバックするためのタイマーをセットする
        var _timeout = setTimeout( ()=>{
            _timeout = null;
            callback(ErrorManager.convertForAltair("timeout"));
        }, 3000);
        
        btModule.findConnectedNetwork(function (error, networkInfo) {
            // すでにタイムアウトだった場合はコールバックを出さない（2度出すことになるので）
            if (!_timeout) return;
            
            // コールバックのタイマーを無効化する
            clearTimeout(_timeout);

            asyncCall(function () {
                if (!error) {
                    var btAddress = networkInfo ? networkInfo.btAddress : '';
                    var deviceType = deviceMap.lookupDeviceType(btAddress);
                    var connected = deviceType === DeviceType.DENEB;
                    callback(undefined, connected, connected ? networkInfo : undefined);
                } else {
                    callback(ErrorManager.convertForAltair(error));
                }
            });
        });
    }


    /**
     * BT ペアリングされている DENEB の数を取得します。
     */
    getPairedDenebCount() {
        logD('* getPairedDenebCount()');

        return deviceMap.getPairedDenebList().length;
    }


    /**
     * BT PAN 接続可能な DENEB の数を取得します。
     */
    getConnectableDenebCount() {
        logD('* getConnectableDenebCount()');

        return deviceMap.getConnectableDenebListEx(targetedDenebDeviceId).length;
    }


    /**
     * mw-auto-bt-pan-connector モジュールをサスペンドさせます。
     */
    suspend() {
        logD('* suspend()');

        // スキャン停止
        this.stopScanDevice(()=>{});
    }


    /**
     * mw-auto-bt-pan-connector モジュールをレジュームさせます。
     */
    resume() {
        logD('* resume()');

        // PANインスタンス再作成してから再スキャン。
        // ※自動接続でない場合でも、内部のネットワーク情報マップを構築するためにスキャンは必要。
        var self = this;

        // 以下、念のための処理あり：
        // 1.Suspendでスキャン停止処理が呼ばれない想定外を考慮し、スキャン停止を呼ぶ
        // 2.ロックなどでスキャン停止ができない瞬間があることを考慮し、強制的にインスタンス再作成する
        //  →↑はStartScanDeviceでやる
        this.stopScanDevice( ()=>{
            // スキャン開始
            self.startScanDevice(()=>{});
        });
    }

    /**
     * 検出しているすべての DENEB に対して、
     * 現在 PAN 接続している/していないにかかわらず、
     * disconnectFromNetwork() を実行します。
     */
    bruteForceDisconnectFromAllDenebs(callback) {
        logD('* bruteForceDisconnectFromAllDenebs()');

        if (typeof callback !== 'function') {
            throw new Error('Invalid argument.');
        }

        var disconnector = function () {
            if (!nowConnecting) {
                nowConnecting = true;

                var denebList = deviceMap.getDenebList();
                btModule.bruteForceDisconnectFromAllDenebs(denebList, function (error) {
                    nowConnecting = false;
                    callback();
                });
            } else {
                setTimeout(disconnector, 500);
            }
        };

        asyncCall(function () {
            disconnector();
        });
    }

    /**
     * 接続対象となる Deneb のデバイス ID を設定します。
     */
    setTargetedDenebDeviceId(deviceId) {
        if ((typeof deviceId === 'string') && (deviceId.match(/^\d{7}$/))) {
            targetedDenebDeviceId = deviceId;
        } else {
            targetedDenebDeviceId = undefined;
        }
    }
}


module.exports.AutoBtPanConnector = AutoBtPanConnector;
