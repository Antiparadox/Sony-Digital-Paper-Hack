const expect = require('chai').expect;
const sinon = require('sinon');
const BtPairingModule = require('bt-pairing-mw' + process.env.TEST_MODULE_POSTFIX);
const BtPanModule = require('bt-pan-mw' + process.env.TEST_MODULE_POSTFIX);
const BtModuleMod = require(`../${process.platform === 'win32' ? 'win' : 'mac'}/btModule`);

/**
 * sinon.stub(obj, prop, function(){}) の、function(){} を ()=>{} にすると、うまくいくときといかないときがある！！！
 */

describe('BtModule', function() {
    // BtPanモジュールのスタブ
    var stubs = {
        BtPairing: {},
        BtPan: {},
    };

    before( () => {

        // bt-pairing :: SBluetoothPairing で生成されるので、それをStubして、その中にSpyを仕込ませる
        stubs.BtPairing.startScanDevice = sinon.stub();
        stubs.BtPairing.on = sinon.stub();

        stubs.BtPairing.SBluetoothPairing = sinon.stub(BtPairingModule, "SBluetoothPairing", function() {
            this.S_BT_PAIRING_DEVICE_CLASS = {
                S_BT_PAIRING_DEVICE_CLASS_PHONE_SMART: 123
            };
            this.startScanDevice = stubs.BtPairing.startScanDevice;
            this.on = stubs.BtPairing.on;
        });

        // bt-pan :: SBluetoothPan で生成されるので、それをStubして、その中にSpyを仕込ませる
        stubs.BtPan.connectToNetwork = sinon.stub();
        stubs.BtPan.disconnectFromNetwork = sinon.stub();
        stubs.BtPan.on = sinon.stub();
        stubs.BtPan.findNetworks = sinon.stub();
        stubs.BtPan.findConnectedNetwork = sinon.stub();

        stubs.BtPan.SBluetoothPan = sinon.stub(BtPanModule, "SBluetoothPan", function() {
            this.S_BT_PAN_ROLE = {
                S_BT_PAN_ROLE_NAP: 999
            };
            this.connectToNetwork = stubs.BtPan.connectToNetwork;
            this.disconnectFromNetwork = stubs.BtPan.disconnectFromNetwork;
            this.on = stubs.BtPan.on;
            this.findNetworks = stubs.BtPan.findNetworks;
            this.findConnectedNetwork = stubs.BtPan.findConnectedNetwork;
        });
    });
    after(() => {
        // restore all of spys
        for (var mod in stubs) {
            if (typeof stubs[mod].restore === 'function') {
                stubs[mod].restore();
            }
            else if (typeof stubs[mod] === 'object') {
                for (var func in stubs[mod]) {
                    if (typeof stubs[mod][func].restore === 'function')
                    stubs[mod][func].restore();
                }
            }
        }
        // restore sinon.stubs
        sinon.restore();
    });


    describe('#initialize', () => {
        var connector = new BtModuleMod.BtModule();
        it('should create shared lib instances', () => {
            expect(connector.btPairingObject, "null of btPairingObject before init").null;
            expect(connector.btPanObject, "null of btPanObject before init").null;

            connector.initialize();
            expect(connector.btPairingObject, "null of btPairingObject before init").not.null;
            expect(connector.btPanObject, "null of btPanObject before init").not.null;
        });
    });

    describe('#isAvailable', ()=>{
        var connector = new BtModuleMod.BtModule();

        it('should return false before init', () => {
            expect(connector.isAvailable()).false;
        });
        it('should return true after init', () => {
            connector.initialize();
            expect(connector.isAvailable()).true;
        });
        it('should return false if no pan instances', () => {
            var panObj = connector.btPanObject;
            connector.btPanObject = null;
            expect(connector.isAvailable()).false;

            connector.btPairingObject = null;
            expect(connector.isAvailable()).false;

            connector.btPanObject = panObj;
            expect(connector.isAvailable()).false;
        });
    });

    describe('#startScanDevice', ()=>{
        var connector = new BtModuleMod.BtModule();

        beforeEach( ()=> {
            connector.initialize();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.startScanDevice();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.startScanDevice({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not callback").not.null;
                ex = null;
            }
        })
        it('should call api :: startScanDevice if isAvailable() returns true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;
            expect(stubs.BtPairing.startScanDevice.callCount).eq(0);

            // 呼び出し
            connector.startScanDevice(sinon.spy());
            expect(stubs.BtPairing.startScanDevice.callCount).eq(1);
        });
        it('should not call api :: startScanDevice if isAvailable() return false', ()=>{
            connector.btPanObject = null;

            // 呼び出し
            stubs.BtPairing.startScanDevice.reset();
            connector.startScanDevice(sinon.spy());
            expect(stubs.BtPairing.startScanDevice.callCount).eq(0);
        });
        it('should call callback-func after api :: startScanDevice', ()=>{
            // 事前確認
            expect(connector.isAvailable()).true;
            
            // 呼び出し
            var callback = sinon.spy();
            connector.startScanDevice(callback);
            expect(stubs.BtPairing.startScanDevice.withArgs(sinon.match.any, sinon.match.any, sinon.match.func).calledOnce).true;
            expect(callback.callCount).eq(0);

            // api :: startScanDevice へのコールバックを呼ぶと、こちらで指定したcallbackが呼ばれるはず
            stubs.BtPairing.startScanDevice.getCall(0).args[2]();
            expect(callback.callCount).eq(1);
        })
    });

    describe('#findNetworks', ()=>{
        var connector = new BtModuleMod.BtModule();

        beforeEach( ()=> {
            connector.initialize();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.findNetworks();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.findNetworks({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not callback").not.null;
                ex = null;
            }
        })
        it('should call api :: findNetworks if isAvailable() returns true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;
            expect(stubs.BtPan.findNetworks.callCount).eq(0);

            // 呼び出し
            connector.findNetworks(sinon.spy());
            expect(stubs.BtPan.findNetworks.callCount).eq(1);
        });
        it('should not call api :: findNetworks if isAvailable() return false', ()=>{
            connector.btPanObject = null;

            // 呼び出し
            stubs.BtPan.findNetworks.reset();
            connector.findNetworks(sinon.spy());
            expect(stubs.BtPan.findNetworks.callCount).eq(0);
        });
        it('should call callback-func after api :: findNetworks', ()=>{
            // 事前確認
            expect(connector.isAvailable()).true;
            
            // 呼び出し
            var callback = sinon.spy();
            connector.findNetworks(callback);
            expect(stubs.BtPan.findNetworks.withArgs(sinon.match.func).calledOnce).true;
            expect(callback.callCount).eq(0);

            // api :: findNetworks へのコールバックを呼ぶと、こちらで指定したcallbackが呼ばれるはず
            stubs.BtPan.findNetworks.getCall(0).args[0]();
            expect(callback.callCount).eq(1);
        })
    })

    describe('#findConnectedNetwork', ()=>{
        var connector = new BtModuleMod.BtModule();

        beforeEach( ()=> {
            connector.initialize();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.findConnectedNetwork();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.findConnectedNetwork({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not callback").not.null;
                ex = null;
            }
        })
        it('should call api :: findConnectedNetwork if isAvailable() returns true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;
            expect(stubs.BtPan.findConnectedNetwork.callCount).eq(0);

            // 呼び出し
            connector.findConnectedNetwork(sinon.spy());
            expect(stubs.BtPan.findConnectedNetwork.callCount).eq(1);
        });
        it('should not call api :: findConnectedNetwork if isAvailable() return false', ()=>{
            connector.btPanObject = null;

            // 呼び出し
            stubs.BtPan.findConnectedNetwork.reset();
            connector.findConnectedNetwork(sinon.spy());
            expect(stubs.BtPan.findConnectedNetwork.callCount).eq(0);
        });
        it('should call callback-func after api :: findConnectedNetwork', ()=>{
            // 事前確認
            expect(connector.isAvailable()).true;
            
            // 呼び出し
            var callback = sinon.spy();
            connector.findConnectedNetwork(callback);
            expect(stubs.BtPan.findConnectedNetwork.withArgs(sinon.match.func).calledOnce).true;
            expect(callback.callCount).eq(0);

            // api :: findConnectedNetwork へのコールバックを呼ぶと、こちらで指定したcallbackが呼ばれるはず
            stubs.BtPan.findConnectedNetwork.getCall(0).args[0]();
            expect(callback.callCount).eq(1);
        })
    })

    describe('#connect', () => {
        var
        connector = new BtModuleMod.BtModule(),
        connectAddr = "12345",
        disconnectAddr = "99999",
        callback = sinon.spy();

        before( () => {
            connector.initialize();
        });

        afterEach( () => {
            callback.reset();
            // reset spy
            stubs.BtPan.connectToNetwork.reset();
            stubs.BtPan.disconnectFromNetwork.reset();
        });

        it('should call pan-connect', () => {
            connector.connectToNetworkEx(connectAddr, '', callback);

            expect(
                stubs.BtPan.connectToNetwork
                .withArgs(connectAddr, connector.btPanObject.S_BT_PAN_ROLE.S_BT_PAN_ROLE_NAP, sinon.match.func)
                .calledOnce
            ).to.true;
        });
        it('should call callback after pan-connect with error status', () => {
            connector.connectToNetworkEx(connectAddr, '', callback);
            expect(callback.callCount, "callback not yet before pan-connect is done").eq(0);

            // panConnect からのコールバック
            var callbackFromPanConnect = stubs.BtPan.connectToNetwork.args[0][2];
            callbackFromPanConnect();
            expect(callback.withArgs().calledOnce, "callback without error after pan-connect is done").to.true;

            // with error
            var err = { message: "" };
            callback.reset();
            callbackFromPanConnect(err);
            expect(callback.withArgs(err).calledOnce, "callback(error) after pan-connect is done").to.true;
        });
        it('should call pan-disconnect if it passed', () => {
            connector.connectToNetworkEx(connectAddr, disconnectAddr, callback);

            expect(
                stubs.BtPan
                .disconnectFromNetwork
                .withArgs(disconnectAddr, sinon.match.func)
                .calledOnce
            ).to.true;
        });
        it('should call pan-connect after disconnect if no error', () => {
            connector.connectToNetworkEx(connectAddr, disconnectAddr, callback);
            expect(stubs.BtPan.connectToNetwork.callCount, "pan-connect not yet before disconnect is done").eq(0);

            // panDisconnect からのコールバック
            var callbackFromPanDisconnect = stubs.BtPan.disconnectFromNetwork.args[0][1];
            callbackFromPanDisconnect();

            expect(
                stubs.BtPan
                .connectToNetwork
                .withArgs(connectAddr, connector.btPanObject.S_BT_PAN_ROLE.S_BT_PAN_ROLE_NAP, sinon.match.func)
                .calledOnce
            ).to.true;
        });
        it('should call callback with error and not call pan-connect if disconnect returned error', () => {
            connector.connectToNetworkEx(connectAddr, disconnectAddr, callback);
            expect(stubs.BtPan.connectToNetwork.callCount, "pan-connect not yet before disconnect is done").eq(0);
            expect(callback.callCount, "callback not yet before pan-disconnect is done").eq(0);

            // panDisconnect からのコールバック
            var callbackFromPanDisconnect = stubs.BtPan.disconnectFromNetwork.args[0][1];

            var err = { message: "" };
            callbackFromPanDisconnect(err);

            expect(stubs.BtPan.connectToNetwork.callCount, "no pan-connect if error occured").eq(0);
            expect(callback.calledOnce).to.true;
            expect(callback.args[0][0], "callback(error) if disconnect failed").eq(err);
        });
        it('should throw an exception if PanObject not exists', () => {
            var ex = null;

            try {
                new BtModuleMod.BtModule().initialize().connectToNetworkEx(connectAddr, null, callback);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex).not.null;
            }
        });
        it('should throw an exception if without address to connect or without callback', () => {
            var ex = null;

            try {
                connector.connectToNetworkEx(null, null, callback);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "exception with null connection address").not.null;
                ex = null;
            }

            try {
                connector.connectToNetworkEx("", null, callback);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "exception with empty connection address").not.null;
                ex = null;
            }

            try {
                connector.connectToNetworkEx(connectAddr, null);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "exception without callback").not.null;
                ex = null;
            }

            try {
                connector.connectToNetworkEx(connectAddr, null, null);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "exception with null callback").not.null;
                ex = null;
            }
        });
        it('should throw an exception if invalid disconnection address', () => {
            var ex = null, conAddr = '123456789', callback = function(){};

            try {
                connector.connectToNetworkEx(conAddr, null, callback);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "exception with null disconnection address").not.null;
                ex = null;
            }

            try {
                connector.connectToNetworkEx(conAddr, {}, callback);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "exception with object as disconnection address").not.null;
                ex = null;
            }

            try {
                connector.connectToNetworkEx(conAddr, 123, callback);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "exception with number as disconnection address").not.null;
                ex = null;
            }

            try {
                connector.connectToNetworkEx(conAddr, "", callback);
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "NO exception with empty string as disconnection address").null;
                ex = null;
            }
        })
        it('should throw an exception if object is passed as a callback', () => {
            var ex = null;
            try {
                connector.connectToNetworkEx(connectAddr, null, {});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "exception with object as callback").not.null;
                ex = null;
            }
        });
    });

    describe('#setDeviceRegisteredEventListener', ()=>{
        var
        connector = new BtModuleMod.BtModule(),
        handler = sinon.spy();

        beforeEach( ()=> {
            connector.initialize();
            stubs.BtPairing.on.reset();
            handler.reset();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.setDeviceRegisteredEventListener();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.setDeviceRegisteredEventListener({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not handler").not.null;
                ex = null;
            }
        })
        it('should send deviceRegistered event to PairingObj if isAvailable() return true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;

            // 呼び出し
            connector.setDeviceRegisteredEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceRegistered", handler).calledOnce).true;
        });
        it('should not send deviceRegistered event to PairingObj if isAvailable() return false', ()=>{
            // no-available 状態にする
            connector.btPanObject = null;

            // 呼び出し
            connector.setDeviceRegisteredEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceRegistered").callCount).eq(0);
        });
    });

    describe('#setDeviceUnregisteredEventListener', ()=>{
        var
        connector = new BtModuleMod.BtModule(),
        handler = sinon.spy();

        beforeEach( ()=> {
            connector.initialize();
            stubs.BtPairing.on.reset();
            handler.reset();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.setDeviceUnregisteredEventListener();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.setDeviceUnregisteredEventListener({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not handler").not.null;
                ex = null;
            }
        })
        it('should send deviceUnregistered event to PairingObj if isAvailable() return true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;

            // 呼び出し
            connector.setDeviceUnregisteredEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceUnregistered", handler).calledOnce).true;
        });
        it('should not send deviceUnregistered event to PairingObj if isAvailable() return false', ()=>{
            // no-available 状態にする
            connector.btPanObject = null;

            // 呼び出し
            connector.setDeviceUnregisteredEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceUnregistered").callCount).eq(0);
        });
    });

    describe('#setDeviceFoundEventListener', ()=>{
        var
        connector = new BtModuleMod.BtModule(),
        handler = sinon.spy();

        beforeEach( ()=> {
            connector.initialize();
            stubs.BtPairing.on.reset();
            handler.reset();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.setDeviceFoundEventListener();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.setDeviceFoundEventListener({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not handler").not.null;
                ex = null;
            }
        })
        it('should send deviceFound event to PairingObj if isAvailable() return true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;

            // 呼び出し
            connector.setDeviceFoundEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceFound", handler).calledOnce).true;
        });
        it('should not send deviceFound event to PairingObj if isAvailable() return false', ()=>{
            // no-available 状態にする
            connector.btPanObject = null;

            // 呼び出し
            connector.setDeviceFoundEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceFound").callCount).eq(0);
        });
    });

    describe('#setDeviceLostEventListener', ()=>{
        var
        connector = new BtModuleMod.BtModule(),
        handler = sinon.spy();

        beforeEach( ()=> {
            connector.initialize();
            stubs.BtPairing.on.reset();
            handler.reset();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.setDeviceLostEventListener();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.setDeviceLostEventListener({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not handler").not.null;
                ex = null;
            }
        })
        it('should send deviceLost event to PairingObj if isAvailable() return true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;

            // 呼び出し
            connector.setDeviceLostEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceLost", handler).calledOnce).true;
        });
        it('should not send deviceLost event to PairingObj if isAvailable() return false', ()=>{
            // no-available 状態にする
            connector.btPanObject = null;

            // 呼び出し
            connector.setDeviceLostEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceLost").callCount).eq(0);
        });
    });

    describe('#setDeviceStatusChangedEventListener', ()=>{
        var
        connector = new BtModuleMod.BtModule(),
        handler = sinon.spy();

        beforeEach( ()=> {
            connector.initialize();
            stubs.BtPairing.on.reset();
            handler.reset();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.setDeviceStatusChangedEventListener();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.setDeviceStatusChangedEventListener({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not handler").not.null;
                ex = null;
            }
        })
        it('should send deviceChanged event to PairingObj if isAvailable() return true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;

            // 呼び出し
            connector.setDeviceStatusChangedEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceChanged", handler).calledOnce).true;
        });
        it('should not send deviceChanged event to PairingObj if isAvailable() return false', ()=>{
            // no-available 状態にする
            connector.btPanObject = null;

            // 呼び出し
            connector.setDeviceStatusChangedEventListener(handler);
            expect(stubs.BtPairing.on.withArgs("deviceChanged").callCount).eq(0);
        });
    });

    describe('#setPanStatusChangedEventListener', ()=>{
        var
        connector = new BtModuleMod.BtModule(),
        handler = sinon.spy();

        beforeEach( ()=> {
            connector.initialize();
            stubs.BtPan.on.reset();
            handler.reset();
        });

        it('should throw exception if invalid args', ()=>{
            var ex = null;
            try {
                connector.setPanStatusChangedEventListener();
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if no args").not.null;
                ex = null;
            }
            try {
                connector.setPanStatusChangedEventListener({});
            }
            catch(_ex) {
                ex = _ex;
            }
            finally {
                expect(ex, "ex if not handler").not.null;
                ex = null;
            }
        })
        it('should send statusChanged event to PairingObj if isAvailable() return true', () => {
            // 事前確認
            expect(connector.isAvailable()).true;

            // 呼び出し
            connector.setPanStatusChangedEventListener(handler);
            expect(stubs.BtPan.on.withArgs("statusChanged", handler).calledOnce).true;
        });
        it('should not send statusChanged event to PairingObj if isAvailable() return false', ()=>{
            // no-available 状態にする
            connector.btPanObject = null;

            // 呼び出し
            connector.setPanStatusChangedEventListener(handler);
            expect(stubs.BtPan.on.withArgs("statusChanged").callCount).eq(0);
        });
    });
});