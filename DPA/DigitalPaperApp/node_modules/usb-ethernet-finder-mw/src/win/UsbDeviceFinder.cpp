//
//  UsbDeviceFinder.cpp
// 
//  Copyright 2016 Sony Corporation
//

#include "UsbDeviceFinder.h"
#include "CmApiWrap.h"
#include "WinErrorCode.h"
#include "macro.h"
#include "../Log.h"

#include <vector>
#include <tchar.h>
#include <iostream>
#include <iomanip>
#include <algorithm>

#define USB_PREFIX _T("USB\\")


std::string UsbDeviceFinder::FindUsbDevices(
	/*[in]*/ const UINT16 idVendor,
	/*[in]*/ const UINT16 idProduct,
	/*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& rvDeviceList
	) {
	// 検索対象のUSBデバイス "USB\\VID_%04X&PID_%04X"
	tstringstream strTargetDevice;
	strTargetDevice << _T("USB\\VID_") << std::setfill(_T('0')) << std::setw(4) << std::hex << idVendor
		<< _T("&PID_") << std::setfill(_T('0')) << std::setw(4) << std::hex << idProduct;
	tstring sTargetDevice = strTargetDevice.str();

	return UsbDeviceFinder::FindUsbDevices(sTargetDevice, rvDeviceList);
}

std::string UsbDeviceFinder::FindUsbDevices(
	/*[in]*/ tstring& rsPnpDeviceId,
	/*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& rvDeviceList
	) {
	std::string errMsg;
	try {
		CONFIGRET cResult = CR_SUCCESS;

		DEVINST ulDevInst = 0;
		cResult = ::CM_Locate_DevNode(&ulDevInst, NULL, CM_LOCATE_DEVNODE_NORMAL);
		if (cResult != CR_SUCCESS) {
			errMsg = WinErrorCode::ToWinErrStr(cResult);
			LOG_ERROR(_T("::CM_Locate_DevNode(CM_LOCATE_DEVNODE_NORMAL) failed. [%S]"), errMsg.c_str());
			throw cResult;
		}

		UsbDeviceFinder::FindUsbDevices(rsPnpDeviceId, ulDevInst, nullptr, rvDeviceList);
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}
	return errMsg;
}

std::string UsbDeviceFinder::EnumUsbDevices(
	/*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& rvDeviceList
	) {
	std::string errMsg;
	try {
		CONFIGRET cResult = CR_SUCCESS;

		DEVINST ulDevInst = 0;
		cResult = ::CM_Locate_DevNode(&ulDevInst, NULL, CM_LOCATE_DEVNODE_NORMAL);
		if (cResult != CR_SUCCESS) {
			errMsg = WinErrorCode::ToWinErrStr(cResult);
			LOG_ERROR(_T("::CM_Locate_DevNode(CM_LOCATE_DEVNODE_NORMAL) failed. [%S]"), errMsg.c_str());
			throw cResult;
		}

		UsbDeviceFinder::FindUsbDevices(USB_PREFIX, ulDevInst, nullptr, rvDeviceList);
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}
	return errMsg;
}


void UsbDeviceFinder::FindUsbDevices(
	/*[in]*/ const tstring& rTargetDevice,
	/*[in]*/ const DEVINST ulDevInst,
	/*[in]*/ std::shared_ptr<UsbDevice> spParentDevice,
	/*[out]*/ std::vector<std::shared_ptr<UsbDevice>>& rvDeviceList
	) {

	CONFIGRET cResult = CR_SUCCESS;

	// PNP Device ID を取得する
	tstring sDeviceId;
	CmApiWrap::GetDeviceId(ulDevInst, sDeviceId);

	// VID, PID を取得する
	UINT16 idVendor = 0;
	UINT16 idProduct = 0;
	ExtractVidPidSerial(sDeviceId, idVendor, idProduct, nullptr);

	if (spParentDevice
		&& idVendor == spParentDevice->idVendor
		&& idProduct == spParentDevice->idProduct
		) {
		// USB Composite Device の子ノードの場合
		std::shared_ptr<UsbDevice> spDevice = std::make_shared<UsbDevice>();
		spDevice->sPnpDeviceId = sDeviceId;
		GetDeviceInfo(ulDevInst, spDevice);

		spParentDevice->vChildList.push_back(spDevice);

		// 子ノードを探す
		DEVINST ulDevInstChild = 0;
		cResult = ::CM_Get_Child(&ulDevInstChild, ulDevInst, 0);
		if (cResult == CR_SUCCESS) {
			FindUsbDevices(rTargetDevice, ulDevInstChild, spDevice, rvDeviceList);
		}

		// 兄弟ノードを探す
		DEVINST ulDevInstSibling = 0;
		cResult = ::CM_Get_Sibling(&ulDevInstSibling, ulDevInst, 0);
		if (cResult == CR_SUCCESS) {
			FindUsbDevices(rTargetDevice, ulDevInstSibling, spDevice, rvDeviceList);
		}
	}
	else if (!sDeviceId.empty()
		&& ::_tcsicmp(rTargetDevice.c_str(), sDeviceId.substr(0, rTargetDevice.length()).c_str()) == 0) {

		// 検索対象のUSBデバイスの場合
		std::shared_ptr<UsbDevice> spTargetDevice = std::make_shared<UsbDevice>();
		spTargetDevice->sPnpDeviceId = sDeviceId;
		GetDeviceInfo(ulDevInst, spTargetDevice);

		// 子ノードを探す
		DEVINST ulDevInstChild = 0;
		cResult = ::CM_Get_Child(&ulDevInstChild, ulDevInst, 0);
		if (cResult == CR_SUCCESS) {
			FindUsbDevices(rTargetDevice, ulDevInstChild, spTargetDevice, rvDeviceList);
		}

		rvDeviceList.push_back(spTargetDevice);

		// 兄弟ノードを探す
		DEVINST ulDevInstSibling = 0;
		cResult = ::CM_Get_Sibling(&ulDevInstSibling, ulDevInst, 0);
		if (cResult == CR_SUCCESS) {
			FindUsbDevices(rTargetDevice, ulDevInstSibling, nullptr, rvDeviceList);
		}
	}
	else {
		// 子ノードを探す
		DEVINST ulDevInstChild = 0;
		cResult = ::CM_Get_Child(&ulDevInstChild, ulDevInst, 0);
		if (cResult == CR_SUCCESS) {
			FindUsbDevices(rTargetDevice, ulDevInstChild, nullptr, rvDeviceList);
		}

		// 兄弟ノードを探す
		DEVINST ulDevInstSibling = 0;
		cResult = ::CM_Get_Sibling(&ulDevInstSibling, ulDevInst, 0);
		if (cResult == CR_SUCCESS) {
			FindUsbDevices(rTargetDevice, ulDevInstSibling, nullptr, rvDeviceList);
		}
	}
}


void UsbDeviceFinder::GetDeviceInfo(
	/*[in]*/ const DEVINST ulDevInst,
	/*[in,out]*/ std::shared_ptr<UsbDevice>& spDevice
	) {
	std::string errMsg;

	// CM_DRP_DEVICEDESC
	errMsg = UsbDeviceFinder::GetDeviceProperty(ulDevInst, CM_DRP_DEVICEDESC, spDevice->sDeviceDesc);
	if (!errMsg.empty()) {
		LOG_DEBUG(_T("UsbDeviceFinder::GetDeviceProperty( CM_DRP_DEVICEDESC ) failed. [%S]"), errMsg.c_str());
	}

	// CM_DRP_FRIENDLYNAME
	errMsg = UsbDeviceFinder::GetDeviceProperty(ulDevInst, CM_DRP_FRIENDLYNAME, spDevice->sFriendlyName);
	if (!errMsg.empty()) {
		LOG_DEBUG(_T("UsbDeviceFinder::GetDeviceProperty( CM_DRP_FRIENDLYNAME ) failed. [%S]"), errMsg.c_str());
	}

	// CM_DRP_MFG
	errMsg = UsbDeviceFinder::GetDeviceProperty(ulDevInst, CM_DRP_MFG, spDevice->sManufacturer);
	if (!errMsg.empty()) {
		LOG_DEBUG(_T("UsbDeviceFinder::GetDeviceProperty( CM_DRP_MFG ) failed. [%S]"), errMsg.c_str());
	}

	// CM_DRP_CLASS
	errMsg = UsbDeviceFinder::GetDeviceProperty(ulDevInst, CM_DRP_CLASS, spDevice->sClass);
	if (!errMsg.empty()) {
		LOG_DEBUG(_T("UsbDeviceFinder::GetDeviceProperty( CM_DRP_CLASS ) failed. [%S]"), errMsg.c_str());
	}

	// CM_DRP_SERVICE
	errMsg = UsbDeviceFinder::GetDeviceProperty(ulDevInst, CM_DRP_SERVICE, spDevice->sService);
	if (!errMsg.empty()) {
		LOG_DEBUG(_T("UsbDeviceFinder::GetDeviceProperty( CM_DRP_SERVICE ) failed. [%S]"), errMsg.c_str());
	}

	// idVendor, idProduct, serialNumber
	ExtractVidPidSerial(spDevice->sPnpDeviceId, spDevice->idVendor, spDevice->idProduct, &spDevice->sSerialNumber);
}

void UsbDeviceFinder::ExtractVidPidSerial(
	/*[in]*/ const tstring& rsPnpDeviceId,
	/*[out]*/ UINT16& idVendor,
	/*[out]*/ UINT16& idProduct,
	/*[out]*/ tstring* psSerialNumber
	) {
	if (rsPnpDeviceId.empty()) {
		return;
	}

	tstring sPnpDeviceId = rsPnpDeviceId;

	// SerialNumber の抽出
	if (psSerialNumber) {
		const std::string::size_type index = sPnpDeviceId.rfind(_T('\\'));
		if (index != std::string::npos) {
			*psSerialNumber = sPnpDeviceId.substr(index + 1);
		}
	}

	// PNP Device ID を大文字に変換
	std::transform(sPnpDeviceId.begin(), sPnpDeviceId.end(), sPnpDeviceId.begin(), ::toupper);

	// idVendor の抽出
	const std::string::size_type iVid = sPnpDeviceId.find(_T("VID_"));
	if (iVid != std::string::npos) {
		const tstring sVid = sPnpDeviceId.substr(iVid + 4, 4);
		TCHAR* pszEnd = nullptr;
		idVendor = (UINT16)::_tcstol((LPCTSTR)sVid.c_str(), &pszEnd, 16);
	}

	// idProduct の抽出
	const std::string::size_type iPid = sPnpDeviceId.find(_T("PID_"));
	if (iPid > 0) {
		const tstring sPid = sPnpDeviceId.substr(iPid + 4, 4);
		TCHAR* pszEnd = nullptr;
		idProduct = (UINT16)::_tcstol((LPCTSTR)sPid.c_str(), &pszEnd, 16);
	}
}


std::string UsbDeviceFinder::GetDeviceProperty(
	/*[in]*/ const DEVINST ulDevInst,
	/*[in]*/ const ULONG ulPropertyId,
	/*[out]*/ tstring& rsProperty
	) {
	std::string errMsg;
	try	{
		std::vector<tstring> vProperties;
		errMsg = UsbDeviceFinder::GetDeviceProperties(ulDevInst, ulPropertyId, vProperties);
		if (!errMsg.empty()) {
			LOG_DEBUG(_T("UsbDeviceFinder::GetDeviceProperties( 0x%08X ) failed. [%S]"), ulPropertyId, errMsg.c_str());
			throw CR_FAILURE;
		}
		if (!vProperties.empty()) {
			rsProperty = vProperties[0];
		}
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}
	return errMsg;
}


std::string UsbDeviceFinder::GetDeviceProperties(
	/*[in]*/ const DEVINST ulDevInst,
	/*[in]*/ const ULONG ulPropertyId,
	/*[out]*/ std::vector<tstring>& rvProperties
	) {
	std::string errMsg;
	try	{
		ULONG ulRegType = 0;
		ULONG ulDataSize = 0;
		AutoBinaryPtr spData;
		errMsg = CmApiWrap::GetDevNodeRegistryProperty(ulDevInst, ulPropertyId, ulRegType, ulDataSize, spData);
		if (!errMsg.empty()) {
			LOG_DEBUG(_T("CmApiWrap::GetDevNodeRegistryProperty( 0x%08X ) failed. [%S]"), ulPropertyId, errMsg.c_str());
			throw CR_FAILURE;
		}

		rvProperties = UsbDeviceFinder::GetPropertyStrings(ulRegType, ulDataSize, spData);
	}
	catch (...) {
		if (errMsg.empty()) {
			errMsg = WinErrorCode::GetLastError();
			LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
		}
	}
	return errMsg;
}


std::vector<tstring> UsbDeviceFinder::GetPropertyStrings(
	/*[in]*/ const ULONG ulRegType,
	/*[in]*/ const ULONG ulDataSize,
	/*[in]*/ const AutoBinaryPtr& rspData
	) {
	std::vector<tstring> vProperties;

	switch (ulRegType) {
	case REG_SZ:
	case REG_EXPAND_SZ:
		{
			tstring property = tstring((LPCTSTR)rspData.m_pData);
			vProperties.push_back(property);
		}
		break;

	case REG_MULTI_SZ:
		{
			TCHAR* pPos = (TCHAR*)rspData.m_pData;
			for (; *pPos != _T('\0'); pPos += ::_tcslen(pPos) + 1) {
				vProperties.push_back(tstring(pPos));
			}
		}
		break;

	case REG_DWORD:
		if (ulDataSize == sizeof(UINT32))
		{
			UINT32 ulData = 0;
			::memcpy_s(&ulData, sizeof(ulData), rspData.m_pData, ulDataSize);

			tstringstream streamData;
			streamData << _T("0x") << std::setfill(_T('0')) << std::setw(8) << std::hex << ulData;

			vProperties.push_back(streamData.str());
		}
		break;

	case REG_QWORD:
		if (ulDataSize == sizeof(UINT64))
		{
			UINT64 uhData = 0;
			::memcpy_s(&uhData, sizeof(uhData), rspData.m_pData, ulDataSize);

			tstringstream streamData;
			streamData << _T("0x") << std::setfill(_T('0')) << std::setw(16) << std::hex << uhData;

			vProperties.push_back(streamData.str());
		}
		break;

	case REG_BINARY:
		{
			tstring sProperty = _T("");
			for (ULONG ulIndex = 0; ulIndex < ulDataSize; ulIndex++) {

				tstringstream streamData;
				streamData << std::setfill(_T('0')) << std::setw(2) << std::hex << rspData.m_pData[ulIndex];

				sProperty += streamData.str();
			}
			vProperties.push_back(sProperty);
		}
		break;

	default:
		{
			vProperties.push_back(tstring((LPCTSTR)rspData.m_pData, ulDataSize / sizeof(TCHAR)));
		}
		break;
	}

	return vProperties;
}