//
//  UsbEthernetFinder.cpp
//
//  Copyright 2016 Sony Corporation
//

#include "UsbEthernetFinder.h"
#include "AutoCFString.h"
#include "MacErrorCode.h"
#include "../Log.h"

#include <IOKit/IOKitLib.h>
#include <IOKit/IOCFPlugIn.h>
#include <IOKit/usb/IOUSBLib.h>
#include <IOKit/IOBSD.h>

#include <mach/mach.h>


/**
 * 指定したVID/PIDを持つUSB機器の一覧を取得する。
 * 
 * @param pIdVendor     検索対象のVID
 * @param pIdProduct    検索対象のPID
 * @param deviceList    検索結果のUSB機器の一覧
 * @return 成功時には空のstringオブジェクトを、失敗時にはエラーメッセージを
 *      含むstringオブジェクトを返却する。
 */ 
std::string UsbEthernetFinder::FindDevice(
    /*[in]*/ UInt16 idVendor,
    /*[in]*/ UInt16 idProduct,
    /*[out]*/ std::vector<std::shared_ptr<UsbEthernetDevice>>& deviceList
    )
{
    std::string errMsg;
    kern_return_t kr = kIOReturnSuccess;
    try {
        // USB機器の一覧から対象の機器を検索する
        std::vector<std::shared_ptr<UsbEthernetDevice>> devices;
        kr = FindDeviceFromUsb(idVendor, idProduct, devices);
        if (kr == kIOReturnSuccess) {
            // USB(CDC-ECM)のBSD名が取得できているか確認する
            // 下記の環境にて、kIOUSBDeviceClassName を対象に検索した場合にBSD名が取得できなかった
            //  - Mack Book Pro : OS X 10.11.2 El Capitan
            //  - Mack Book Air : OS X 10.11.4 El Capitan
            for (auto it = devices.cbegin(); it != devices.cend(); it++) {
                std::shared_ptr<UsbEthernetDevice> device = *it;
                if (!device || device->bsdName.empty()) {
                    LOG_DEBUG("FindDeviceFromUsb() : BSD name is empty (%s)", device->deviceId.c_str());
                    kr = kIOReturnError;
                    break;
                }
            }
        }
        if (kr == kIOReturnSuccess) {
            deviceList = devices;
        }
        else {
            // 取得に失敗した場合には、全ての機器の一覧から対象の機器を検索する
            // kIOUSBDeviceClassNameではなく、kIOServiceClassを対象に検索する
            devices.clear();
            kr = FindDeviceFromAll(idVendor, idProduct, devices);
            if (kr != kIOReturnSuccess) {
                LOG_ERROR("FindDeviceFromAll() failed [0x%08X]", kr);
                throw kr;
            }
            
            for (auto it = devices.cbegin(); it != devices.cend(); it++) {
                std::shared_ptr<UsbEthernetDevice> device = *it;
                if (!device || device->bsdName.empty()) {
                    // kIOServiceClassを対象とした場合、BSD名を持たないnodeも検索結果に含まれる
                    LOG_DEBUG("FindDeviceFromAll() : BSD name is empty (%s)", device->deviceId.c_str());
                    continue;
                }
                deviceList.push_back(device);
            }
        }
    }
    catch (...) {
        kr = kIOReturnError;
    }
    
    if (kr != kIOReturnSuccess) {
        errMsg = MacErrorCode::ToString(kr);
    }
    return errMsg;
}

/**
 * 指定したVID/PIDを持つUSB機器の一覧を取得する。
 *
 * @param pIdVendor     検索対象のVID
 * @param pIdProduct    検索対象のPID
 * @param deviceList    検索結果のUSB機器の一覧
 * @return kr           処理結果
 */
kern_return_t UsbEthernetFinder::FindDeviceFromUsb(
                                            /*[in]*/ UInt16 idVendor,
                                            /*[in]*/ UInt16 idProduct,
                                            /*[out]*/ std::vector<std::shared_ptr<UsbEthernetDevice>>& deviceList
                                            )
{
    return FindDevice(idVendor, idProduct, kIOUSBDeviceClassName, deviceList);
}


/**
 * 指定したVID/PIDを持つUSB機器の一覧を取得する。
 *
 * @param pIdVendor     検索対象のVID
 * @param pIdProduct    検索対象のPID
 * @param deviceList    検索結果のUSB機器の一覧
 * @return kr           処理結果
 */
kern_return_t UsbEthernetFinder::FindDeviceFromAll(
                                                   /*[in]*/ UInt16 idVendor,
                                                   /*[in]*/ UInt16 idProduct,
                                                   /*[out]*/ std::vector<std::shared_ptr<UsbEthernetDevice>>& deviceList
                                                   )
{
    return FindDevice(idVendor, idProduct, kIOServiceClass, deviceList);
}

/**
 * 指定したVID/PIDを持つUSB機器の一覧を取得する。
 *
 * @param pIdVendor     検索対象のVID
 * @param pIdProduct    検索対象のPID
 * @param deviceList    検索結果のUSB機器の一覧
 * @return kr           処理結果
 */
kern_return_t UsbEthernetFinder::FindDevice(
                                            /*[in]*/ UInt16 idVendor,
                                            /*[in]*/ UInt16 idProduct,
                                            /*[in]*/ const char * serviceName,
                                            /*[out]*/ std::vector<std::shared_ptr<UsbEthernetDevice>>& deviceList
                                            )
{
    kern_return_t kr = kIOReturnSuccess;
    mach_port_t masterPort = 0;
    
    try {
        // Master IOKit Port の作成
        kr = IOMasterPort(MACH_PORT_NULL, &masterPort);
        if (kIOReturnSuccess != kr || !masterPort) {
            LOG_ERROR("IOMasterPort() failed [0x%08X]", kr);
            throw kr;
        }
        
        // USB matching dictionary の作成
        CFMutableDictionaryRef matchingDict = IOServiceMatching(serviceName);
        if (!matchingDict) {
            LOG_ERROR("IOServiceMatching(%s) failed [0x%08X]", serviceName, kr);
            throw kr;
        }
        
        // 検索対象のVendorIDを辞書に登録
        SInt32 vid = idVendor;
        CFNumberRef vendorId = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &vid);
        CFDictionarySetValue(matchingDict, CFSTR(kUSBVendorID), vendorId);
        CFRelease(vendorId);
        
        // 検索対象のProductIDを辞書に登録
        SInt32 pid = idProduct;
        CFNumberRef productId  = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &pid);
        CFDictionarySetValue(matchingDict, CFSTR(kUSBProductID), productId);
        CFRelease(productId);
        
        // 対象のUSBデバイスを検索
        io_iterator_t existingDevices;
        kr = IOServiceGetMatchingServices(masterPort, matchingDict, &existingDevices);
        if (kIOReturnSuccess != kr) {
            LOG_ERROR("IOServiceGetMatchingServices() failed [0x%08X]", kr);
            throw kr;
        }
        
        io_service_t device;
        while ( (device = IOIteratorNext(existingDevices)) )
        {
            std::shared_ptr<UsbEthernetDevice> spNicDevice = std::make_shared<UsbEthernetDevice>();
            
            kr = GetDeviceInfo(device, spNicDevice);
            if (kr == kIOReturnSuccess) {
                deviceList.push_back(spNicDevice);
            }
            
            // io_service_t の解放
            IOObjectRelease(device);
        }
        kr = kIOReturnSuccess;
        
        // io_iterator_t の解放
        IOObjectRelease(existingDevices);
        
        // Master IOKit Port の解放
        mach_port_deallocate(mach_task_self(), masterPort);
    }
    catch (kern_return_t krException) {
        if (krException == kIOReturnSuccess) {
            kr = kIOReturnError;
        }
    }
    catch (...) {
        kr = kIOReturnError;
    }
    
    if (masterPort) {
        mach_port_deallocate(mach_task_self(), masterPort);
        masterPort = 0;
    }
    
    return kr;
}




/**
 * USB機器の情報を取得する。
 *
 * @param   ioDevice            対象のUSB機器
 * @param   spDevice            取得した情報の格納先
 * @return  kr                  処理結果
 */
kern_return_t UsbEthernetFinder::GetDeviceInfo(
                                               /*[in]*/ io_service_t ioDevice,
                                               /*[out]*/ std::shared_ptr<UsbEthernetDevice>& spDevice
                                               )
{
    kern_return_t kr = kIOReturnSuccess;
    
    IOCFPlugInInterface** ppPlugInInterface = NULL;
    IOUSBDeviceInterface** ppDeviceInterface = NULL;
    
    try {
        // デバイス名
        io_name_t deviceName = {0};
        kr = IORegistryEntryGetName(ioDevice, deviceName);
        if (kIOReturnSuccess != kr) {
            LOG_ERROR("IORegistryEntryGetName() failed [0x%08X]", kr);
        }
        spDevice->deviceName = deviceName;
        
        // パス名
        io_string_t pathName = {0};
        kr = IORegistryEntryGetPath(ioDevice, kIOServicePlane, pathName);
        if (kIOReturnSuccess != kr) {
            LOG_ERROR("IORegistryEntryGetName() failed [0x%08X]", kr);
        }
        spDevice->deviceId = pathName;
        
        // IOCFPlugInInterface の取得
        SInt32 score = 0;
        kr = IOCreatePlugInInterfaceForService(
                                               ioDevice,
                                               kIOUSBDeviceUserClientTypeID,
                                               kIOCFPlugInInterfaceID,
                                               &ppPlugInInterface,
                                               &score
                                               );
        if ((kIOReturnSuccess != kr) || !ppPlugInInterface)
        {
//            LOG_ERROR("IOCreatePlugInInterfaceForService(kIOUSBDeviceUserClientTypeID) failed [0x%08X]", kr);
            throw kr;
        }
        
        // IOUSBDeviceInterface の取得
        HRESULT hr = (*ppPlugInInterface)->QueryInterface(
                                                          ppPlugInInterface,
                                                          CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID),
                                                          (void**)&ppDeviceInterface
                                                          );
        if (FAILED(hr) || !ppDeviceInterface) {
            LOG_ERROR("QueryInterface(kIOUSBDeviceInterfaceID) failed [0x%08X]", hr);
            throw kIOReturnError;
        }
        
        // Vendor ID
        UInt16 vendorId = 0;
        kr = (*ppDeviceInterface)->GetDeviceVendor(ppDeviceInterface, &vendorId);
        if(kIOReturnSuccess != kr) {
            LOG_ERROR("GetDeviceVendor() failed [0x%08X]", hr);
        }
        spDevice->vendorId = vendorId;
        
        // Product ID
        UInt16 productId = 0;
        kr = (*ppDeviceInterface)->GetDeviceProduct(ppDeviceInterface, &productId);
        if(kIOReturnSuccess != kr) {
            LOG_ERROR("GetDeviceProduct() failed [0x%08X]", hr);
        }
        spDevice->productId = productId;
        
        // Vendor Name
        AutoCFString vendorName =
        (CFStringRef)IORegistryEntrySearchCFProperty(
                                                     ioDevice,
                                                     kIOServicePlane,
                                                     CFSTR(kUSBVendorString),
                                                     kCFAllocatorDefault,
                                                     kIORegistryIterateRecursively
                                                     );
        if (vendorName) {
            vendorName.copy(spDevice->vendorName);
        }
        
        // Serial Nuber
        AutoCFString serialNumber =
        (CFStringRef)IORegistryEntrySearchCFProperty(
                                                     ioDevice,
                                                     kIOServicePlane,
                                                     CFSTR(kUSBSerialNumberString),
                                                     kCFAllocatorDefault,
                                                     kIORegistryIterateRecursively
                                                     );
        if (serialNumber) {
            serialNumber.copy(spDevice->serialNumber);
        }
        
        // BSD Name
        AutoCFString bsdName =
        (CFStringRef)IORegistryEntrySearchCFProperty(
                                                     ioDevice,
                                                     kIOServicePlane,
                                                     CFSTR(kIOBSDNameKey),
                                                     kCFAllocatorDefault,
                                                     kIORegistryIterateRecursively
                                                     );
        if (bsdName) {
            bsdName.copy(spDevice->bsdName);
        }
    }
    catch (kern_return_t krException) {
        if (krException == kIOReturnSuccess) {
            kr = kIOReturnError;
        }
    }
    catch (...) {
        kr = kIOReturnError;
    }
    
    if (ppPlugInInterface && *ppPlugInInterface) {
        (*ppPlugInInterface)->Release(ppPlugInInterface);
        *ppPlugInInterface = NULL;
    }
    
    if (ppDeviceInterface && *ppDeviceInterface) {
        (*ppDeviceInterface)->Release(ppDeviceInterface);
        *ppDeviceInterface = NULL;
    }
    
    return kr;
}
