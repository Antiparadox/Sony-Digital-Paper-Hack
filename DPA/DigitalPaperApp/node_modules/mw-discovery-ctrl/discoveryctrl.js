/*
  discovery.js
  
  created:    [2016-05-19 16:29:02+09:00]
  modified:   [2016-10-06 16:01:52+09:00]
  description:
  Device Discovery implementation.
*/
'use strict';

const EventEmitter = require('events').EventEmitter;

const emitter = new EventEmitter();

const AutoBtPanConnector = require('mw-auto-bt-pan-connector');
const autoBtPanConnector = AutoBtPanConnector.getInstance();

const OS = require('os');

const log_e = require('debug')('mw-discovery-ctrl:discovery:error');
const log_d = require('debug')('mw-discovery-ctrl:discovery:debug');

/** @exports mw-discovery-ctrl */
const discovery = exports;

var closing_ = false;

/* ----------------------------- */
/* --- define                    */
/* ----------------------------- */

/**
 * Phyisical connection type that indicates Deneb direct USB-ether.
 * <br>
 * 物理的な接続が、DenebのUSB-Ether直結であることを示す。
 */
discovery.PHY_TYPE_USB = 'USB';

/**
 * Phyisical connection type indicates other than above.
 * <br>
 * 物理的な接続が、上記以外の方式であることを示す。
 */
discovery.PHY_TYPE_OTHER = 'OTHER';


/* ----------------------------- */
/* --- local implement           */
/* ----------------------------- */

const deviceCache = require('./lib/device_list');
const browser = require('./lib/discovery_proxy');
const deviceChecker = require('./lib/checker');
const networkChecker = require('./lib/nicwatcher');
const constants = require('./lib/constants');
const dptUsbInitiator = require('mw-usb-initiator');

const TaskRunner = require('./lib/task_runner').TaskRunner;
const taskRunner = new TaskRunner();
taskRunner.run();

// --- USB接続イベントのパススルー
// USB(CDC-ACM)接続通知の登録
dptUsbInitiator.on('add:serialport', function (device) {
  emitter.emit("usbSerialConnected", device);
});// USB(CDC-ACM)切断通知の登録
dptUsbInitiator.on('remove:serialport', function (device) {
  emitter.emit("usbSerialDisconnected", device);
});
// USB(RNDIS/CDC-ECM)接続通知の登録
dptUsbInitiator.on('add:ethernet', function (device) {
  // Altair実行中にDenebをUSB接続した際に呼び出される。
  // device (=Ether情報) からIpV6アドレスが生成できた場合は、ここで(mDNSを通す前に)登録処理を呼び出す。
  //
  // 抜き挿しがある程度の速さだと、Remove処理の途中にAddedイベントが発生するため、
  // Remove -> Added -> register(here) -> DeviceAppear -> fetch -> Removedにより失敗、
  // というフローが存在する。
  // よって、既存のDiscoveryと同じタイミング(5sec)だけ、登録処理をずらす
  setTimeout(()=>{
    var discoveryData = browser.getRegisterDataFromUsbEther(device);
    if (discoveryData) {
      browser.register(discoveryData);
    }
  }, 5000);

  // ブラウザに新規IPアドレスの通知
  browser.addUsbLink(device.ipV6.address);
  //再ディスカバリする
  setTimeout(function() {
    browser.discovery(true);
  }, 5000);
  // ネットワークカードの変更検出キャンセル＆リスタート
  networkChecker.stop();
  networkChecker.start();
  //
  emitter.emit("usbEtherConnected", device);
});

log_d('loading');

// USB(RNDIS/CDC-ECM)切断通知の登録
dptUsbInitiator.on('remove:ethernet', function (device) {
  // ブラウザに消えたことを通知
  browser.removeUsbLink(device.ipV6.address);
  // リストから削除、リスト登録済アドレスであったら切断されたものとして通知
  var removeitem = deviceCache.remove('localip', device.ipV6.address);
  for(const disappear of removeitem) {
    emitter.emit("deviceDisappear", disappear);
  }
  //再ディスカバリする
  // setTimeout(browser.discovery, 3000);
  // ネットワークカードの変更検出キャンセル＆リスタート
  networkChecker.stop();
  networkChecker.start();
  //
  emitter.emit("usbEtherDisconnected", device);
});

// USBの接続/切断の検出処理を開始する
dptUsbInitiator.start(function (error, usbSerialArray, usbEtherArray) {
  if (error) {
    log_e('\n[ERROR] UsbInitiator.start() :\n', error);
    process.nextTick(function() {
      emitter.emit('error', error);
    });
    return;
  }
  log_d('usb-initiator initialized');
  // ether item があったらブラウザに教えておく
  for(const item of usbEtherArray) {
    if (item.ipV6 !== undefined) {
      // Altair起動時にネットワークインターフェース接続済みのDenebがある場合にここを通る。
      // Ether情報からIpV6アドレスが生成できた場合は、ここで(mDNSを通す前に)登録処理を呼び出す。
      var discoveryData = browser.getRegisterDataFromUsbEther(item);
      if (discoveryData) {
        browser.register(discoveryData);
      }

      browser.addUsbLink(item.ipV6.address);
      //再ディスカバリする
      // setTimeout(browser.discovery, 3000);
    }
  }

  // mdnsのDiscoveryをここで起動する。
  browser.browserStart();
  // 初回時の start でクエリを投げるため基本的には上記の brouserStart() でクエリされているはず
  // UDPドロップの回避をするため時間をおいてもう一回クエリする
  // setTimeout(function() {
  //   browser.discovery(true);
  // }, 5000);
  sendMultipleDiscovery(true, 5000, 3, 3000);

  // ネットワークカードの変更検出開始
  networkChecker.start();
});

// ネットワークインタフェースの数に変動があった
networkChecker.on('changed' , function() {
  //ブラウザを再起動する
  setTimeout(function() {
    browser.stop();
    browser.browserStart();
    //登録済み全デバイスのpingチェックを行う
    let items = deviceCache.get('all');
    let ping_check = true;
    for(const device of items) {
      deviceChecker.ping(device.remoteIp, device.remotePort, function(addr, apiversion) {
        // [2016-07-29 00:12:25+09:00] kan.k: [TODO] レアケースですが、
        // portfwdrのエラーが握りつぶされています。nodeのcallbackマナー
        // に従って、第一引数を、errとするべきと思います。そしてエラーの
        // 時には、 `emitter.emit('error', error);` で返すという形にして
        // いただきたいです。
        if (apiversion === null) {
          deviceCache.remove('ip', addr);
          // いなくなっていたら通知
          emitter.emit("deviceDisappear", device);
        }
      });
    }
    // browserStart() 時のクエリに期待していたが、再スタート時はクエリを投げない模様
    // またnetwork検出時は USBの時と同じく数秒の準備時間があるらしく即時のクエリも無効
    // これらを回避するため時間をおいてクエリを投げるコードを追加する
    // 二発投げているのは UDP のパケット漏れ回避のため
    // setTimeout(function() {
    //   browser.discovery(true);
    // }, 5000);
    // setTimeout(function() {
    //   browser.discovery(false)
    // }, 10000);
    // [2016-10-11 20:37:35+09:00] kan.k: 過去のMulticast scanの実績値
    // である、3秒間隔で3回を実装。
    sendMultipleDiscovery(true, 0, 3, 3000);
  }, 5000);
});

// Deneb (Bluetooth 経由) っぽいもの発見イベント
var createDataOfSomethingLikeDeneb = function (localIp) {
  return {
    localIp: localIp,
    remoteIp: '172.25.47.1',  // 固定
    remotePort: constants.DEVICE_HTTP_PORT,
    phyType: browser.PHY_TYPE_OTHER,
    autoGenerated: true  // IPv4/IPv6 アドレスが自動生成されたことを示すフラグ
  };
};

networkChecker.on('foundSomethingLikeDeneb', function (localIp) {
  browser.register(createDataOfSomethingLikeDeneb(localIp));
});

var discoveryTimerId_ = null;

/**
 * 複数回のdiscovery送信を行う。
 *
 * @param {number} initialDelay 最初のdiscovery送信のための待ち時間。
 *
 * @param {number} count discovery送信を行う総数。
 *
 * @param {number} interval 1回目のdiscovery以降のinterval
 *
 * @private
 */
function sendMultipleDiscovery(force, initialDelay, count, interval) {
  log_d('multiple called'); // , discoveryTimerId_);
  if ( discoveryTimerId_ ) {
    clearTimeout(discoveryTimerId_);
    discoveryTimerId_ = null;
  }
  discoveryTimerId_ = setTimeout(function() {
    // After second discovery this is not forced.
    sendMultipleDiscoveryRepeated_(force, count, interval);
  }, initialDelay);
}

/**
 * @private
 *
 * @note もしIntervalをDynamicに変更するのであればこの場所。
 */
function sendMultipleDiscoveryRepeated_(force, count, interval) {
  log_d('multiple repeated called'); // , discoveryTimerId_);
  browser.discovery(force);
  discoveryTimerId_ = null;
  if ( count > 1 ) {
    discoveryTimerId_ = setTimeout(function() {
      // After second discovery this is not forced.
      sendMultipleDiscoveryRepeated_(false, count - 1, interval);
    }, interval);
  }
}

/* ===== 起動時の enumerated を確認する */
//setTimeout(function () {
//  dptUsbInitiator.enumUsbEthernet(function (error, usbEtherArray) {
//    if (error) {
//      console.error(error);
//      return;
//    }
//    for(const item of usbEtherArray) {
//      if (item.ipV6 !== undefined) {
//        browser.addUsbLink(item.ipV6.address);
//      }
//    }
//  });
//}, 5000);


/** @discovery event catcher */
browser.on('found', function(data) {
  log_d('browser.on(found)');

  addDeviceToKnownDeviceDic(data);

  //スコープ間ラベル付け替え
  if (data['phyType'] === browser.PHY_TYPE_USB) {
    data['phyType'] = discovery.PHY_TYPE_USB;
  }
  else {
    data['phyType'] = discovery.PHY_TYPE_OTHER;
  }

  /* -----  */
  // 既存リスト確認
  var matches = deviceCache.get("ip", data.remoteIp);

  // 1) まだリストに登録されていないIPなので、新規追加扱い
  if ( matches.length <= 0 ) {
    if ( ! deviceCache.add(data) ) {
      log_e('\n[ERROR] deviceCache.add() failed\n data: \n' +  data);
      emitter.emit('error', new Error('failed to add deviceCache'));
      return;
    }
    // 接続が新規に発見、追加されたため通知して終了
    emitter.emit("deviceAppear", data);
    return;
  }

  // この時点で matches は 1つの要素数なはず
  /* -----  */
  // IP は、同じでも、DeviceIdが変わっている場合は、違うデバイスとして認識させたい。
  let samedeviceid = false
  for(const match of matches) {
    if ( match.deviceId === data.deviceId ) {
      samedeviceid = true;
    }
  }

  if (samedeviceid === true) {
    // 2) 既存のエントリと、IPも、deviceIdも同じ → 増えても減ってもいない、一応データ上書き更新
    if ( ! deviceCache.update(data.remoteIp, data) ) {
      log_e('\n[ERROR] deviceCache.update() failed\n data: \n' +  data);
      emitter.emit('error', new Error('failed to update deviceCache'));
    }
  }
  else {
    // 3) 既存のエントリとIPは同じだが、deviceIdは異なっていた → 旧デバイスはremoveされて、その後新しくadd扱い
    if ( ! deviceCache.remove("ip", data.remoteIp) ) {
      log_e('\n[ERROR] deviceCache.remove() failed\n data: \n' +  data);
      emitter.emit('error', new Error('failed to remove deviceCache'));
    }
  
    emitter.emit("deviceDisappear", data);

    if ( ! deviceCache.add(data) ) {
      log_e('\n[ERROR] deviceCache.add() failed\n data: \n' +  data);
      emitter.emit('error', new Error('failed to add deviceCache'));
      return
    }

    emitter.emit("deviceAppear", data);
  }
  
  return;
});

/* ----------------------------- */
/* --- interface                 */
/* ----------------------------- */

/**
 * Gets the list of already scanned DPT devices.
 *
 * 現在スキャンできているデバイスのリストを取得する。
 * 
 * @return {Array.<{deviceId: string, name: string, phyType: PhyType,
 *   remoteIp: string, remotePort: number, localIp: string, info:
 *   Object}>} The list of scanned devices. When remoteIp is IPv6 Link
 *   Local address, scope Id also be set. The type of return value is
 *   `Array.<{deviceId: string, name: string, phyType: PhyType,
 *   remoteIp: string, remotePort: number, localIp: string, info:
 *   Object}>`.
 *   <br>
 *   スキャンされているデバイスのリストを返す。remoteIpが、IPv6 Link
 *   Local Addressである場合には、スコープID付きのIPが返される。戻り値
 *   のTypeは、`Array.<{deviceId: string, name: string, phyType:
 *   PhyType, remoteIp: string, remotePort: number, localIp: string,
 *   info: Object}>`。 `deviceId`は、デバイスユニークなID。`name` は、
 *   デバイスのホスト名。`phyType`は、物理的な接続方式で、
 *   discovery.PHY_TYPE_USB か、discovery.PHY_TYPE_OTHER を返す。`info
 *   は、当該デバイスに対して、GET /register/informationを呼び出した際
 *   の戻り値のJSONをそのまま保持しているものとする。GET
 *   /register/informationで情報が取得できなかった場合には、`info`の値は`null`とする。
 *   - 例: `{ deviceId: "9999999", name: "MyDevice", phyType: 'USB',
 *     remoteIp: '192.168.128.111', remotePort: '5000', info: {
 *     sku_code: "JP", device_color: "#000000" } }`
 *   - 例: `{ deviceId: "8888888", name: "Someones Device", phyType: 'USB',
 *     remoteIp: '192.168.128.112', remotePort: '5000', info: null }`
 */
discovery.getDeviceList = function() {
  if ( closing_ ) {
    throw new Error('close is already called');
  }
  return deviceCache.get('all');
}

/**
 * Invoke active scanning process if available.
 * <br>
 * 可能な場合、アクティブスキャンをトリガする。
 *
 * @param {function(?Error)} callback The callback to be called when
 *   active scan done.
 *   <br>
 *   アクティブスキャンが完了したことを、受け取るCallback。
 */
discovery.scanDevices = function(callback) {
  log_d('discovery.scanDevices()');

  if ( closing_ ) {
    throw new Error('close is already called');
  }
  browser.discovery(true, 3000, callback);  // スキャンタイムは検討
};

discovery.scanDevicesEx = function () {
  try {
    discovery.scanDevices(function () {});
  } catch (e) {
    log_e(e);
  }
};


/**
 * Check connectivity between device.  When the app could not connect
 * to the device, this device entry will also removed from the list of
 * getDeviceList.
 * <br>
 * 指定したデバイスとの接続を能動的にチェックする。チェックした結果、
 * 対象デバイスと接続可能でない事が分かった場合には、getDeviceListで取
 * 得できる一覧からも当該デバイスも消える。
 *
 * @param {string} deviceId The deviceId of the device to be checked.
 *   <br>
 *   チェックするデバイスのdeviceId を指定する。
 *
 * @param {function(?Error)} callback The callback to be called when
 *   check process done. When the device looks not connectable, a
 *   Error object will be passed to first argument to callback.
 *   <br>  
 *   チェック処理が完了したことを返すCallback。デバイスが接続できない
 *   事が分かった場合には、Errorオブジェクトが第一引数に返る。
 */
discovery.checkConnection = function(deviceId, callback) {
  if ( closing_ ) {
    throw new Error('close is already called');
  }
  
  //指定 deviceid のアイテムを探す
  let items = deviceCache.get('id', deviceId);
  //リストに無かったら終了
  if (items.length == 0) {
    callback(new Error('has gone.'));
    return;
  }
  //APIを投げて存在確認
  let ping_check = true;
  for(const device of items) {
    deviceChecker.ping(device.remoteIp, device.remotePort, function(addr, apiversion) {
      // [2016-07-29 00:12:25+09:00] kan.k: [TODO] レアケースですが、
      // portfwdrのエラーが握りつぶされています。nodeのcallbackマナー
      // に従って、第一引数を、errとするべきと思います。そしてエラーの
      // 時には、 `emitter.emit('error', error);` で返すという形にして
      // いただきたいです。
      
       //未達だったら削除
      if (apiversion === null) {
        ping_check = false;
        deviceCache.remove('ip', addr);
      }
    });
  }
  //削除を伴っていたらErrorをcallbackする
  if (ping_check === false) {
    callback(new Error('device has disconnected'));
  }
  else {
    callback(null);
  }
}

/**
 * Adds a event listener function.
 * <br>
 * Eventのリスナーを追加する。
 *
 * @param {string} eventName The name of event.
 *   <br>
 *   イベント名。
 *
 * @param {function(arg)} listener The listener function to register.
 *   <br>
 *   登録する、リスナー関数。
 */
discovery.on = function(eventName, listener) {
  return emitter.on(eventName, listener);
};

/**
 * Adds a one time event listener function.
 * <br>
 * 一度だけ呼び出されるEventのリスナーを追加する。
 *
 * @param {string} eventName The name of event.
 *   <br>
 *   イベント名。
 *
 * @param {function(arg)} listener The listener function to register.
 *   <br>
 *   登録する、リスナー関数。
 */
discovery.once = function(eventName, listener) {
  return emitter.once(eventName, listener);
};

/**
 * Removes the specified event listener.
 * <br>
 * 指定したEventのリスナーを削除する。
 *
 * @param {string} eventName The name of event.
 *   <br>
 *   イベント名。
 *
 * @param {function(arg)} listener The listener function to remove.
 *   <br>
 *   登録解除する、リスナー関数。
 */
discovery.removeListener = function(eventName, listener) {
  return emitter.removeListener(eventName, listener);
};

/**
 * Release system resource required for this module.  After this call
 * is called any function can not be called until process
 * shutdown. Call this function before shutdown.
 * <br>
 * このモジュールに必要なシステムリソースを解放する。この呼び出しの実
 * 行後はいずれの関数呼び出しもできない。終了前に呼び出す必要がある。
 *
 * @param {function(?Error)} callback The callback to be called when
 *   closing is done.
 *   <br>
 *   閉じる処理が完了したことを受け取るCallback。
 */
discovery.close = function(callback) {
  if ( closing_ ) {
    throw new Error('close is already called');
  }
  closing_ = true;
  dptUsbInitiator.stop(callback);
}

/**
 * デバイスリストのリフレッシュを行います。
 */
discovery.refresh = function () {
  log_d('discovery.refresh()');

  if (autoBtPanConnector) {
    log_d('autoBtPanConnector exists.');

    autoBtPanConnector.bruteForceDisconnectFromAllDenebs(function () {
      networkChecker.changed();
    });
  } else {
    log_d('autoBtPanConnector does not exist.');

    networkChecker.changed();
  }
};

/**
 * Recover lost connection
 */
var recoverLostConnection = function (doneCallback) {
  log_d('recoverLostConnection()');

  var delay = 1000 * 3;
  var oldDeviceList = deviceCache.get('all');
  
  deviceCache.clear();

  for (var device of oldDeviceList) {
    emitter.emit('deviceDisappear', device);
  }

  for (var i = 0; i < 3; ++i) {
    setTimeout(function () {
      discovery.scanDevicesEx();
    }, delay);

    delay += 1000 * 3;
  }

  for (var device of oldDeviceList) {
    setTimeout(function () {
        browser.register(device);
    }, delay);

    delay += 1000 * 3;
  }

  delay += 1000 * 15;

  setTimeout(function () {
    var nicList = OS.networkInterfaces();
    for (var nicName in nicList)  {
      var nic = nicList[nicName];
      for (var item of nic) {
        if ((item) && (item.address) && (item.address.indexOf('172.25.47.') === 0)) {
          browser.register(createDataOfSomethingLikeDeneb(item.address));
        }
      }
    }
  }, delay);

  delay += 1000 * 10;

  setTimeout(function () {
    doneCallback();
  }, delay);
};

discovery.requestRecoverLostConnection = function () {
  taskRunner.pushFront(recoverLostConnection);
};

discovery.cancelRecoverLostConnection = function () {
  taskRunner.remove(function (task) {
    return (task === recoverLostConnection);
  });
};

/**
 * デバイスへの接続性チェックを行います。
 */
var checkConnectivity = function (doneCallback) {
  log_d('checkConnectivity()');

  const WATCH_INTERVAL = 1000 * 10;
  const MAX_WATCH_COUNT = 11;
  const DONE_DELAY = 1000 * 10;

  var cachedDeviceList = deviceCache.get('all');
  var checkedDeviceCount = 0;
  var removedDeviceCount = 0;

  log_d('[CONCHECK] Start.');

  var check = function (device) {
    deviceChecker.ping(device.remoteIp, device.remotePort, function (address, apiVersion) {
      if (!apiVersion) {
        deviceCache.remove('ip', address);
        ++removedDeviceCount;

        emitter.emit('deviceDisappear', device);
        log_d('[CONCHECK] %s (%s) does not exist.', device.deviceId, device.remoteIp.toString());
      } else {
        log_d('[CONCHECK] %s (%s) exists.', device.deviceId, device.remoteIp.toString());
      }

      ++checkedDeviceCount;
    });
  };

  for (const device of cachedDeviceList) {
    check(device);
  }

  var watch = function (n) {
    var finished = (checkedDeviceCount === cachedDeviceList.length) || (n >= MAX_WATCH_COUNT);
    if (finished) {
      if ((checkedDeviceCount !== cachedDeviceList.length) || (removedDeviceCount > 0)) {
        discovery.scanDevicesEx();
        log_d('[CONCHECK] Scan devices.');
      }

      setTimeout(function () {
        log_d('[CONCHECK] End.');
        doneCallback();
      }, DONE_DELAY);
    } else {
      setTimeout(function () {
        watch(n + 1);
      }, WATCH_INTERVAL);
    }
  };

  watch(1);
};

discovery.requestCheckConnectivity = function () {
  taskRunner.pushBack(checkConnectivity);
};

/**
 * 定期的な「デバイスへの接続性チェック」の間隔を設定します。
 */
var periodicConnectivityCheckIntervalId = undefined;

discovery.setPeriodicConnectivityCheckInterval = function (intervalMinutes) {
  log_d('discovery.setPeriodicConnectivityCheckInterval()');

  clearInterval(periodicConnectivityCheckIntervalId);
  periodicConnectivityCheckIntervalId = undefined;

  var m = parseInt(intervalMinutes);
  if (!isNaN(m) && (m > 0)) {
    log_d('[CONCHECK] Checks every %s minutes.', m.toString());
    periodicConnectivityCheckIntervalId = setInterval(function () {
      discovery.requestCheckConnectivity();
    }, 1000 * 60 * m);
  }
};

if (process.env.MW_DEVICE_CHECK_INTERVAL) {
  discovery.setPeriodicConnectivityCheckInterval(process.env.MW_DEVICE_CHECK_INTERVAL);
} else {
  discovery.setPeriodicConnectivityCheckInterval(5);  // 環境変数 MW_DEVICE_CHECK_INTERVAL が設定されていない場合は 5 分間隔となります。
}


/****************************************
 * Ping でのこまめなデバイス存在確認処理
 ****************************************/
const PING_AND_REGISTER_INTERVAL_MILLISECONDS = 1000 * 5;
const PING_AND_REGISTER_MAX_CONTINUOUS_EXECUTION_MILLISECONDS = 1000 * 60 * 3;

var pingAndRegisterStartTime = undefined;
var pingAndRegisterIntevalId = undefined; 
var knownDeviceDic = {};
var masterPingNo = 0;

var addDeviceToKnownDeviceDic = function (device) {
  if (device) {
    if (knownDeviceDic.hasOwnProperty(device.remoteIp) === false) {
      knownDeviceDic[device.remoteIp] = {
          localIp: device.localIp,
          remoteIp: device.remoteIp,
          remotePort: device.remotePort,
          phyType: device.phyType
      };
    }
  }
};

var pingAndRegisterInternal = function (device, pingNo) {
  log_d('* [' + pingNo +'] Ping to ' + device.remoteIp + ' - Start');

  deviceChecker.ping(device.remoteIp, device.remotePort, function (address, apiVersion) {
    if (apiVersion !== null) {
      log_d('* [' + pingNo +'] Ping to ' + device.remoteIp + ' - OK');

      browser.register({
        localIp: device.localIp,
        remoteIp: device.remoteIp,
        remotePort: device.remotePort,
        phyType: device.phyType,
        autoGenerated: true
      });
    } else {
      log_d('* [' + pingNo +'] Ping to ' + device.remoteIp + ' - Failed');
    }
  });
};

var pingAndRegister = function () {
  var currentTime = new Date();
  var elapsedMilliseconds = currentTime - pingAndRegisterStartTime;
  if (elapsedMilliseconds <= PING_AND_REGISTER_MAX_CONTINUOUS_EXECUTION_MILLISECONDS) {
    for (var key in knownDeviceDic) {
      pingAndRegisterInternal(knownDeviceDic[key], masterPingNo++);
    }
  } else {
    discovery.stopPingAndRegister();
  }
};

discovery.startPingAndRegister = function () {
  log_d('startPingAndRegister()');

  if (pingAndRegisterIntevalId === undefined) {
    pingAndRegisterStartTime = new Date();
    pingAndRegisterIntevalId = setInterval(pingAndRegister, PING_AND_REGISTER_INTERVAL_MILLISECONDS);
  }
};

discovery.stopPingAndRegister = function () {
  log_d('stopPingAndRegister()');

  if (pingAndRegisterIntevalId !== undefined) {
    clearInterval(pingAndRegisterIntevalId);
    pingAndRegisterIntevalId = undefined;
  }
};




/* ----------------------------- */
/* --- events                    */
/* ----------------------------- */

/**
 * Indicates a device found.  The object with deviceId will be passed.
 * The event will be passed per each connection. So, when the device
 * detected more than one connection. This event will emitted per
 * connection separatedly.
 * <br>
 * デバイスが、新しく検出されたことを示す。deviceId付きのオブジェクト
 * が渡される。このイベントは接続毎に送信される。あるデバイスが、複数
 * の接続で検出されている場合、このイベントは接続毎に独立して送信される。
 *
 * @event deviceAppear
 * @type {{deviceId: string, name: string, phyType: enum, remoteIp:
 *   string, remotePort: number, localIp: string, info: Object}}
 */

/**
 * Indicates the device disappear is detected. The object with
 * deviceId will be passed. The event will be passed per each
 * connection. So, when the device detected more than one
 * connection. This event will emitted per connection separatedly.
 * <br>
 * デバイスが、見えなくなったことを検知した事を示すイベント。deviceId
 * 付きのオブジェクトが渡される。このイベントは接続毎に送信される。あ
 * るデバイスが、複数の接続で検出されている場合、このイベントは接続毎
 * に独立して送信される。
 *
 * @event deviceDisappear
 * @type {{deviceId: string, name: string, phyType: enum, remoteIp:
 *   string, remotePort: number, localIp: string, info: Object}}
 */

/**
 * Indicates Deneb direct USB serial is detected. The deviceId will be
 * passed. This event is prepared only for showing progress of USB
 * initialization.
 * <br>
 * Deneb直結USBシリアルが検出されたことをを示す。deviceId が渡される。
 * USBの接続処理の進捗を表示する目的のためだけに用意されたイベント。
 *
 * @note 状態経過表示以外の目的で、このイベントを利用するべきではない。
 *
 * @event usbSerialConnected
 * @type {string}
 */

/**
 * Indicates Deneb direct USB serial is disconnected. The deviceId
 * will be passed. This event is prepared only for showing progress of USB
 * initialization.
 * <br>
 * Deneb直結USBシリアルの切断が検出されたことを示す。deviceId が渡される。
 * USBの接続処理の進捗を表示する目的のためだけに用意されたイベント。
 *
 * @note 状態経過表示以外の目的で、このイベントを利用するべきではない。
 *
 * @event usbSerialDisconnected
 * @type {string}
 */

/**
 * Indicates Deneb direct USB ether is detected. The deviceId will be
 * passed. This event is prepared only for showing progress of USB
 * initialization.
 * <br>
 * Deneb直結USB Etherが検出されたことをを示す。deviceId が渡される。
 * USBの接続処理の進捗を表示する目的のためだけに用意されたイベント。
 *
 * @note 状態経過表示以外の目的で、このイベントを利用するべきではない。
 *
 * @event usbEtherConnected
 * @type {string}
 */

/**
 * Indicates Deneb direct USB ether is disconnected. The deviceId
 * will be passed. This event is prepared only for showing progress of USB
 * initialization.
 * <br>
 * Deneb直結USB Etherの切断が検出されたことを示す。deviceId が渡される。
 * USBの接続処理の進捗を表示する目的のためだけに用意されたイベント。
 *
 * @note 状態経過表示以外の目的で、このイベントを利用するべきではない。
 *
 * @event usbEtherDisconnected
 * @type {string}
 */

/**
 * Indicates any error occured in or under discovery control.
 * <br>
 * いずれかのエラーがDiscovery Controlか、それより下で発生したことを通
 * 知する。
 *
 * @event error
 * @type {Error}
 */
