/*
  DiscoveryProxy.js

  description:
  Device Discovery proxy factrory.
*/
'use strict';

const log_e = require('debug')('mw-discovery-ctrl:proxy:error');
const log_d = require('debug')('mw-discovery-ctrl:proxy:debug');

const EventEmitter = require('events').EventEmitter;
const emitter = new EventEmitter();

const checker = require('./checker');
const Util = require('./util');
const Constants = require('./constants');

const mwe = require('mw-error');

const os = require('os');

/** @exports discovery-proxy */
const DiscoveryProxy = exports;

DiscoveryProxy.PHY_TYPE_USB = 'USB';
DiscoveryProxy.PHY_TYPE_OTHER = 'OTHER';

//
DiscoveryProxy.isWindows = (process.platform === 'win32');
//
DiscoveryProxy.browser = null;
//
DiscoveryProxy.usbif = [];
//
// USB接続デバイスの追加
DiscoveryProxy.addUsbLink = function (address) {
  log_d('DiscoveryProxy.addUsbLink()');
  DiscoveryProxy.usbif.push(address);
  // mdns-js のときはブラウザ作り直し
  if (DiscoveryProxy.isWindows) {
    DiscoveryProxy.stop();
    DiscoveryProxy.browserStartWindows();
  }
};

// USB接続デバイスの削除
DiscoveryProxy.removeUsbLink = function (address) {
  log_d('DiscoveryProxy.removeUsbLink()');
  for (let index = 0; index < this.usbif.length; index++) {
    if (this.usbif[index] === address) {
      this.usbif.splice(index, 1);
      // mdns-js のときはブラウザ作り直し
      if (DiscoveryProxy.isWindows) {
        DiscoveryProxy.stop();
        DiscoveryProxy.browserStartWindows();
      }
      break;
    }
  }
};

// ディスカバリ開始 Windows
DiscoveryProxy.browserStartWindows = function () {
  log_d('DiscoveryProxy.browserStartWindows()');
  var mdns = require('mdns-js-mw');
  if ( DiscoveryProxy.broser ) {
    log_e('This may be wrong call. Browser looks already initialized.', new Error('looks wrong'));
    // console.warn('This may be wrong call. Browser looks already initialized: ', new Error('Looks wrong'));
  }
  
  DiscoveryProxy.browser = mdns.createBrowser(mdns.tcp("digitalpaper"));
  DiscoveryProxy.browser.on('update', function (node) {
    log_d('DiscoveryProxy.browser.on(updated): ', node);
    // 必要なデータを抜き出して共通フォーマットに整形
    for (const addr of node.addresses) {
      var scopeId = '';
      var checkAddress = node.interfaceAddress;
      if (node.interfaceAddress.indexOf('%') >= 0) {
        scopeId = node.interfaceAddress.slice(node.interfaceAddress.indexOf('%'));
        checkAddress = node.interfaceAddress.slice(0, node.interfaceAddress.indexOf('%'));
      }

      //fullnameを持たない相手は今回ターゲットとしていない
      if (node.fullname === undefined) {
        log_d('node.fullname === undefined : ', node);
        continue;
      }
      //digitalpaper でなかったら無視
      if (node.fullname.indexOf('digitalpaper') === -1) {
        log_d('node.fullname != digitalpaper : ', node);
        continue;
      }

      var data = {};
      data['remoteIp'] = addr + scopeId;
      data['remotePort'] = node.port;
      data['deviceId'] = '';
      data['phyType'] = DiscoveryProxy.PHY_TYPE_OTHER;
      data['localIp'] = node.interfaceAddress;
      data['name'] = '';
      if (node.fullname !== undefined) {
        var ppos = node.fullname.indexOf('.');
        if (ppos >= 0) {
          data['name'] = node.fullname.substr(0, ppos);
        }
      }

      // physical check
      for (const usblink of DiscoveryProxy.usbif) {
        if (checkAddress === usblink) {
          data['phyType'] = DiscoveryProxy.PHY_TYPE_USB;
        }
      }

      // 共通登録処理
      DiscoveryProxy.register(data);
    }
    //
  });
  DiscoveryProxy.browser.start();
}

// ディスカバリ開始 Other(bonjour)
DiscoveryProxy.browserStartDarwin = function () {
  var mdns = require('mdns');
  if ( DiscoveryProxy.broser ) {
    log_e('This may be wrong call. Browser looks already initialized.', new Error('looks wrong'));
    // console.warn('This may be wrong call. Browser looks already initialized: ', new Error('Looks wrong'));
  }
  DiscoveryProxy.browser = mdns.createBrowser(mdns.tcp("digitalpaper"));
  DiscoveryProxy.browser.on('serviceUp', function (node) {
    // 必要なデータを抜き出して共通フォーマットに整形
    for (const addr of node.addresses) {
      //fullnameを持たない相手は今回ターゲットとしていない
      if (node.fullname === undefined) {
        log_e('node.fullname === undefined : ', node);
        continue;
      }
      //digitalpaper でなかったら無視
      if (node.fullname.indexOf('digitalpaper') === -1) {
        log_e('node.fullname != digitalpaper : ', node);
        continue;
      }

      var data = {};
      if (DiscoveryProxy.isIPv6(addr)) {
        data['remoteIp'] = addr + '%' + node.networkInterface;
      }
      else {
        data['remoteIp'] = addr;
      }
      data['deviceId'] = '';
      data['phyType'] = DiscoveryProxy.PHY_TYPE_OTHER;
      data['remotePort'] = node.port;
      data['localIp'] = '';
      data['name'] = '';
      if (node.fullname !== undefined) {
        var ppos = node.fullname.indexOf('.');
        if (ppos >= 0) {
          data['name'] = node.fullname.substr(0, ppos);
        }
      }
      // physical check
      const ifaddr = DiscoveryProxy.getInterfaceAddress(node.networkInterface);
      for (const usblink of DiscoveryProxy.usbif) {
        for (const chkaddr of ifaddr) {
          if (chkaddr === usblink) {
            data['phyType'] = DiscoveryProxy.PHY_TYPE_USB;
          }
        }
      }
      // local IP address
      if (DiscoveryProxy.isIPv6(data['remoteIp'])) {
        // IPv6
        for (const chkaddr of ifaddr) {
          if (DiscoveryProxy.isIPv6(chkaddr)) {
            data['localIp'] = chkaddr;
            break;
          }
        }
      }
      else {
        // IPv4
        for (const chkaddr of ifaddr) {
          if (DiscoveryProxy.isIPv6(chkaddr) === false) {
            data['localIp'] = chkaddr;
            break;
          }
        }
      }
      // 共通登録処理
      DiscoveryProxy.register(data);
    }
  });
  // mDNS モジュール内部のエラーをキャッチする
  DiscoveryProxy.browser.on('error', function (ecode) {
    log_e('mDNS error message : ', ecode);
  });

  // ブラウザスタート
  DiscoveryProxy.browser.start();
  //DiscoveryProxy.browser.on('serviceDown', function(node) {
  //});
}

/**
 * Active discovery trigger
 * <br>
 * デバイスのアクティブ探索リクエスト
 *
 * @param {boolean} force A flag to reload module when required. 
 *   <br>
 *   必要な場合にモジュールのリロードまで行う場合のフラグ
 *
 * @param {value} interval (msec)
 *   <br>
 *   探索開始からコールバックするまでの時間
 *
 * @param {function(?Error)} callback The callback to be called when passed time count interval
 *   <br>
 *   探索開始から一定時間が経過したら呼ばれるコールバック
 *
 */
DiscoveryProxy.discovery = function (force, interval, callback) {
  // アクティブディスカバリー開始
  if ( typeof force != 'boolean' ) {
    // console.error('input is wrong', new Error('input is wrong'));
    log_e('This is wrong call.', new Error('wrong call'));
    if ( typeof callback === 'function' ) {
      callback(mwe.genError(mwe.E_MW_FATAL_ERROR, 'This is wrong call.'));
    }
    return;
  }
  if (DiscoveryProxy.isWindows) {
    if ( ! DiscoveryProxy.browser ) {
      // console.error('This is wrong call. Browser is not initialized.', new Error('wrong call'));
      log_e('This is wrong call.', new Error('wrong call'));
      if ( typeof callback === 'function' ) {
        callback(mwe.genError(mwe.E_MW_FATAL_ERROR, 'This is wrong call.'));
      }
      return;
    }
    DiscoveryProxy.browser.discover();
  }
  else {
    // [2016-10-24 13:46:05+09:00] kan.k: 明確にDarwinチェックを入れる
    // べきかも知れないが、現時点で追加ロジックを入れるべきではないと
    // 判断して入れていない。次回整理の際には対応のこと。
    if ( force ) {
      if ( ! DiscoveryProxy.browser ) {
        // console.error('This is wrong call. Browser is not initialized.', new Error('input is wrong'));
        log_e('This is wrong call.', new Error('wrong call'));
        if ( typeof callback === 'function' ) {
          callback(mwe.genError(mwe.E_MW_FATAL_ERROR, 'This is wrong call.'));
        }
        return;
      }
      
      DiscoveryProxy.browser.stop();
      DiscoveryProxy.browser = null;
      // setTimeout(function () {
      //   DiscoveryProxy.browserStartDarwin();
      // }, 1000);
      DiscoveryProxy.browserStartDarwin();
      // [2016-10-24 13:43:15+09:00] kan.k: 次のintervalの実装は現時点
      // では利用されていないとのこと。
      if (interval !== null) {
        interval += 1001;
      }
    }
  }
  // 終了時にコールバックを投げる
  if ((interval !== undefined) && (callback !== undefined)) {
    setTimeout(function () {
      callback(null);
    }, interval);
  }
};


/**
 * ディスカバリの終了
 */
DiscoveryProxy.stop = function () {
  if (this.isWindows) {
    if (DiscoveryProxy.browser !== null) {
      DiscoveryProxy.browser.stop();
      DiscoveryProxy.browser = null;
    }
  }
  else {
    if (DiscoveryProxy.browser !== null) {
      DiscoveryProxy.browser.stop();
      DiscoveryProxy.browser = null;
    }
  }
}

/**
 * デバイス発見時の共通登録イベント
 */
DiscoveryProxy.serviceFound = function (data) {
  emitter.emit('found', data);
};

/**
 * イベントリスナーの登録
 */
DiscoveryProxy.on = function (eventName, listener) {
  return emitter.on(eventName, listener);
};

/**
 * 一回のみイベントリスナーの登録
 */
DiscoveryProxy.once = function (eventName, listener) {
  return emitter.once(eventName, listener);
};

/**
 * イベントリスナーの解除
 */
DiscoveryProxy.removeListener = function (eventName, listener) {
  return emitter.removeListener(eventName, listener);
};



/* ------------------------------ */
/* --- local method               */
/* ------------------------------ */

/// ネットワークインタフェース名から持っているIPアドレスを調べる
DiscoveryProxy.getInterfaceAddress = function (ifname) {
  var address = [];
  var interfaces = os.networkInterfaces();

  for (let key in interfaces) {
    if (key !== ifname) {
      continue;
    }
    if ((interfaces.hasOwnProperty(key)) &&
      (key === ifname)) {
      for (var i = 0; i < interfaces[key].length; i++) {
        var iface = interfaces[key][i];
        //choice IPv6 link local
        if (iface.address.indexOf(':') !== -1) {
          if (iface.address.indexOf('fe80:') !== 0) {
            continue;
          }
          else {
            address.push(iface.address);
          }
        }
        //choice IPv4 link local
        else {
          address.push(iface.address);
        }
      }
    }
  }

  return address;
};


/// IPアドレスを示す文字列が IPv6 フォーマットであったら true を返す
DiscoveryProxy.isIPv6 = function (address) {
  if (address.indexOf(':') === -1) {
    return false;
  }
  return true
};



/// 発見したノードに必要な情報を追加して登録処理に渡す
DiscoveryProxy.register = function (data) {
  log_d('DiscoveryProxy.register(): ', data);

  // ローカルIPが空欄ならドロップ
  if (data['localIp'].length == 0) {
    log_e('localIp == empty : ', data);
    return;
  }

  // deviceID 取得
  log_d('data: ', data);

  const remoteIp = data['remoteIp'];
  const remotePort = data['remotePort'];
  const self = this

  // [2016-07-29 00:20:33+09:00] kan.k: [TODO] Altair側の意図として、
  // プロトコル上は/register/serialnumberの方を先に取得するようにして
  // いただきたいです。 /register/information は、その後でお願いします。
  // [2016-08-01 16:58:15+09:00] kan.k: 入れました
  // self.getdeviceinfo(remoteIp, remotePort)
  //   .then(
  //     function(info) {
  //       log_d("getdeviceinfo: resolved.");
  //       data['info'] = info;
  //       return self.getdeviceserial(remoteIp, remotePort);
  //     },
  //     function(error) {
  //       log_e("getdeviceinfo: defferd.", error);
  //       // 失敗時は情報が null になるけど継続
  //       data['info'] = null;
  //       return self.getdeviceserial(remoteIp, remotePort);
  //     }
  //   )
  //   .then(
  //     function(serialnum) {
  //       log_d("getdeviceserial: resolved.");
  //       data['deviceId'] = serialnum;
  //       // 発見イベント送信
  //       DiscoveryProxy.serviceFound(data);
  //     },
  //     function(error) {
  //         //失敗時は目的とするデバイスでなかったとして何もせず
  //         log_e("getdeviceserial: defferd.", error);
  //     }
  //   );
  self.getdeviceserial(remoteIp, remotePort)
    .then(
      function(serialnum) {
        log_d("getdeviceserial: resolved.");
        data['deviceId'] = serialnum;
        return self.getdeviceinfo(remoteIp, remotePort)
          .then(
            function(info) {

              // SKU コードを強制的に変更します。
              if (process.env.MW_SKU_CODE && info && info.sku_code) {
                info.sku_code = process.env.MW_SKU_CODE;
                console.log(info);
              }

              log_d("getdeviceinfo: resolved.");
              data['info'] = info;
              // 発見イベント送信
              DiscoveryProxy.serviceFound(data);
            },
            function(error) {
              log_e("getdeviceinfo: failed.", error);
              // 失敗時は情報が null になるけど発見イベント送信
              data['info'] = null;
              DiscoveryProxy.serviceFound(data);
            }
          );
      },
      function(error) {
        //失敗時は目的とするデバイスでなかったとして何もせず
        log_e("getdeviceserial: failed.", error);
        return Promise.reject(error);
      }
    );
  
  // [2016-08-01 16:59:31+09:00] kan.k: 元々の実装でも、上記の実装でも、
  // deviceId が取得できる前に、getDeviceListに登場する対応になってい
  // る。メモ
};

/**
 * Denebに接続されたUSB-Ethernetの情報から、DenebのIPV6アドレスを生成し、
 * 登録に必要なプロパティに埋め込んで返却する。
 * 
 * @param  {object} etherInfo             should have the following properties.
 * @param {object} ipV6 Usb               including ethernet interface informations
 * @param {string} etherInfo.ipV6.address the ipv6 address of the ethernet interface
 * @param {string} etherInfo.ipV6.scopeid like 21
 * @param {string} etherInfo.serialNumber the serialnumber of the connected device
 * 
 * @return {object} including properties for register arguments as follows, or null if not enough ethernet information.
 *  {string} localIp    the local link IpV6 address assigned to the PC
 *  {string} remoteIp   the local link IpV6 address assigned to the device
 *  {number} remoteport the local link port to access to the device
 *  {string} phytype    the fixed value as {@link DiscoveryProxy.PHY_TYPE_USB}
 *  {string} name       the device name
 *  {string} deviceId   the device id
 * 
 * @see for more information, see {@link DiscoveryProxy.register}
 * @todo etherInfo.ipV6 に netmask as string, scopeid as number も必須か？←生成ロジック次第
 */
DiscoveryProxy.getRegisterDataFromUsbEther = function(etherInfo) {
  // 生成情報が足りなければnullを返す
  if (
    typeof etherInfo !== 'object' ||
    typeof etherInfo.ipV6 !== 'object' ||
    typeof etherInfo.ipV6.address !== 'string' ||
    typeof etherInfo.serialNumber !== 'string'
  ) {
    return null;
  }

  // 特定のロジックでDenebデバイスのIPV6アドレス、ポート番号などを生成する -> lib/util
  var deviceAddr = Util.Ipv6Generator.createFromSerialNumber(etherInfo.serialNumber);

  // 何らかの理由で生成できなかった場合はNULL
  if (!deviceAddr) {
    return null;
  }

  if (process.platform === 'win32') {
    var localLinkScopeId = etherInfo.ipV6.scopeid ? `%${etherInfo.ipV6.scopeid}` : "";
    return {
      localIp: etherInfo.ipV6.address + localLinkScopeId,
      remoteIp: deviceAddr + localLinkScopeId,
      remotePort: Constants.DEVICE_HTTP_PORT,
      phyType: DiscoveryProxy.PHY_TYPE_USB,
      autoGenerated: true  // IPv6 アドレスが自動生成されたことを示すフラグ
    };
  } else if (process.platform === 'darwin') {
    var adapterName = etherInfo.adapterName ? `%${etherInfo.adapterName}` : "";
    return {
      localIp: etherInfo.ipV6.address + adapterName,
      remoteIp: deviceAddr + adapterName,
      remotePort: Constants.DEVICE_HTTP_PORT,
      phyType: DiscoveryProxy.PHY_TYPE_USB,
      autoGenerated: true  // IPv6 アドレスが自動生成されたことを示すフラグ
    };
  }

  return null;
};


// デバイスの serial_number を取得する
// return: Promise object
DiscoveryProxy.getdeviceserial = function (remoteip, remoteport) {
  return new Promise(function(resolve, reject) {
    checker.deviceid(remoteip, remoteport, function (address, value) {
      // [2016-07-29 00:12:25+09:00] kan.k: [TODO] レアケースですが、
      // portfwdrのエラーが握りつぶされています。nodeのcallbackマナー
      // に従って、第一引数を、errとするべきと思います。それで、この場
      // 合には、reject(err)とするべきでしょうか。
      if ((value !== null) && (value.length > 0) && (address === remoteip)) {
        // 受け取った
        resolve(value);
      }
      else {
        reject('fail: serialnumber');
      }
    });
  });
}

// デバイスの個体情報を取得する
// return: Promise object
DiscoveryProxy.getdeviceinfo = function (remoteip, remoteport) {
  return new Promise(function(resolve, reject) {
    checker.deviceinfo(remoteip, remoteport, function (address, value) {
      // [2016-07-29 00:12:25+09:00] kan.k: [TODO] レアケースですが、
      // portfwdrのエラーが握りつぶされています。nodeのcallbackマナー
      // に従って、第一引数を、errとするべきと思います。それで、この場
      // 合には、reject(err)とするべきでしょうか。
      if ((value !== null) && (address === remoteip)) {
        // 受け取った
        resolve(value);
      }
      else {
        reject('fail: deviceinfo');
      }
    });
  });
}






DiscoveryProxy.browserStart = function () {
  /* ------------------------------ */
  /* --- ディスカバリー開始　　　       */
  /* ------------------------------ */
  if (this.isWindows) {
    DiscoveryProxy.browserStartWindows();
  }
  else {
    DiscoveryProxy.browserStartDarwin();
  }
}


