"use strict";

const expect = require('chai').expect;
const sinon = require('sinon');
const DptUsbInitiator = require('mw-usb-initiator');
const DiscoveryProxy = require('../lib/discovery_proxy');
const NetworkChecker = require('../lib/nicwatcher');

/**
 * モジュール内取り込みでテスト対象に該当するものはすべてスタブにしておく
 */

describe('discoveryctrl', function() {

    var stubs = {};
    
    // before test started
    before(() => {
        // create stubs
        stubs = {
            DptUsbInitiator: {
                start: sinon.stub(DptUsbInitiator, "start"),
                on: sinon.spy(DptUsbInitiator, "on")
            },
            DiscoveryProxy: {
                browserStart: sinon.stub(DiscoveryProxy, "browserStart"),
                register: sinon.stub(DiscoveryProxy, "register"),
                addUsbLink: sinon.stub(DiscoveryProxy, "addUsbLink"),
                discovery: sinon.stub(DiscoveryProxy, "discovery"),
                getRegisterDataFromUsbEther: sinon.stub(DiscoveryProxy, "getRegisterDataFromUsbEther"),
            },
            NetworkChecker: {
                start: sinon.stub(NetworkChecker, "start"),
                stop: sinon.stub(NetworkChecker, "stop")
            }
        };

        this.DiscoveryCtrl =  require('../discoveryctrl');
        this.DiscoveryCtrl.stubs = {
            // sendMultipleDiscovery: sinon.stub(this.DiscoveryCtrl, "sendMultipleDiscovery"),//private関数なのでダメ
        };
    });

    // after all describe done
    after(() => {
        // restore all of spys
        for (var mod in stubs) {
            for (var func in stubs[mod]) {
                stubs[mod][func].restore();
            }
        }

        // restore sinon.stubs
        sinon.restore();
    });

    describe('dptUsbInitiator.start', () => {
        it('should be called once with callback function', () => {
            expect(stubs.DptUsbInitiator.start.calledWith(sinon.match.func)).to.be.true;
            expect(stubs.DptUsbInitiator.start.calledOnce).to.be.true;
        });

        it('should call proxy.browserStart and networkChecker.start if no error', () => {
            var error = null, usbSerialArray = [], usbEtherArray = [{}];

            // reset stubs
            stubs.DiscoveryProxy.browserStart.reset();
            stubs.NetworkChecker.start.reset();

            // stubs.DptUsbInitiator.start.callsArgWith(0, error, usbSerialArray, usbEtherArray);//呼ばれない・・・

            stubs.DptUsbInitiator.start.yield(error, usbSerialArray, usbEtherArray);
            expect(stubs.DiscoveryProxy.browserStart.calledOnce).to.be.true;
            expect(stubs.NetworkChecker.start.calledOnce).to.be.true;
        })

        it('should call discovery_proxy.register if the usbEtherArray exists', () => {
            var error = null, usbSerialArray = [], etherData = { ipV6: {address:"1.1.1.1"} }, usbEtherArray = [etherData];

            // getRegisterDataFromUsbEther に ↑のetherData が渡されたらobjectを返すようにStubを組み込む
            var returnObj = {test:1};
            stubs.DiscoveryProxy.getRegisterDataFromUsbEther.withArgs(etherData).returns(returnObj);
            
            // reset stubs
            stubs.DiscoveryProxy.getRegisterDataFromUsbEther.reset();
            stubs.DiscoveryProxy.register.reset();
            stubs.DiscoveryProxy.addUsbLink.reset();

            stubs.DptUsbInitiator.start.yield(error, usbSerialArray, usbEtherArray);
            expect(stubs.DiscoveryProxy.getRegisterDataFromUsbEther.calledWith(etherData)).to.be.true;
            expect(stubs.DiscoveryProxy.register.calledWith(returnObj)).to.be.true;
            expect(stubs.DiscoveryProxy.addUsbLink.calledWith(etherData.ipV6.address)).to.be.true;
        });
    });


    describe('dptUsbInitiator.on(add:ethernet)', () => {
        before(()=>{
            // on(add:ethernet) で setTimeout(5000) があるのでそのモックを使う。
            this.clock = sinon.useFakeTimers();

            // add:ethernet イベントハンドラで usbEtherConnected が発火されるのでそれを確かめるSpy
            this.OnUsbEtherConnectedSpy = sinon.spy();
            this.DiscoveryCtrl.on('usbEtherConnected', this.OnUsbEtherConnectedSpy);

            // reset stubs
            stubs.DiscoveryProxy.getRegisterDataFromUsbEther.reset();
            stubs.DiscoveryProxy.register.reset();
            stubs.DiscoveryProxy.addUsbLink.reset();
            stubs.NetworkChecker.start.reset();
            stubs.NetworkChecker.stop.reset();
            stubs.DiscoveryProxy.discovery.reset();
            this.OnUsbEtherConnectedSpy.reset();
        });

        after(()=>{
            // clock を戻す
            this.clock.restore();
        });

        // ethernet data
        var etherData = { ipV6: {} };

        it("should listen to 'add:ethernet' event", ()=> {
            expect(stubs.DptUsbInitiator.on.calledWith('add:ethernet', sinon.match.func)).to.be.true;
        });

        it('should discovery_proxy.register 5000ms later after add:ethernet', () => {
            // getRegisterDataFromUsbEther に ↑のetherData が渡されたらobjectを返すようにStubを組み込む
            var returnObj = {test:2};
            stubs.DiscoveryProxy.getRegisterDataFromUsbEther.withArgs(etherData).returns(returnObj);

            // fire 'add:ethernet' event
            DptUsbInitiator.emit('add:ethernet', etherData);

            // イベント発生時はまだ呼ばれていない
            expect(stubs.DiscoveryProxy.register.calledWith(returnObj), "register() not yet before 5000ms").to.be.false;

            // Discoveryもまだ呼ばれない
            expect(stubs.DiscoveryProxy.discovery.callCount, "discovery() not yet before 5000ms").to.eq(0);

            // 5秒後に発火
            this.clock.tick(5000)

            expect(stubs.DiscoveryProxy.getRegisterDataFromUsbEther.calledWith(etherData)).to.be.true;
            expect(stubs.DiscoveryProxy.register.calledWith(returnObj)).to.be.true;
            expect(stubs.NetworkChecker.stop.calledOnce).to.be.true;
            expect(stubs.NetworkChecker.start.calledOnce).to.be.true;
            expect(stubs.NetworkChecker.start.calledAfter(stubs.NetworkChecker.stop)).to.be.true;
        })

        it('should call discovery() after add:ethernet', ()=>{
            expect(stubs.DiscoveryProxy.discovery.callCount).to.eq(1);
        });

        it('should fire usbEtherConnected event', ()=>{
            expect(this.OnUsbEtherConnectedSpy.calledWith(etherData)).to.be.true;
        })
    });
});