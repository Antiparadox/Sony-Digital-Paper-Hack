"use strict";

const expect = require('chai').expect;
const Util = require('../lib/util');
const BigInt = require("big-integer");

describe('Util.BigNumber', function() {
    describe('#bigValue()', () => {
        it('should return the instance of big-integer having a big value larger than MAX_SAFE_INTEGER', () => {
            var val = Util.BigNumber.bigValue();
            expect(val).to.be.at.least(Number.MAX_SAFE_INTEGER);
        })
    });

    describe('#cut()', () => {
        it('should cut off digits over 64 bits', () => {
            var
            n2 = '1' + Array(65).join('0'),
            n = parseInt(n2,2),
            bigInt = Util.BigNumber.cut(n),
            val = parseInt(bigInt.toString());
            
            // console.log(Number(n).toString(2));
            // console.log(Number(val).toString(2));

            expect(n.toString(2)).to.match(/^10{64}$/);
            expect(val).to.equal(0);
        });
        it('should not cut off digits under 64 bits', () => {
            expect(Util.BigNumber.cut(Number.MAX_SAFE_INTEGER).toString())
            .to.eq(Number.MAX_SAFE_INTEGER.toString());
        });
    });

    describe('#plus', () => {
        it('should increase from 64bit+ and cut overflows within 64bits', () => {
            // そのままでは桁あふれの計算はできない。BitIntegerを通すと計算が可能。
            // 10...0 -> 加算で 10....1 -> 桁詰めで 0...1 になることの確認。（素のままではならないことを確認）
            var
            overBin = '1' + Array(65).join('0'),
            // 素のままで加算
            overN = parseInt(overBin, 2),
            overN_plus_1 = overN + 1,
            // BigInt で加算
            bigInt = new BigInt(overBin, 2),
            overBigInt_plus_1 = Util.BigNumber.plus(bigInt, 1);

            // 素のままでは加算されないことの確認
            expect(overN_plus_1, "N over 64 cannot be operated").to.eq(overN).not.eq(1);

            // BigIntで加算＆桁詰めされるのを確認
            expect(overBigInt_plus_1.toString(2)).to.eq(Number(1).toString(2));
        })
    });

    describe('#minus', () => {
        // plus と同様に。
        it('should decrease from 64bit+ and cut overflows within 64bits', ()=>{
            var
            overBin = Array(66).join('1'),
            // 素のままで加算
            overN = parseInt(overBin, 2),
            overN_minus_1 = overN -2,
            // BigInt で加算
            bigInt = new BigInt(overBin, 2),
            overBigInt_minus_1 = Util.BigNumber.minus(bigInt, 1);

            // 素のままでは減算されないことの確認
            expect(overN_minus_1, "N over 64 cannot be operated").eq(overN);

            // BigIntで減算＆桁詰めされるのを確認
            expect(overBigInt_minus_1).below(bigInt);
            expect(overBigInt_minus_1.toString(2)).not.to.eq(bigInt.toString(2));
            expect(overBigInt_minus_1.toString(2)).to.match(/^1+0$/);
        })
    });

    describe('#shiftLeft', () => {
        it('should shift to left and cut overflows within 64bits', ()=>{
            var src = new BigInt(Array(66).join('1'), 2);
            for (var i = 1; i < 64; ++i) {
                src = Util.BigNumber.shiftLeft(src, 1);
                expect(src.toString(2)).to.match(/0+$/);
                expect(src.toString(2).match(/0/g).length).to.eq(i);
            }
        });
    });

    describe('#shiftRight', () => {
        it('should shift to right and cut overflows within 64bits', ()=>{
            var src = new BigInt(Array(66).join('1'), 2);
            for (var i = 1; i < 65; ++i) {
                src = Util.BigNumber.shiftRight(src, 1);
                expect(src.toString(2)).to.match(/^1+$/);
                expect(src.toString(2).match(/1/g).length).to.eq(65-i);
            }
        });
    });
    
    describe('#createHash()', function() {
        it('should return the same value of hash_64 on linux', function() {
            var val = Util.BigNumber.createHash(844301009002026);
            expect(val).to.equal('85a668fcad11');
        });
        it('should return "" if an invalid number', () => {
            var f = Util.BigNumber.createHash;
            expect(f()).to.eq("");
            expect(f("a")).to.eq("");
            expect(f({})).to.eq("");
            expect(f([])).to.eq("");
            expect(f(NaN)).to.eq("");
            expect(f(Infinity)).to.eq("");
            expect(f(Number.NEGATIVE_INFINITY)).to.eq("");
            expect(f(Number.POSITIVE_INFINITY)).to.eq("");
        })
        it('should return "" if a float number', () => {
            expect(Util.BigNumber.createHash(1.1)).to.eq("");
        })
    });
});

/*

*/
describe('Util.Ipv6Generator', function() {
    describe('#createFromSerialNumber()', () => {
        var m = {
            "844301009002026": "fe80::84a6:68ff:fefc:ad11",
            "844300509002562": "fe80::b0e6:e0ff:fe32:1ae4",
            "844301009003027": "fe80::2c9e:68ff:fefc:9d6d",
            "844300509003521": "fe80::64ae:e0ff:fe32:0be8"
        };

        it('should return ipv6 address from a number', () => {
            for (var n in m) {
                var expected = m[n];
                var val = Util.Ipv6Generator.createFromSerialNumber(Number(n));
                expect(val).to.equal(expected);
            }
        });
        it('should execute even if string of number', () => {
            for (var n in m) {
                expect(n).to.be.a("string");
                var expected = m[n];
                var val = Util.Ipv6Generator.createFromSerialNumber(n);
                expect(val).to.equal(expected);
            }
        })
        it('should return "" if an invalid serialNumber', () => {
            var f = Util.Ipv6Generator.createFromSerialNumber;
            expect(f()).to.eq("");
            expect(f("a")).to.eq("");
            expect(f({})).to.eq("");
            expect(f([])).to.eq("");
            expect(f(NaN)).to.eq("");
            expect(f(Infinity)).to.eq("");
            expect(f(Number.NEGATIVE_INFINITY)).to.eq("");
            expect(f(Number.POSITIVE_INFINITY)).to.eq("");
            expect(f(1.1)).to.eq("");
        })
    });
});