/*
    auth-adpt.js
    
    created:    [2016-05-18 15:51:38+09:00]
    modified:   [2016-07-04 12:48:09+09:00]
    description:
    AuthAdopter JS
    
*/

const crypto = require('crypto');

/** @exports auth-adpt-mw */
const authadpt = exports;

const DHP2014 = ("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1" +
                 "29024E088A67CC74020BBEA63B139B22514A08798E3404DD" +
                 "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245" +
                 "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED" +
                 "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D" +
                 "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F" +
                 "83655D23DCA3AD961C62F356208552BB9ED529077096966D" +
                 "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B" +
                 "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9" +
                 "DE2BCBF6955817183995497CEA956AE515D2261898FA0510" +
                 "15728E5A8AACAA68FFFFFFFFFFFFFFFF");


/**
 * Calculate keys.
 *
 * @param {string} yb DH public key of opponent device.
 * @param {string} n1
 * @param {string} mac
 * @param {string} n2
 * @param {function(?Error, string, string, string)} callback A
 *   callback to receive DHYa, authKey and keyWrapKey.
 */
authadpt.generateKeys = function(yb, n1, mac, n2, callback) {
  var dh = crypto.createDiffieHellman(DHP2014, 'hex');
  dh.generateKeys();
  // // var ya = '\x00' + dh.getPublicKey('binary');
  // dh.setPrivateKey('f0thp5CROJvF2excmobSTJruG1eFyYjefiMWYrSklItgUbqAo1CFk6RI1knMewQUtDgKzR8CJAft/jDE+6izQI0sS1FDjCPG3JHbXBUiRnNhSKz2+Eh43vDGKju74b6IcfNiuQT5Sq1rthluMknmx6JwnED5JvhkOL3yS7ol0dscsfUQPcZjHLLr7CVjXGXerKF95vtjfDZzV69/LGYCZ3zxN6UsIpmLYOAec9Ls1G+OfcCut4u4mqmNZpjoBSD9AfIlnvhqjaOpcfkbL6IPdRSRxvjay0Mm4vh5Ok2A7AmupFXEXd7dA/W+3P0S0hmNVM90tNPUogSB7FpAgHeqiQ==', 'base64');
  // dh.setPublicKey('PBJRAH2FtRYwSkqlk8fMLJxBFmXnxSh8gnMeKe5OKvnHBTQIXnf0g/XzkDAqsgcnnUcY/OFSf49syyg02XBgX/ivcgWjFdD45h3FLKP0JqvV2Xsu3MQqDzX0PuRi4QDppS4W1sE3HhKSombROEvUzbDFdEEHyNNI9dK5CJdoi85/4rpHnl7DB0tl8rJ/wmWMsm+VtmXYycYzYQazbhUEGtXEUms+nXUTZ1hTtwUuwU0J0h8AixnDRYXogZLZfPM1/Uc9GovycdjpnB+kOVfrhJffn1oWiXjFvVcPFkEAveJyeDePOlKUdl5Z0pIbwxLxq07BxvYU94vFGOcS+X9yRQ==', 'base64');
  var ya = '\x00' + dh.getPublicKey('buffer').toString('binary');
  var zz = dh.computeSecret(yb, 'binary', 'binary');
  // console.log('zz: ', btoa(zz));
  
  // crypto.pbkdf2(zz, n1 + mac + n2, 10000, 384 / 8, 'sha256', function(err, derivedKey) {
  crypto.pbkdf2(
    Buffer.from(zz, 'binary'),
    Buffer.from(n1 + mac + n2, 'binary'), 10000, 384 / 8, 'sha256', function(err, derivedKey) {
      console.log('err: ', err);
      if ( err ) {
        callback(err);
        return;
      }
      // console.log('derivedKey: ', btoa(derivedKey));
      var authKey = derivedKey.slice(0, 256 / 8).toString('binary');
      var keyWrapKey = derivedKey.slice(256 / 8).toString('binary');
      callback(null, ya, authKey, keyWrapKey);
  });
};

/**
 * Wrap data with keys.
 *
 * @param {string} data
 * @param {string} authKey
 * @param {string} keyWrapKey
 * @return {string|null} Wrapped. When failed to wrap, `null` will be
 *   returned.
 */
authadpt.wrap = function(data, authKey, keyWrapKey) {
  if ( typeof data !== 'string' ) {
    throw new TypeError('data is not string');
  }
  if ( typeof authKey !== 'string' ) {
    throw new TypeError('authKey is not string');
  }
  if ( typeof keyWrapKey !== 'string' ) {
    throw new TypeError('keyWrapKey is not string');
  }
  // var hmac = crypto.createHmac('sha256', authKey);
  var hmac = crypto.createHmac('sha256', Buffer.from(authKey, 'binary'));
  // hmac.update(data, 'binary');
  hmac.update(Buffer.from(data, 'binary'));
  var kwa = hmac.digest('binary').slice(0, 64 / 8);
  var iv = this.generateNonce();
  // var cipher = crypto.createCipheriv('aes-128-cbc', keyWrapKey, iv);
  var cipher = crypto.createCipheriv(
    'aes-128-cbc', Buffer.from(keyWrapKey, 'binary'), Buffer.from(iv, 'binary'));
  // var wrapped = cipher.update(data + kwa, 'binary', 'binary');
  var wrapped = cipher.update(Buffer.from(data + kwa, 'binary')).toString('binary');
  // wrapped += cipher.final('binary');
  wrapped += cipher.final('buffer').toString('binary');
  wrapped += iv;
  return wrapped;
};

/**
 * Unwrap data with keys.
 *
 * @param {string} data
 * @param {string} authKey
 * @param {string} keyWrapKey
 * @return {string|null} Unwrapped. When failed to unwrap, `null` will
 *   be returned.
 */
authadpt.unwrap = function(data, authKey, keyWrapKey) {
  if ( typeof data !== 'string' ) {
    throw new TypeError('data is not string');
  }
  if ( typeof authKey !== 'string' ) {
    throw new TypeError('authKey is not string');
  }
  if ( typeof keyWrapKey !== 'string' ) {
    throw new TypeError('keyWrapKey is not string');
  }
  var iv = data.slice(data.length - (128 / 8));
  // var decipher = crypto.createDecipheriv('aes-128-cbc', keyWrapKey, iv);
  var decipher = crypto.createDecipheriv(
    'aes-128-cbc', Buffer.from(keyWrapKey, 'binary'), Buffer.from(iv, 'binary'));
  // var unwrapped = decipher.update(data.slice(0, data.length - (128 / 8)), 'binary', 'binary');
  var unwrapped = decipher.update(
    Buffer.from(data.slice(0, data.length - (128 / 8)), 'binary')).toString('binary');
  // unwrapped += decipher.final('binary');
  unwrapped += decipher.final().toString('binary');
  var kwa = unwrapped.slice(unwrapped.length - (64 / 8));
  unwrapped = unwrapped.slice(0, unwrapped.length - (64 / 8));
  // var hmac = crypto.createHmac('sha256', authKey);
  var hmac = crypto.createHmac('sha256', Buffer.from(authKey, 'binary'));
  // hmac.update(unwrapped, 'binary');
  hmac.update(Buffer.from(unwrapped, 'binary'));
  if ( kwa !== hmac.digest('binary').slice(0, 64 / 8) ) {
    console.error('kwa does not match');
    return null;
  }
  return unwrapped;
};

/**
 * Generate nonce.
 * @return {string} Nonce.
 */
authadpt.generateNonce = function() {
  var nonce = crypto.randomBytes(128 / 8).toString('binary');
  // var atob = require('atob');
  // var nonce = atob('G3/TBqzaWD9cZen8rqJngQ==');
  return nonce;
}

/**
 * Generate HMAC for data with authKey.
 *
 * @param {string} data
 * @param {string} authKey
 * @return {string|null} HMAC. When failed to generate HMAC `null`
 *   will be returned.
 */
authadpt.generateHmac = function(data, authKey) {
  if ( typeof data !== 'string' ) {
    throw new TypeError('data must be string');
  }
  if ( typeof authKey !== 'string' ) {
    throw new TypeError('data must be string');
  }
  // [2016-07-01 17:52:52+09:00] kan.k: createHmac used to accept
  // 'binary' type of input. But on node 6.1, they does not. On node
  // 6.1, they will return different values. This sympton is confirmed
  // for crypto.createHmac() and crypto.pbkdf2().

  // var hmac = crypto.createHmac('sha256', authKey);
  var hmac = crypto.createHmac('sha256', Buffer.from(authKey, 'binary'));
  // hmac.update(data, 'binary');
  hmac.update(Buffer.from(data, 'binary'));
  // hmac.write(data, 'ascii');
  return hmac.digest('binary');
}

/**
 * Sign nonce with key.
 *
 * @param {string} nonce
 * @param {string} key
 * @return {string|null} A signature. When failed to sign at runtime
 *   `null` will be returned.
 */
authadpt.signNonce = function(nonce, key) {
  if ( typeof nonce !== 'string' ) {
    throw new TypeError('nonce must be string');
  }
  if ( typeof key !== 'string' ) {
    throw new TypeError('key must be string');
  }
  
  var sign = crypto.createSign('RSA-SHA256');
  // sign.update(nonce);
  sign.update(Buffer.from(nonce, 'binary'));
  // var nonceSigned = sign.sign(key, 'binary');
  var nonceSigned = sign.sign(Buffer.from(key, 'binary'));
  return nonceSigned.toString('binary');
}
