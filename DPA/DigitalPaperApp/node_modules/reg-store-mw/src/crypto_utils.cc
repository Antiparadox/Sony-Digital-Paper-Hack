//
//  crypto_utils.cc
//
//  Copyright 2016 Sony Corporation
//

#include <nan.h>
#include <node.h>
#include <string>

#include "AddCertWorker.h"
#include "GenKeyPairWorker.h"


NAN_METHOD(addCert)
{
	Nan::HandleScope();

	// check the number of function arguments
	if (info.Length() != 2) {
		Nan::ThrowTypeError("Number of arguments must be 2.");
		return;
	}

	// check the types of function arguments
	if (!info[0]->IsString()) {
		Nan::ThrowTypeError("1st argument (szPemCert) must be String.");
		return;
	}
	if (!info[1]->IsFunction()) {
		Nan::ThrowTypeError("2nd argument (callback) must be Function.");
		return;
	}

	Nan::Utf8String* szPemCert = new Nan::Utf8String(info[0]);
	Nan::Callback* callback = new Nan::Callback(info[1].As<v8::Function>());

    // start a background task
    std::string strCert(**szPemCert);
	Nan::AsyncQueueWorker(new AddCertWorker(strCert, callback));
}

NAN_METHOD(genKeyPair)
{
	Nan::HandleScope();

	// check the number of function arguments
	if (info.Length() != 3) {
		Nan::ThrowTypeError("Number of arguments must be 3.");
		return;
	}

	// check the types of function arguments
	if (!info[0]->IsString()) {
		Nan::ThrowTypeError("1st argument (privKeyPath) must be String.");
		return;
	}
	if (!info[1]->IsString()) {
		Nan::ThrowTypeError("2nd argument (pubKeyPath) must be String.");
		return;
	}
	if (!info[2]->IsFunction()) {
		Nan::ThrowTypeError("3rd argument (callback) must be Function.");
		return;
	}

	Nan::Utf8String* szPrivKeyPath = new Nan::Utf8String(info[0]);
	Nan::Utf8String* szPubKeyPath = new Nan::Utf8String(info[1]);
	Nan::Callback* callback = new Nan::Callback(info[2].As<v8::Function>());

	// start a background task
    std::string strPrivKeyPath(**szPrivKeyPath);
    std::string strPubKeyPath(**szPubKeyPath);
	Nan::AsyncQueueWorker(new GenKeyPairWorker(strPrivKeyPath, strPubKeyPath, callback));
}

NAN_MODULE_INIT(init)
{
	NAN_EXPORT(target, addCert);
	NAN_EXPORT(target, genKeyPair);
}

NODE_MODULE(crypto_utils, init);
