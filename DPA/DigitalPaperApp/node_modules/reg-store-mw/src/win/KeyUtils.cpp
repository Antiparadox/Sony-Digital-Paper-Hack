#include "KeyUtils.h"
#include "WinErrorCode.h"
#include "AutoCriticalSection.h"
#include "StringUtils.h"
#include "../Log.h"
#include <memory>

#define KEY_CONTAINER		_T("node-crypto-utils-key-container")
#define KEY_SPEC			AT_KEYEXCHANGE
#define RSA2048BIT_KEY		0x08000000
#define PEM_PRIV_KEY_HEADER	"-----BEGIN RSA PRIVATE KEY-----\n"
#define PEM_PRIV_KEY_FOOTER	"-----END RSA PRIVATE KEY-----\n"
#define PEM_PUB_KEY_HEADER	"-----BEGIN PUBLIC KEY-----\n"
#define PEM_PUB_KEY_FOOTER	"-----END PUBLIC KEY-----\n"

static CriticalSection cs_sApi;


std::string KeyUtils::GenRsa2048KeyPair(
	/*[in]*/ const std::string& privateKeyPath,
	/*[in]*/ const std::string& publicKeyPath
	)
{
	AutoCriticalSection lock(&cs_sApi);

	std::string errMsg;

	HCRYPTPROV hProv = NULL;
	HCRYPTKEY  hKey = NULL;
	
	try {
		ULONG result = ERROR_SUCCESS;

		// Convert strings for file paths from UTF-8 to UTF-16
		std::wstring privateKeyPathW;
		result = StringUtils::Utf8ToUtf16(privateKeyPath, privateKeyPathW);
		if (result) {
			errMsg = WinErrorCode::ToString(result);
			LOG_ERROR(_T("StringUtils::Utf8ToUtf16() failed. [%S]"), errMsg.c_str());
			throw result;
		}

		std::wstring publicKeyPathW;
		result = StringUtils::Utf8ToUtf16(publicKeyPath, publicKeyPathW);
		if (result) {
			errMsg = WinErrorCode::ToString(result);
			LOG_ERROR(_T("StringUtils::Utf8ToUtf16() failed. [%S]"), errMsg.c_str());
			throw result;
		}

		// Acquires a handle to a key container
		if (!::CryptAcquireContext(&hProv, KEY_CONTAINER, NULL, PROV_RSA_FULL, 0)) {

			const ULONG errCode = ::GetLastError();
			if (errCode != NTE_BAD_KEYSET) {
				errMsg = WinErrorCode::ToString(errCode);
				LOG_ERROR(_T("CryptAcquireContext() failed. [%S]"), errMsg.c_str());
				throw errCode;
			}

			// Create a new key container
			if (!::CryptAcquireContext(&hProv, KEY_CONTAINER, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
				const ULONG errCode = ::GetLastError();
				errMsg = WinErrorCode::ToString(errCode);
				LOG_ERROR(_T("CryptAcquireContext(CRYPT_NEWKEYSET) failed. [%S]"), errMsg.c_str());
				throw errCode;
			}
		}

		// Gets a usr's two public/private key pairs
		if (!::CryptGetUserKey(hProv, KEY_SPEC, &hKey)) {

			const ULONG errCode = ::GetLastError();
			if (errCode != NTE_NO_KEY) {
				errMsg = WinErrorCode::ToString(errCode);
				LOG_ERROR(_T("CryptGetUserKey() failed. [%S]"), errMsg.c_str());
				throw errCode;
			}

			// Generates a public/private key pair
			if (!::CryptGenKey(hProv, CALG_RSA_KEYX, RSA2048BIT_KEY | CRYPT_EXPORTABLE, &hKey)) {
				const ULONG errCode = ::GetLastError();
				errMsg = WinErrorCode::ToString(errCode);
				LOG_ERROR(_T("CryptGenKey() failed. [%S]"), errMsg.c_str());
				throw errCode;
			}
		}

		// Exports a PEM formatted private key to the specified file path 
		errMsg = KeyUtils::ExportPrivateKey(hProv, privateKeyPathW, KEY_SPEC);
		if (!errMsg.empty()) {
			throw E_FAIL;
		}

		// Exports a PEM formatted public key to the specified file path 
		errMsg = KeyUtils::ExportPublicKey(hProv, publicKeyPathW, KEY_SPEC);
		if (!errMsg.empty()) {
			throw E_FAIL;
		}
	}
	catch (ULONG) {
		;
	}
	catch (...) {
		const ULONG errCode = ::GetLastError();
		errMsg = WinErrorCode::ToString(errCode);
		LOG_ERROR(_T("Unknown error occurred. [%S]"), errMsg.c_str());
	}

	if (hKey) {
		// Releases the handle referenced by the hKey
		if (!::CryptDestroyKey(hKey)) {
			const ULONG errCode = ::GetLastError();
			LOG_ERROR(_T("CryptDestroyKey() failed. [%S]"), WinErrorCode::ToString(errCode).c_str());
		}
		hKey = NULL;
	}

	if (hProv) {
		// Releases the handle of a cryptographic service provider (CSP) and a key container
		if (!::CryptReleaseContext(hProv, 0)) {
			const ULONG errCode = ::GetLastError();
			LOG_ERROR(_T("CryptReleaseContext() failed. [%S]"), WinErrorCode::ToString(errCode).c_str());
		}
		hProv = NULL;
	}

	// Deletes the key contatiner
	if (!::CryptAcquireContext(&hProv, KEY_CONTAINER, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET)) {
		const ULONG errCode = ::GetLastError();
		LOG_ERROR(_T("CryptAcquireContext(CRYPT_DELETEKEYSET) failed. [%S]"), WinErrorCode::ToString(errCode).c_str());
	}

	return errMsg;
}


std::string KeyUtils::ExportPrivateKey(
	/*[in]*/ const HCRYPTPROV hProv,
	/*[in]*/ const std::wstring& strKeyPath,
	/*[in]*/ const ULONG ulKeySpec
	)
{
	std::string errMsg;

	HCRYPTKEY hKey = NULL;
	HANDLE hFile = INVALID_HANDLE_VALUE;

	try {
		// Gets a two public/private key pairs
		if (!::CryptGetUserKey(hProv, ulKeySpec, &hKey)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptGetUserKey() failed. [%S]"), errMsg.c_str());
			throw errCode;
		}

		// Exports a private key from a cryptographic service provider (CSP) 
		ULONG ulKeyBlobSize = 0;
		if (!::CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, NULL, &ulKeyBlobSize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptExportKey(PRIVATEKEYBLOB) failed. [%S]"), errMsg.c_str());
			throw errCode;
		}
		if (ulKeyBlobSize == 0) {
			errMsg = WinErrorCode::ToString(ERROR_INCORRECT_SIZE);
			LOG_ERROR(_T("CryptExportKey(PRIVATEKEYBLOB) failed. (%s)"), errMsg.c_str());
			throw E_FAIL;

		}
		std::auto_ptr<BYTE> spKeyBlob(new BYTE[ulKeyBlobSize]);
		::ZeroMemory(spKeyBlob.get(), ulKeyBlobSize);
		if (!::CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, spKeyBlob.get(), &ulKeyBlobSize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptExportKey(PRIVATEKEYBLOB, %d) failed. [%S]"), ulKeyBlobSize, errMsg.c_str());
			throw errCode;
		}

		// Encodes a private key by X.509 certificate encoding or PKCS 7 message encoding
		ULONG ulEncodedKeySize = 0;
		if (!::CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, spKeyBlob.get(), 0, NULL, NULL, &ulEncodedKeySize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptEncodeObjectEx(PKCS_RSA_PRIVATE_KEY) failed. [%S]"), errMsg.c_str());
			throw errCode;
		}
		if (ulEncodedKeySize == 0) {
			errMsg = WinErrorCode::ToString(ERROR_INCORRECT_SIZE);
			LOG_ERROR(_T("CryptEncodeObjectEx(PKCS_RSA_PRIVATE_KEY) failed. (%s)"), errMsg.c_str());
			throw E_FAIL;
		}
		std::auto_ptr<BYTE> spEncodedKey(new BYTE[ulEncodedKeySize]);
		::ZeroMemory(spEncodedKey.get(), ulEncodedKeySize);
		if (!::CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, spKeyBlob.get(), 0, NULL, spEncodedKey.get(), &ulEncodedKeySize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptEncodeObjectEx(PKCS_RSA_PRIVATE_KEY, %d) failed. [%S]"), ulEncodedKeySize, errMsg.c_str());
			throw errCode;
		}

		// Converts a DER formatted binary array into a PEM formatted string
		ULONG ulPemFormattedKeySize = 0;
		if (!::CryptBinaryToStringA(spEncodedKey.get(), ulEncodedKeySize, CRYPT_STRING_BASE64, NULL, &ulPemFormattedKeySize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptBinaryToStringA(CRYPT_STRING_BASE64) failed. [%S]"), errMsg.c_str());
			throw errCode;
		}
		if (ulPemFormattedKeySize == 0) {
			errMsg = WinErrorCode::ToString(ERROR_INCORRECT_SIZE);
			LOG_ERROR(_T("CryptBinaryToStringA(CRYPT_STRING_BASE64) failed. [%S]"), errMsg.c_str());
			throw E_FAIL;
		}
		std::auto_ptr<char> spPemFormattedKey(new char[ulPemFormattedKeySize]);
		::ZeroMemory(spPemFormattedKey.get(), ulPemFormattedKeySize);
		if (!::CryptBinaryToStringA(spEncodedKey.get(), ulEncodedKeySize, CRYPT_STRING_BASE64, spPemFormattedKey.get(), &ulPemFormattedKeySize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptBinaryToStringA(CRYPT_STRING_BASE64, %d) failed. [%S]"), ulPemFormattedKeySize, errMsg.c_str());
			throw errCode;
		}

		// Writes a PEM formatted string to the specifed file path
		hFile = ::CreateFileW(strKeyPath.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CreateFile(%S) failed. [%S]"), strKeyPath.c_str(), errMsg.c_str());
			throw errCode;
		}
		ULONG ulWrittenSize = 0;
		if (!::WriteFile(hFile, PEM_PRIV_KEY_HEADER, ::lstrlenA(PEM_PRIV_KEY_HEADER), &ulWrittenSize, NULL)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("WriteFile(PEM_PRIV_KEY_HEADER, %S) failed. [%S]"), strKeyPath.c_str(), errMsg.c_str());
			throw errCode;
		}
		if (!::WriteFile(hFile, spPemFormattedKey.get(), ulPemFormattedKeySize, &ulWrittenSize, NULL)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("WriteFile(spPemFormattedKey, %S) failed. [%S]"), strKeyPath.c_str(), errMsg.c_str());
			throw errCode;
		}
		if (!::WriteFile(hFile, PEM_PRIV_KEY_FOOTER, ::lstrlenA(PEM_PRIV_KEY_FOOTER), &ulWrittenSize, NULL)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("WriteFile(PEM_PRIV_KEY_FOOTER, %S) failed. [%S]"), strKeyPath.c_str(), errMsg.c_str());
			throw errCode;
		}
	}
	catch (...) {
		;
	}

	if (hKey) {
		// Releases the handle referenced by the hKey
		if (!::CryptDestroyKey(hKey)) {
			const ULONG errCode = ::GetLastError();
			LOG_ERROR(_T("CryptDestroyKey() failed. [%S]"), WinErrorCode::ToString(errCode).c_str());
		}
		hKey = NULL;
	}

	if (hFile != INVALID_HANDLE_VALUE) {
		// Releases the handle referenced by the hFile
		if (!::CloseHandle(hFile)) {
			const ULONG errCode = ::GetLastError();
			LOG_ERROR(_T("CloseHandle() failed. [%S]"), WinErrorCode::ToString(errCode).c_str());
		}
		hKey = NULL;
	}
	
	return errMsg;
}


std::string KeyUtils::ExportPublicKey(
	/*[in]*/ const HCRYPTPROV hProv,
	/*[in]*/ const std::wstring& strKeyPath,
	/*[in]*/ const ULONG ulKeySpec
	)
{
	std::string errMsg;

	HCRYPTKEY hKey = NULL;
	HANDLE hFile = INVALID_HANDLE_VALUE;

	try {
		// Gets a two public/private key pairs
		if (!::CryptGetUserKey(hProv, ulKeySpec, &hKey)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptGetUserKey() failed. [%S]"), errMsg.c_str());
			throw errCode;
		}

		//
		ULONG ulKeyInfoSize = 0;
		if (!::CryptExportPublicKeyInfo(hProv, ulKeySpec, X509_ASN_ENCODING, NULL, &ulKeyInfoSize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptExportPublicKeyInfo(X509_ASN_ENCODING) failed. [%S]"), errMsg.c_str());
			throw errCode;
		}
		std::auto_ptr<BYTE> spKeyInfo(new BYTE[ulKeyInfoSize]);
		::ZeroMemory(spKeyInfo.get(), ulKeyInfoSize);
		CERT_PUBLIC_KEY_INFO* pKeyInfo = (CERT_PUBLIC_KEY_INFO*)spKeyInfo.get();
		if (!::CryptExportPublicKeyInfo(hProv, ulKeySpec, X509_ASN_ENCODING, pKeyInfo, &ulKeyInfoSize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptExportPublicKeyInfo(X509_ASN_ENCODING, %d) failed. [%S]"), ulKeyInfoSize, errMsg.c_str());
			throw errCode;
		}

		// Encodes a public key by X.509 certificate encoding or PKCS 7 message encoding
		ULONG ulEncodedKeySize = 0;
		if (!::CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pKeyInfo, NULL, &ulEncodedKeySize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptEncodeObject(X509_PUBLIC_KEY_INFO) failed. [%S]"), errMsg.c_str());
			throw errCode;
		}
		std::auto_ptr<BYTE> spEncodedKey(new BYTE[ulEncodedKeySize]);
		::ZeroMemory(spEncodedKey.get(), ulEncodedKeySize);
		if (!::CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pKeyInfo, spEncodedKey.get(), &ulEncodedKeySize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptEncodeObject(X509_PUBLIC_KEY_INFO, %d) failed. [%S]"), ulEncodedKeySize, errCode, errMsg.c_str());
			throw errCode;
		}

		// Converts a DER formatted binary array into a PEM formatted string
		ULONG ulPemFormattedKeySize = 0;
		if (!::CryptBinaryToStringA(spEncodedKey.get(), ulEncodedKeySize, CRYPT_STRING_BASE64, NULL, &ulPemFormattedKeySize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptBinaryToStringA(CRYPT_STRING_BASE64) failed. [%S]"), errMsg.c_str());
			throw errCode;
		}
		if (ulPemFormattedKeySize == 0) {
			errMsg = WinErrorCode::ToString(ERROR_INCORRECT_SIZE);
			LOG_ERROR(_T("CryptBinaryToStringA(CRYPT_STRING_BASE64) failed. [%S]"), errMsg.c_str());
			throw E_FAIL;
		}
		std::auto_ptr<char> spPemFormattedKey(new char[ulPemFormattedKeySize]);
		::ZeroMemory(spPemFormattedKey.get(), ulPemFormattedKeySize);
		if (!::CryptBinaryToStringA(spEncodedKey.get(), ulEncodedKeySize, CRYPT_STRING_BASE64, spPemFormattedKey.get(), &ulPemFormattedKeySize)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CryptBinaryToStringA(CRYPT_STRING_BASE64, %d) failed. [%S]"), ulPemFormattedKeySize, errMsg.c_str());
			throw errCode;
		}

		// Writes a PEM formatted string to the specifed file path
		hFile = ::CreateFileW(strKeyPath.c_str(), GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("CreateFile(%S) failed. [%S]"), strKeyPath.c_str(), errMsg.c_str());
			throw errCode;
		}
		ULONG ulWrittenSize = 0;
		if (!::WriteFile(hFile, PEM_PUB_KEY_HEADER, ::lstrlenA(PEM_PUB_KEY_HEADER), &ulWrittenSize, NULL)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("WriteFile(PEM_PUB_KEY_HEADER, %S) failed. [%S]"), strKeyPath.c_str(), errMsg.c_str());
			throw errCode;
		}
		if (!::WriteFile(hFile, spPemFormattedKey.get(), ulPemFormattedKeySize, &ulWrittenSize, NULL)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("WriteFile(spPemFormattedKey, %S) failed. [%S]"), strKeyPath.c_str(), errMsg.c_str());
			throw errCode;
		}
		if (!::WriteFile(hFile, PEM_PUB_KEY_FOOTER, ::lstrlenA(PEM_PUB_KEY_FOOTER), &ulWrittenSize, NULL)) {
			const ULONG errCode = ::GetLastError();
			errMsg = WinErrorCode::ToString(errCode);
			LOG_ERROR(_T("WriteFile(PEM_PUB_KEY_FOOTER, %S) failed. [%S]"), strKeyPath.c_str(), errMsg.c_str());
			throw errCode;
		}
	}
	catch (...) {
		;
	}

	if (hKey) {
		// Releases the handle referenced by the hKey
		if (!::CryptDestroyKey(hKey)) {
			const ULONG errCode = ::GetLastError();
			LOG_ERROR(_T("CryptDestroyKey() failed. [%S]"), WinErrorCode::ToString(errCode).c_str());
		}
		hKey = NULL;
	}

	if (hFile != INVALID_HANDLE_VALUE) {
		// Releases the handle referenced by the hFile
		if (!::CloseHandle(hFile)) {
			const ULONG errCode = ::GetLastError();
			LOG_ERROR(_T("CloseHandle() failed. [%S]"), WinErrorCode::ToString(errCode).c_str());
		}
		hKey = NULL;
	}

	return errMsg;
}
