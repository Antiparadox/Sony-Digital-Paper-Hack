//
//  KeyUtils.cpp
//
//  Copyright 2016 Sony Corporation
//

#include "KeyUtils.h"
#include "AutoCFString.h"
#include "MacErrorCode.h"
#include "../Log.h"


std::string KeyUtils::GenRsa2048KeyPair(
	/*[in]*/ const std::string& privateKeyPath,
	/*[in]*/ const std::string& publicKeyPath
	)
{
	std::string errMsg;
    OSStatus result = errSecSuccess;
    
    CFMutableDictionaryRef genKeyParams = NULL;
    CFNumberRef keySize = NULL;
    
    SecKeyRef publicKey = NULL;
    SecKeyRef privateKey = NULL;
    
    CFDataRef pulickKeyData = NULL;
    CFDataRef privateKeyData = NULL;
    
    try {
        // 鍵生成のパラメーターを用意する
        genKeyParams = CFDictionaryCreateMutable(
                                                 kCFAllocatorDefault,
                                                 0,
                                                 &kCFTypeDictionaryKeyCallBacks,
                                                 &kCFTypeDictionaryValueCallBacks);
        
        CFDictionarySetValue(genKeyParams, kSecAttrKeyType, kSecAttrKeyTypeRSA);
        const int iKeySize= 2048;
        keySize = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &iKeySize);
        CFDictionarySetValue(genKeyParams, kSecAttrKeySizeInBits, keySize);
        
        // 公開鍵・秘密鍵を生成してキーチェーンに登録する
        result = SecKeyGeneratePair(genKeyParams, &publicKey, &privateKey);
        if (result != errSecSuccess) {
            errMsg = MacErrorCode::ToString(result);
            LOG_ERROR("SecKeyGeneratePair(RSA-2048) failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        
        // キーチェーンからPEM形式で秘密鍵を取り出す
        errMsg = KeyUtils::exportKeyFromKeyChain(privateKey, &privateKeyData);
        if (!errMsg.empty()) {
            LOG_ERROR("exportKeyFromKeyChain(privateKey) failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        
        // キーチェーンからPEM形式で公開鍵を取り出す
        errMsg = KeyUtils::exportKeyFromKeyChain(publicKey, &pulickKeyData);
        if (!errMsg.empty()) {
            LOG_ERROR("exportKeyFromKeyChain(publicKey) failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        
        // 秘密鍵をファイルに出力する
        errMsg = KeyUtils::writeKeyFile(privateKeyPath, privateKeyData);
        if (!errMsg.empty()) {
            LOG_ERROR("writeKeyFile(%s) failed [%s]", privateKeyPath.c_str(), errMsg.c_str());
            throw errMsg;
        }
        
        // 公開鍵をファイルに出力する
        errMsg = KeyUtils::writeKeyFile(publicKeyPath, pulickKeyData);
        if (!errMsg.empty()) {
            LOG_ERROR("writeKeyFile(%s) failed [%s]", publicKeyPath.c_str(), errMsg.c_str());
            throw errMsg;
        }
    }
    catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
        }
    }
    
    if (privateKey) {
        // キーチェーンから秘密鍵を削除する
        KeyUtils::deleteKeyFromKeyChain(privateKey);
        CFRelease(privateKey);
    }
    
    if (publicKey) {
        // キーチェーンから公開鍵を削除する
        KeyUtils::deleteKeyFromKeyChain(publicKey);
        CFRelease(publicKey);
    }

    if (pulickKeyData) {
        CFRelease(pulickKeyData);
    }
    
    if (privateKeyData) {
        CFRelease(privateKeyData);
    }
    
    if (genKeyParams) {
        CFRelease(genKeyParams);
    }
    
    if (keySize) {
        CFRelease(keySize);
    }
    
	return errMsg;
}


std::string KeyUtils::exportKeyFromKeyChain(
    /*[in]*/ SecKeyRef keyRef,
    /*[out]*/ CFDataRef* keyData
) {
    std::string errMsg;
    
    try {
        OSStatus result = errSecSuccess;
        result = SecItemExport(keyRef, kSecFormatOpenSSL, kSecItemPemArmour, NULL, keyData);
        if (result != errSecSuccess) {
            errMsg = MacErrorCode::ToString(result);
            LOG_ERROR("SecItemExport() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
    }
    catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
        }
    }
    
    return errMsg;
}


std::string KeyUtils::deleteKeyFromKeyChain(
    /*[in]*/ SecKeyRef keyRef
) {
    std::string errMsg;
    
    CFMutableDictionaryRef queryParams = NULL;
    
    try {
        queryParams = CFDictionaryCreateMutable(
                                                kCFAllocatorDefault,
                                                0,
                                                &kCFTypeDictionaryKeyCallBacks,
                                                &kCFTypeDictionaryValueCallBacks
                                                );
        CFDictionarySetValue(queryParams, kSecClass, kSecClassKey);
        CFDictionarySetValue(queryParams, kSecValueRef, keyRef);
        
        OSStatus result = errSecSuccess;
        result = SecItemDelete(queryParams);
        if (result != errSecSuccess) {
            errMsg = MacErrorCode::ToString(result);
            LOG_ERROR("SecItemDelete() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
    }
    catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
        }
    }
    
    if (queryParams) {
        CFRelease(queryParams);
    }

    return errMsg;
}


std::string KeyUtils::writeKeyFile(
    /*[in]*/ const std::string& filePath,
    /*[in]*/ CFDataRef pemKeyData
) {
    std::string errMsg;
    
    FILE* file = NULL;
    CFStringRef pemKeyStr = NULL;
    char* szKeyData = NULL;
    
    try {
        file = fopen(filePath.c_str(), "w");
        
        pemKeyStr = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, pemKeyData, kCFStringEncodingUTF8);
        szKeyData = KeyUtils::getCString(pemKeyStr);
        fprintf(file,"%s", szKeyData);
    }
    catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
        }
    }
    
    if (file) {
        fclose(file);
    }
    
    if (szKeyData) {
        free(szKeyData);
    }
    
    if (pemKeyStr) {
        CFRelease(pemKeyStr);
    }
    
    return errMsg;
}


char* KeyUtils::getCString(
    /*[in]*/ CFStringRef srcString
) {
    if (srcString == NULL) {
        return NULL;
    }
    
    CFIndex length = CFStringGetLength(srcString);
    CFIndex maxSize = CFStringGetMaximumSizeForEncoding(length, kCFStringEncodingUTF8) + 1;
    char *buffer = (char *)malloc(maxSize);
    if (CFStringGetCString(srcString, buffer, maxSize, kCFStringEncodingUTF8)) {
        return buffer;
    }
    return NULL;
}



