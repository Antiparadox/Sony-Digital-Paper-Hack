//
//  CertUtils.cpp
//
//  Copyright 2016 Sony Corporation
//

#include "CertUtils.h"
#include "MacErrorCode.h"
#include "../Log.h"



std::string CertUtils::addCertToRootStore(
    /*[in]*/ const std::string& strPemCert
) {
    std::string errMsg;
    OSStatus result = errSecSuccess;

    CFStringRef pemCertStr = NULL;
    CFMutableStringRef pemCertMstr = NULL;
    CFDataRef certData = NULL;
    
    SecCertificateRef certRef = NULL;
    SecKeychainRef keychainRef = NULL;
    
    CFDictionaryRef query = NULL;
    CFTypeRef keychainItem = NULL;
    CFMutableDictionaryRef trustSslSetting = NULL;
    SecPolicyRef sslPolicy = NULL;
    
    try {
        // PEM形式の証明書のバイナリを文字列化する
        pemCertStr = CFStringCreateWithCString(kCFAllocatorDefault, strPemCert.c_str(), kCFStringEncodingUTF8);
        pemCertMstr = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, pemCertStr);
        
        // PEM形式のheader/footerおよび改行コードを削除する
        CFRange range = CFStringFind(pemCertMstr, CFSTR("\n"), 0);
        while (range.length > 0) {
            CFStringDelete(pemCertMstr, range);
            range = CFStringFind(pemCertMstr, CFSTR("\n"), 0);
        }
        CFStringTrim(pemCertMstr, CFSTR("-----BEGIN CERTIFICATE-----"));
        CFStringTrim(pemCertMstr, CFSTR("-----END CERTIFICATE-----"));
        
        // Base64でencodeされた証明書をdecodeする
        errMsg = CertUtils::decodeBase64String(pemCertMstr, &certData);
        if (!errMsg.empty()) {
            throw errMsg;
        }
        
        // decodeした証明書からSecCertificateオブジェクトを生成する
        certRef = SecCertificateCreateWithData(NULL, certData);
        
        // キーチェーンの「ログイン」を開く
        result = SecKeychainOpen("login.keychain", &keychainRef);
        if (result != errSecSuccess) {
            errMsg = MacErrorCode::ToString(result);
            LOG_ERROR("SecKeychainOpen(login.keychain) failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        
        // 証明書をキーチェーンに登録する
        result = SecCertificateAddToKeychain(certRef, keychainRef);
        if (result != errSecSuccess && result != errSecDuplicateItem) {
            errMsg = MacErrorCode::ToString(result);
            LOG_ERROR("SecCertificateAddToKeychain() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        
        // キーチェーンから証明書を検索するための条件を用意する
        errMsg = CertUtils::createCertQueryCondition(certRef, keychainRef, &query);
        if (!errMsg.empty()) {
            throw errMsg;
        }
        
        // キーチェーンから登録済み証明書を検索する
        result = SecItemCopyMatching(query, &keychainItem);
        if (result != errSecSuccess) {
            errMsg = MacErrorCode::ToString(result);
            LOG_ERROR("SecItemCopyMatching() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        CFTypeID id = CFGetTypeID(keychainItem);
        if (id != SecCertificateGetTypeID()) {
            LOG_ERROR("CFGetTypeID() != SecCertificateGetTypeID() [%ld]", id);
            throw result;
        }
        SecCertificateRef regCertRef = (SecCertificateRef)keychainItem;
        
        // 証明書の「SSL (Secure Sockets Layer)」を「常に信頼」 に設定する
        trustSslSetting = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        sslPolicy = SecPolicyCreateSSL(true, NULL);
        CFDictionarySetValue(trustSslSetting, kSecTrustSettingsPolicy, sslPolicy);
        result = SecTrustSettingsSetTrustSettings(regCertRef, kSecTrustSettingsDomainUser, trustSslSetting);
        if (result != errSecSuccess) {
            errMsg = MacErrorCode::ToString(result);
            LOG_ERROR("SecTrustSettingsSetTrustSettings(SSL) failed [%s]", errMsg.c_str());
            throw errMsg;
        }
    }
    catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
        }
    }
    
    if (sslPolicy) {
        CFRelease(sslPolicy);
    }
    if (trustSslSetting) {
        CFRelease(trustSslSetting);
    }
    if (keychainItem) {
        CFRelease(keychainItem);
    }
    if (query) {
        CFRelease(query);
    }
    if (keychainRef) {
        CFRelease(keychainRef);
    }
    if (certRef) {
        CFRelease(certRef);
    }
    if (certData) {
        CFRelease(certData);
    }
    if (pemCertMstr) {
        CFRelease(pemCertMstr);
    }
    if (pemCertStr) {
        CFRelease(pemCertStr);
    }
    
    return errMsg;
}


std::string CertUtils::decodeBase64String(
    /*[in]*/ CFStringRef base64String,
    /*[out]*/ CFDataRef* decodedData
){
    std::string errMsg;
    
    CFErrorRef error = NULL;
    CFDataRef encodedData = NULL;
    
    try {
        // CFStringからCFDataに変換する
        encodedData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, base64String, kCFStringEncodingUTF8, 0);
        
        // Base64でencodeされた文字列をdecodeする
        SecTransformRef decoder = SecDecodeTransformCreate(kSecBase64Encoding, &error);
        if (error) {
            errMsg = MacErrorCode::ToString(error);
            LOG_ERROR("SecDecodeTransformCreate() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        SecTransformSetAttribute(decoder, kSecTransformInputAttributeName, encodedData, &error);
        if (error) {
            errMsg = MacErrorCode::ToString(error);
            LOG_ERROR("SecTransformSetAttribute() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        *decodedData = (CFDataRef)SecTransformExecute(decoder, &error);
        if (error) {
            errMsg = MacErrorCode::ToString(error);
            LOG_ERROR("SecTransformExecute() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
    }
    catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
        }
    }
    
    if (encodedData) {
        CFRelease(encodedData);
    }
    if (error) {
        CFRelease(error);
    }
    
    return errMsg;
}


std::string CertUtils::createCertQueryCondition(
    /*[in]*/ SecCertificateRef originalCert,
    /*[in]*/ SecKeychainRef targetKeychain,
    /*[out]*/ CFDictionaryRef* queryCondition
) {
    std::string errMsg;
    
    CFErrorRef error = NULL;
    
    CFMutableDictionaryRef queryDict = NULL;
    CFMutableArrayRef searchList = NULL;
    CFDataRef serialNumber = NULL;
    CFDataRef issuer = NULL;
    
    try {
        // キーチェーンから証明書を検索するための条件を用意する
        queryDict = CFDictionaryCreateMutable(
                                              kCFAllocatorDefault,
                                              0,
                                              &kCFTypeDictionaryKeyCallBacks,
                                              &kCFTypeDictionaryValueCallBacks
                                              );
        
        // SecCertificateを検索する
        CFDictionarySetValue(queryDict, kSecClass, kSecClassCertificate);
        
        // 検索結果としてSecCertificateRefを取得する
        CFDictionarySetValue(queryDict, kSecReturnRef, kCFBooleanTrue);
        
        // 検索先のキーチェーンを設定する
        searchList = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(searchList, targetKeychain);
        CFDictionarySetValue(queryDict, kSecMatchSearchList, searchList);
        
        // 証明書のシリアルナンバーを検索条件に設定する
        serialNumber = SecCertificateCopySerialNumber(originalCert, &error);
        if (error) {
            errMsg = MacErrorCode::ToString(error);
            LOG_ERROR("SecCertificateCopySerialNumber() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        CFDictionarySetValue(queryDict, kSecAttrSerialNumber, serialNumber);
        
        // 証明書の発行者を検索条件に設定する
        issuer = SecCertificateCopyNormalizedIssuerContent(originalCert, &error);
        if (error) {
            errMsg = MacErrorCode::ToString(error);
            LOG_ERROR("SecCertificateCopyNormalizedIssuerContent() failed [%s]", errMsg.c_str());
            throw errMsg;
        }
        CFDictionarySetValue(queryDict, kSecAttrIssuer, issuer);
        
        *queryCondition = queryDict;
        queryDict = NULL;
    }
    catch (...) {
        if (errMsg.empty()) {
            errMsg = MacErrorCode::GetLastError();
        }
    }
    
    if (issuer) {
        CFRelease(issuer);
    }
    if (serialNumber) {
        CFRelease(serialNumber);
    }
    if (searchList) {
        CFRelease(searchList);
    }
    if (queryDict) {
        CFRelease(queryDict);
    }
    if (error) {
        CFRelease(error);
    }
    
    return errMsg;
}



