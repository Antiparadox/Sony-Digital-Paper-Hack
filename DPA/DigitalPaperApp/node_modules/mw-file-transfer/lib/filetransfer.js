/**
    filetransfer.js
    
    created:    [2016-06-10 11:49:08+09:00]
    modified:   [2016-11-23 13:06:41+09:00]
    description:
    File Transfer
*/

'use strict';

const mwe = require('mw-error');

// Use from Main Process
const electron = require('electron');

if ( typeof electron.remote === 'undefined' ) {
  throw new Error('This module must be loaded from Electron Renderer');
  // [2016-06-01 14:02:51+09:00] kan.k: このモジュールは、
  // RendererProcessで動作させる必要がある。理由はXHRを通じてRenderer
  // 側のHTTPSスタックを利用して通信するため。
}

const debug = require('debug')('mw-file-transfer');
// const debug = electron.remote.require('debug')('mw-file-transfer');

// [TODO] remote にする必要がなくなったため、要コメント修正
// [2016-06-20 18:36:35+09:00] kan.k: [TODO] This should be remote
const fs = require('fs');
// const fs = electron.remote.require('fs');

const path = require('path');

///////////////////////////////////
/// Master switches
///////////////////////////////////

const ENABLE_REAUTH = (!!process.env.MW_SUPPORT_DPAPI_REAUTH);

const ENABLE_RETRY = (!!process.env.MW_SUPPORT_DPAPI_RETRY);

/// Check size between webapi response and content-range header while
/// donwloading.
const STRICT_SIZE_CHECK = (!!process.env.MW_SUPPORT_DPAPI_STRICT_SIZE_CHECK);

/// Check JSON.
const STRICT_JSON_CHECK = (!!process.env.MW_SUPPORT_DPAPI_STRICT_JSON_CHECK);

debug("reauth: ", ENABLE_REAUTH);
debug("retry: ", ENABLE_RETRY);
debug("strict size check: ", STRICT_SIZE_CHECK);
debug("strict json check: ", STRICT_JSON_CHECK);

///////////////////////////////////
/// Reauth switches
///////////////////////////////////

const REAUTH_UPLOAD_DOCUMENT = ENABLE_REAUTH;

const REAUTH_UPLOAD_OVERWRITE_DOCUMENT = ENABLE_REAUTH;

// exclusive of above switches.
const REAUTH_UPLOAD_PARTIAL = false;

const REAUTH_CALL_WEBAPI = ENABLE_REAUTH;

///////////////////////////////////
/// Retry switches
///////////////////////////////////

// retry upload document
const RETRY_UPLOAD_DOCUMENT = ENABLE_RETRY;

const RETRY_CALL_WEBAPI = ENABLE_RETRY;

const RETRY_CALL_WEBAPI_FOR_TIMEOUT = false;

///////////////////////////////////
/// Constant
///////////////////////////////////

// Chunk len for partial upload.
const CHUNKLEN = 8 * 1024 * 1024;

// status to invoke reauth.
const REAUTH_STATUSES = [401];

/// XHR default timeout value.
const XHR_TIMEOUT = 60000;

/// XHR default timeout value for file transfer.
const XHR_TIMEOUT_TRANSFER = 120000;

/**
 * Create ConnCtrl instance.
 */
exports.createFileTransfer = function(connCtrl) {
  return new FileTransfer(connCtrl);
}

/** 
 * Connection Control class for MilkyWay
 * @class
 */
class FileTransfer {
  constructor(connCtrl) {
    this.connCtrl_ = connCtrl;
//    this.currentFolderId_ = 'root';
    this.bytesTotal_ = null;
    this.bytesTransferred_ = null;
    this.bytesTransferredCompleted_ = null;
    this.xhrRequest_ = null;
  }

  /**
   * Download document.
   *
   * @param {string} documentId The target document to download.
   * @param {string} filepath A full path to download the file.
   * @param {function(?Error, stamp, filePath)} callback The callback to get cert
   *   result. When failed to download an Error object will be
   *   returned to first argument. The error code of the Error object
   *   are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   - E_MW_FILE_WRITE_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。取得に失敗した場合には、第一引数に
   *   Errorオブジェクトが返る。返る場合のあるエラーコードは次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   - E_MW_FILE_WRITE_LOCAL_FAILED
   */
  downloadDocument(documentId, filepath, rename, callback) {
    if ( typeof documentId !== 'string' ) {
      throw new TypeError('documentId must be a string');
    }
    if ( typeof filepath !== 'string' ) {
      throw new TypeError('filepath must be a string');
    }
    if ( typeof rename !== 'boolean' ) {
      throw new TypeError('filepath must be a string');
    }
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }

    // 転送先ディレクトリのパスを取得する
    const dirPath = path.dirname(filepath);
    const fileName = path.basename(filepath);

    // 転送先ディレクトリを階層的に作成する
    const self = this;
    this.makeDirRecursively_(dirPath, function(error, dstDirPath){
      if (error) {
        callback(error);
        self.terminateTransferState_();
        return;
      }
      
      if ( ! rename ) {
        // 転送元のドキュメントのファイルサイズを取得する
        self.getDocumentSize_(documentId, (err, fileSize) => {
          if (err) {
            callback(err);
            self.terminateTransferState_();
            return;
          }

          // ファイルのダウンロードを開始する
          self.downloadFile_(
            'GET','/documents/' + documentId + '/file',
            (STRICT_JSON_CHECK ? '/documents/' + documentId : null),
            (STRICT_SIZE_CHECK ? fileSize : null), filepath, callback);
            // fileSize, filepath, callback);
        });
        return;
      }

      // 重複を回避した転送先ファイルパスを生成する
      self.getDownloadableFileName_(dstDirPath, fileName, function(error, dstFileName){
        if (error) {
          callback(error);
          self.terminateTransferState_();
          return;
        }
        const dstFilePath = path.join(dstDirPath, dstFileName);

        // 転送元のドキュメントのファイルサイズを取得する
        self.getDocumentSize_(documentId, (err, fileSize) => {
          if (err) {
            callback(err);
            self.terminateTransferState_();
            return;
          }

          // ファイルのダウンロードを開始する
          self.downloadFile_(
            'GET', '/documents/' + documentId + '/file',
            (STRICT_JSON_CHECK ? '/documents/' + documentId : null),
            (STRICT_SIZE_CHECK ? fileSize : null), dstFilePath, callback);
            // fileSize, dstFilePath, callback);
        });
      });
    });
  }
  
  /**
   * Download document as binary.
   *
   * @param {string} documentId The target document to download.
   * @param {function(Buffer,boolean)} output
   * @param {function(?Error)} callback
   *   The callback to get a file as binary.
   *   When failed to download an Error object will be returned
   *   to first argument. The error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   <br>
   *   結果を受け取るCallback関数。取得に失敗した場合には、第一引数に
   *   Errorオブジェクトが返る。返る場合のあるエラーコードは次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_REMOTE_MODIFIED
   */
  downloadDocumentAsBinary(documentId, output, callback) {
    if ( typeof documentId !== 'string' ) {
      throw new TypeError('documentId must be a string');
    }
    if ( typeof output !== 'function' ) {
      throw new TypeError('output must be a function');
    }
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }

    var self = this;
    // 転送元のドキュメントのファイルサイズを取得する
    this.getDocumentSize_(documentId, (err, fileSize) => {
      if (err) {
        callback(err);
        self.terminateTransferState_();
        return;
      }
      // ファイルのダウンロードを開始する
      self.downloadFileAsBinary_(
        'GET', '/documents/' + documentId + '/file',
        (STRICT_JSON_CHECK ? '/documents/' + documentId : null),
        (STRICT_SIZE_CHECK ? fileSize : null), output, callback);
        // fileSize, output, callback);
    });
  }

  /**
   * Win/Mac上にディクレトリを階層的に作成する
   * 
   * @private
   * @param {string} dirPath 作成対象のディクレトリパス
   * @param {function(?Error, dstDirPath)} callback
   */
  makeDirRecursively_(dirPath, callback) {

    if (typeof dirPath !== 'string') {
      throw new TypeError('dirPath must be a string');      
    }
    if (typeof callback !== 'function') {
      throw new TypeError('callback must be a function');      
    }

    // [TODO] Node.js の path.parse() での置き換えを検討する
    // UNC形式のパスの分割は以下の振る舞いで正しいとのこと。
    //
    // Node.js の path.parse() を使用してディレクトリパスを分割したいが、
    // '\\xxx.exapmel.com'のようなUNC形式のパスが正しく分割できない。
    // （Node.js v6.1.0 にて確認）
    //
    //     > path.parse('\\\\xxx.example.com\\test');
    //     { root: '\\\\xxx.example.com\\test',
    //       dir: '\\\\xxx.example.com\\test',
    //       base: '',
    //       ext: '',
    //       name: '' }
    //
    // Windowsの場合にもファイルパスに'/'が含まれていた場合には、POSIXの流儀にあわせて
    // これを区切り文字として扱う。そのために、以下でパス内の'/'を'\'に変換する。
    if (process.platform === 'win32') {
      dirPath = dirPath.replace(/\//g, path.sep);
    }

    let dirPathArray = dirPath.split(path.sep);
    if (dirPathArray.length === 0) {
      throw new Error('invalid folderPath : ' + dirPath);      
    }
    if (dirPathArray[dirPathArray.length - 1] === '') {
      // フォルダパスの末尾がseparatorの場合には末尾の要素を削除する
      dirPathArray.pop();
    }
    if (dirPathArray.length === 1) {
      // ディレクトリパスとして、Windowsのドライブ直下('C:\'など）やmacOSでのroot直下('/')が
      // 指定された場合には、指定されたディレクトリパスをそのまま使用する
      callback(null, dirPath);
      return;
    }

    // ルートディクレトリの取得
    //  例) ['', 'Users'] ⇒ '\Users'
    //  例) ['', '', 'xxx.example.com'] ⇒ '\\xxx.exapmel.com'
    let rootDir = dirPathArray.shift();
    if (rootDir === '') {
      rootDir = path.sep + dirPathArray.shift();
      if (rootDir === path.sep) {
        rootDir += path.sep + dirPathArray.shift();
      } 
    }

    const self = this;
    this.makeChildDirRecursively_(rootDir, dirPathArray, function (error, dstDirPath) {
      if (error) {
        callback(error);
        return;
      }
      callback(null, dstDirPath);
    });
  }


  /**
   * 階層的にダウンロード先の子ディレクトリを作成する。
   * 
   * @private
   * @param {string} parentDirPath ディレクトリ作成先のパス
   * @param {string} childDirPathArray 階層化された子ディレクトリの名前の配列
   * @param {function(?Error, dirPath)} callback
   */
  makeChildDirRecursively_(parentDirPath, childDirPathArray, callback) {

    // この階層で作成するフォルダ名を取り出す
    const dirName = childDirPathArray.shift();

    // 再帰的に子フォルダを作成する
    const self = this;
    this.makeDirWithNewNameIfConflicted_(parentDirPath, dirName, function (error, dstDirName) {
      if (error) {
        callback(error);
        return;
      }

      const dstDirPath = path.join(parentDirPath, dstDirName);

      if (childDirPathArray.length === 0) {
        // 全てのフォルダの作成が完了した場合
        callback(null, dstDirPath);
        return;
      }

      self.makeChildDirRecursively_(dstDirPath, childDirPathArray, callback);
    });
  }

  /**
   * ダウンロード先のディレクトリを作成する。
   * ただし、名前重複時には連番付きのディレクトリ名でディレクトリを作成する。
   * 
   * @private
   * @param {string} parentDirPath ディレクトリ作成先のパス
   * @param {string} dirName 作成するディレクトリの名前
   * @param {function(?Error, dirName)} callback
   */
  makeDirWithNewNameIfConflicted_(parentDirPath, dirName, callback) {
    // アップロード可能なフォルダ名を取得する
    const self = this;
    this.getDownloadableDirName_(parentDirPath, dirName, function(error, dstDirName, alreadyExists){
      if (error) {
        callback(error);
        return;
      }

      if (alreadyExists) {
        // 使用可能なディクレトリが既に存在した場合には、そのディクレトリを使用する
        callback(null, dstDirName);
        return;
      }

      // 新規にディクレトリを作成する
      const dirPath = path.join(parentDirPath, dstDirName);
      fs.mkdir(dirPath, function(error) {
        if (error) {
          callback(mwe.genError(
            mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to create directory.', error));
          return;
        }
        callback(null, dstDirName);
      });
    });
  }

  /**
   * ダウンロード先として、使用可能なディレクトリ名を取得する。
   * 
   * @private
   * @param {string} parentDirPath ディレクトリ作成先のパス
   * @param {string} dirName 作成するディレクトリの名前
   * @param {function(?Error, dirName, alreadyExists)} callback
   */
  getDownloadableDirName_(parentDirPath, dirName, callback) {

    const dirPath = path.join(parentDirPath, dirName);

    // 作成するディレクトリと同名のファイルが存在しないかを確認する
    const self = this;
    fs.stat(dirPath, function (error, stats) {
      if (error && error.code === 'ENOENT') {
        // 同名のエントリが存在しない場合
        callback(null, dirName);
        return;
      }
      if (error) {
        callback(mwe.genError(
          mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to read directory.', error));
        return;
      }

      if (stats.isDirectory()) {
        // 同名のディレクトリが存在した場合には、そのディレクトリを使用する
        const alreadyExists = true;
        callback(null, dirName, alreadyExists);
        return;
      }

      // 同名のエントリが既に存在する場合

      // 指定されたディレクトリ名に既に連番が付いていた場合には、ベースのディレクトリ名を抜き出す
      //  例) "dir (1)"  ⇒ "dir"
      //  例) "dir(1)"   ⇒ null
      //  例) "dir (01)" ⇒ nulll
      let dirBaseName = dirName;
      const result = dirName.match(/^(.*) \([1-9][0-9]*\)$/);
      if (result) {
        dirBaseName = result[1];
      }
      
      // 重複しない連番付きのディレクトリ名を取得する
      self.getDownloadableDirNameWithIndex_(parentDirPath, dirBaseName, 1, callback);
    });
  }

  /**
   * ダウンロード先のディレクトリ名が既存のファイル名と重複した際に、連番付きのディレクトリ名を作成する。
   * 
   * @private
   * @param {string} parentDirPath ディレクトリ作成先のパス
   * @param {string} dirBaseName 作成するディレクトリの名前
   * @param {string} index ディレクトリ名に追加する番号
   * @param {function(?Error, dirName, alreadyExists)} callback
   */
  getDownloadableDirNameWithIndex_(parentDirPath, dirBaseName, index, callback) {
    // 連番付きのディレクトリ名を用意する
    const dirName = dirBaseName + ' (' + index + ')';

    // 再帰的に未使用のディレクトリ名を探す
    const self = this;
    const dirPath = path.join(parentDirPath, dirName);
    fs.stat(dirPath, function (error, stats) {
      if (error && error.code === 'ENOENT') {
        // 同名のエントリが存在しない場合
        const alreadyExists = false;
        callback(null, dirName, alreadyExists);
        return;
      }
      if (error) {
        callback(mwe.genError(
          mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to read directory.', error));
        return;
      }

      if (stats.isDirectory()) {
        // 同名のディレクトリが存在した場合には、そのフォルダを使用する
        const alreadyExists = true;
        callback(null, dirName, alreadyExists);
        return;
      }

      self.getDownloadableDirNameWithIndex_(parentDirPath, dirBaseName, ++index, callback);
    });
  }

  /**
   * ダウンロード先として、使用可能なファイル名を取得する。
   * 
   * @private
   * @param {string} parentDirPath 転送先ディレクトリのパス
   * @param {string} fileName 作成するファイルの名前
   * @param {function(?Error, fileName)} callback
   */
  getDownloadableFileName_(parentDirPath, fileName, callback) {
    // ファイルの転送先に同名ファイルが存在しないか確認する
    const self = this;
    const filePath = path.join(parentDirPath, fileName);
    fs.stat(filePath, function (error, stats) {
      if (error && error.code === 'ENOENT') {
        // 同名のエントリが存在しない場合
        callback(null, fileName);
        return;
      }
      if (error) {
        callback(mwe.genError(
          mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to read directory.', error));
        return;
      }

      // 同名のエントリが既に存在する場合

      // 指定されたファイル名に既に連番が含まれていた場合には、ベースのファイル名と拡張子を抜き出す
      //  例) "file (1).pdf"  ⇒ "file", ".pdf"
      //  例) "file(1) .pdf"  ⇒ null
      //  例) "file(1).pdf"   ⇒ null
      //  例) "file (01).pdf" ⇒ null
      let fileBaseName;
      let fileExt;
      let result = fileName.match(/^(.*) \([1-9][0-9]*\)(\..*)$/);
      if (result) {
        // ファイル名に連番が含まれていた場合
        fileBaseName = result[1];
        fileExt = result[2];
      }
      else {
        // ファイル名に連番が含まれていなかった場合
        //  例) "file.pdf"  ⇒ "file", ".pdf"
        result = fileName.match(/^(.*)(\..*)$/);
        fileBaseName = result[1];
        fileExt = result[2];
      }
      
      // 重複しない連番付きのフォルダ名を取得する
      self.getDownloadableFileNameWithIndex_(parentDirPath, fileBaseName, fileExt, 1, callback);
    });
  }

  /**
   * ダウンロード先のファイル名が既存のファイル名やディクレトリ名と重複した際に、連番付きのファイル名を作成する。
   *
   * @private
   * @param {string} parentDirPath 転送先ディレクトリのパス
   * @param {string} fileBaseName 転送するドキュメントのファイル名
   * @param {string} fileExt 転送するドキュメントのファイルの拡張子
   * @param {string} index ファイル名に追加する番号
   * @param {function(?Error, fileName)} callback
   */
  getDownloadableFileNameWithIndex_(parentDirPath, fileBaseName, fileExt, index, callback) {
    // 連番付きのファイル名を用意する
    const fileName = fileBaseName + ' (' + index + ')' + fileExt;
    const filePath = path.join(parentDirPath, fileName);

    // 再帰的に未使用のファイル名を探す
    const self = this;
    fs.stat(filePath, function (error, stats) {
      if (error && error.code === 'ENOENT') {
        // 同名のエントリが存在しない場合
        callback(null, fileName);
        return;
      }
      if (error) {
        callback(mwe.genError(
          mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to read directory.', error));
        return;
      }

      self.getDownloadableFileNameWithIndex_(parentDirPath, fileBaseName, fileExt, ++index, callback);
    });
  }

  /**
   * デバイス上のドキュメントのファイルサイズを取得する。
   * 
   * @private
   * @param {string} documentId 対象のドキュメントのID
   * @callback {function{?Error,fileSize}} callback
   */
  getDocumentSize_(documentId, callback) {
    const self = this;
    this.callWebApi('GET', '/documents/' + documentId, null, (err, data, status) => {
      if (err) {
        callback(err);
        return;
      }
      if (status !== 200) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'GET', '/documents/' + documentId,
          status, data));
        return;
      }
      const fileSize = parseInt(data.file_size, 10);
      if (typeof data.file_size !== 'string' || isNaN(fileSize)) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'fileSize is not a number.', 'GET', '/documents/' + documentId,
          status, data));
        return;
      }      
      callback(null, fileSize);
    });
  }


  /**
   * Upload document.
   *
   * @param {string} parentFolderId The target folder to upload file.
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error, documentId, folderId)} callback
   *   The callback to get cert result. When succeed the documentId
   *   for the document that created is passed as a second argument,
   *   and the folderId for the parent folder of the document is
   *   passed as a third argument. When failed to upload an Error
   *   object will be returned to first argument.
   *   The error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに成功した場合には、作
   *   成されたファイルのdocumentIdが第二引数に渡される。アップロード
   *   に失敗した場合には、第一引数にErrorオブジェクトが返る。返る場合
   *   のあるエラーコードは次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   */
  uploadDocumentById(parentFolderId, filepath, filename, callback) {
    this.uploadDocumentByIdWithRetry_(parentFolderId, filepath, filename, false, false, callback);
    return;
  }

  /**
   * @private
   */
  uploadDocumentByIdWithRetry_(parentFolderId, filepath, filename, reauthed, retried, callback) {
    if ( typeof callback !== 'function' ) {
      callback = this.defaultCallback;
    }
    // var parentFolderId = this.currentFolderId_;

    // callWebApi(method, apipath, body, callback
    if ( typeof filename !== 'string') {
      filename = path.parse(filepath).base;
    }

    var req = { parent_folder_id: parentFolderId,
                file_name: filename,
                document_source: '' };

    var self = this;
    this.callWebApi('POST', '/documents/', req, function(err, data, status) {
      // console.log('END with err: ', err, ', data:', data);
      if ( err ) {
        callback(err);
        // self.terminateTransferState_();
        return;
      }
      if ( status !== 200 ) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'POST', '/documents/', status, data));
        // self.terminateTransferState_();
        return;
      }
      var docId = data.document_id;
      if ( typeof docId !== 'string' ) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.', 'POST', '/documents/', status, data));
        // self.terminateTransferState_();
        return;
      }

      self.uploadFile_('PUT', '/documents/' + docId + '/file', filepath, null, function(err, stamp) {
        if ( err ) {
          if ( REAUTH_UPLOAD_DOCUMENT && ! reauthed &&
               err.mwCode === mwe.E_MW_WEBAPI_UNEXPECTED_STATUS &&
               REAUTH_STATUSES.indexOf(err.mwWebApiResCode) >= 0 ) {

            debug('reaauth upload document invoked by: ', err);
            self.connCtrl_.auth(function(autherr) {
              if ( autherr ) {
                // returning original error.
                callback(err);
                return;
              }
              self.uploadDocumentByIdWithRetry_(parentFolderId, filepath, filename, true, retried, callback);
            });
            return;
          }
          if ( RETRY_UPLOAD_DOCUMENT && ! retried &&
               err.mwCode === mwe.E_MW_WEBAPI_ERROR ) {
            debug('retry upload document invoked by: ', err);
            self.uploadDocumentByIdWithRetry_(parentFolderId, filepath, filename, reauthed, true, callback);
            return;
          }
          
          callback(err);
          // self.terminateTransferState_();
          return;
        }
        callback(null, docId, parentFolderId, stamp);
        // self.terminateTransferState_();
      });
    });
  }

  
  /**
   * Upload document.
   *
   * @param {string} parentFolderPath The target folder path to upload file.
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error, documentId, folderId, stamp)} callback
   *   The callback to get cert result. When succeed the documentId
   *   for the document that created is passed as a second argument,
   *   and the folderId for the parent folder of the document is
   *   passed as a third argument. When failed to upload an Error
   *   object will be returned to first argument.
   *   The error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに成功した場合には、作
   *   成されたファイルのdocumentIdが第二引数に渡される。アップロード
   *   に失敗した場合には、第一引数にErrorオブジェクトが返る。返る場合
   *   のあるエラーコードは次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   */
  uploadDocumentByPath(parentFolderPath, filepath, filename, rename, callback) {
    if ( typeof parentFolderPath !== 'string' ) {
      throw new TypeError('parentFolderPath must be a string');
    }
    if ( typeof filepath !== 'string' ) {
      throw new TypeError('filepath must be a string');
    }
    if ( typeof filename !== 'string' ) {
      throw new TypeError('filename must be a string');
    }
    if ( typeof rename !== 'boolean' ) {
      throw new TypeError('rename must be a boolean');
    }
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }

    if ( typeof filename !== 'string') {
      filename = path.parse(filepath).base;
    }

    // 転送先フォルダを作成した後、ファイルを転送する
    const self = this;
    this.createFolderRecursively_(parentFolderPath, function(error, parentFolderId, affectedFolderIds){
      if (error) {
        callback(error);
        self.terminateTransferState_();
        return;
      }
      self.uploadDocument_(parentFolderId, affectedFolderIds, filepath, filename, rename, false, false, callback);
    });
  }

  /**
   * Upload document.
   *
   * @param {string} parentFolderId The target folder to upload file.
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error, documentId, stamp)} callback
   *   The callback to get cert result. When succeed the documentId
   *   for the document that created is passed as a second argument,
   *   and the folderId for the parent folder of the document is
   *   passed as a third argument. When failed to upload an Error
   *   object will be returned to first argument.
   *   The error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに成功した場合には、作
   *   成されたファイルのdocumentIdが第二引数に渡される。アップロード
   *   に失敗した場合には、第一引数にErrorオブジェクトが返る。返る場合
   *   のあるエラーコードは次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   */
  uploadOverwriteDocumentById(documentId, filepath, stamp, callback) {
    this.uploadOverwriteDocumentByIdWithRetry_(documentId, filepath, stamp, false, callback);
    return;
  }

  /**
   * @private
   */
  uploadOverwriteDocumentByIdWithRetry_(documentId, filepath, stamp, reauthed, callback) {
    if ( typeof documentId !== 'string' ) {
      throw new TypeError('documentId must be a string');
    }
    if ( typeof filepath !== 'string' ) {
      throw new TypeError('filepath must be a string');
    }
    if ( typeof stamp !== 'string' ) {
      throw new TypeError('stamp must be a string');
    }
    if ( typeof callback !== 'function' ) {
      callback = this.defaultCallback;
    }
    
    var self = this;
    self.uploadFile_('PUT', '/documents/' + documentId + '/file', filepath, stamp, function(err, retStamp) {
      if ( err ) {
        if ( REAUTH_UPLOAD_OVERWRITE_DOCUMENT && ! reauthed &&
             err.mwCode === mwe.E_MW_WEBAPI_UNEXPECTED_STATUS &&
             REAUTH_STATUSES.indexOf(err.mwWebApiResCode) >= 0 ) {
          
          debug('reaauth upload overwrite document invoked by: ', err);
          self.connCtrl_.auth(function(autherr) {
            if ( autherr ) {
              // returning original error.
              callback(err);
              return;
            }
            self.uploadOverwriteDocumentByIdWithRetry_(documentId, filepath, stamp, true, callback);
          });
          return;
        }
        callback(err);
        // self.terminateTransferState_();
        return;
      }

      callback(null, documentId, retStamp);
      // self.terminateTransferState_();
    });
  }

  
  /**
   * Upload document.
   *
   * @param {string} parentFolderPath The target folder path to upload file.
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error, documentId, folderId, stamp)} callback
   *   The callback to get cert result. When succeed the documentId
   *   for the document that created is passed as a second argument,
   *   and the folderId for the parent folder of the document is
   *   passed as a third argument. When failed to upload an Error
   *   object will be returned to first argument.
   *   The error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに成功した場合には、作
   *   成されたファイルのdocumentIdが第二引数に渡される。アップロード
   *   に失敗した場合には、第一引数にErrorオブジェクトが返る。返る場合
   *   のあるエラーコードは次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   */
  uploadOverwriteDocumentByPath(parentFolderPath, filepath, filename, stamp, callback) {
    if ( typeof parentFolderPath !== 'string' ) {
      throw new TypeError('parentFolderPath must be a string');
    }
    if ( typeof filepath !== 'string' ) {
      throw new TypeError('filepath must be a string');
    }
    if ( typeof filename !== 'string' ) {
      throw new TypeError('filename must be a string');
    }
    if ( typeof stamp !== 'string' ) {
      throw new TypeError('stamp must be a string');
    }
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }

    if ( typeof filename !== 'string') {
      filename = path.parse(filepath).base;
    }

    // 転送先フォルダを作成した後、ファイルを転送する
    const self = this;
    this.resolvePath_(parentFolderPath + '/' + filename, function(err, data) {
      if ( err ) {
        callback(err);
        self.terminateTransferState_();
        return;
      }

      if ( data.entry_type !== 'document' ) {
        // [2016-10-18 15:02:04+09:00] kan.k: [TODO] Folder found when
        // expecting document.
        callback(mwe.genError(
          mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.'));
        self.terminateTransferState_();
      }
      
      self.uploadOverwriteDocumentById(data.entry_id, filepath, stamp, function(err, documentId, retStamp) {
        if ( err ) {
          callback(err);
          return;
        }
        callback(null, documentId, data.parent_folder_id, retStamp);
      });
    });
  }


  /**
   * パスに対応するフォルダかファイルのObjectを取得する。
   *
   * "GET /resolve/entry/{path}" 
   * 
   * @private
   * @param {string} targetpath
   * @param {function(?error, data)} callback 
   */
  resolvePath_(targetpath, callback) {
    const encodedPath = encodeURIComponent(targetpath);
    const self = this;
    this.callWebApi('GET', '/resolve/entry/' + encodedPath, null, function(err, data, status) {
      if ( err ) {
        callback(err);
        return;
      }

      if (status !== 200) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.',
          'GET', '/resolve/entry/' + encodedPath, status, data));
        return;
      }

      if ( typeof data.entry_id !== 'string' ||
           typeof data.entry_name !== 'string' ||
           typeof data.entry_type !== 'string' ||
           typeof data.entry_path !== 'string' ) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.',
          'GET', '/resolve/entry/' + encodedPath, status, data));
      }

      callback(null, data);
    });
  }

  /**
   * ドキュメントを作成して、ファイルをアップロードする。
   *
   * @private
   * @param {string} parentFolderId The target folder to upload file.
   * @param {string} filePath The full path to the file to upload.
   * @param {string} fileName A filename to be put on opponent device.
   * @param {boolean} rename Whether resolve conflict file name or not.
   * @param {function(?Error, documentId, folderId, stamp)} callback
   *   The callback to get cert result. When succeed the documentId
   *   for the document that created is passed as a second argument,
   *   and the folderId for the parent folder of the document is
   *   passed as a third argument. When failed to upload an Error
   *   object will be returned to first argument.
   */
  uploadDocument_(parentFolderId, affectedFolderIds, filePath, fileName, rename, reauthed, retried, callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    const self = this;
    if ( ! rename ) {
      this.createDocument_(parentFolderId, fileName, function (err, documentId){
        if (err) {
          callback(err);
          self.terminateTransferState_();
          return;
        }

        self.uploadFile_('PUT', '/documents/' + documentId + '/file', filePath, null, function(err, stamp) {
          if (err) {
            if ( REAUTH_UPLOAD_DOCUMENT && ! reauthed &&
                 err.mwCode === mwe.E_MW_WEBAPI_UNEXPECTED_STATUS &&
                 REAUTH_STATUSES.indexOf(err.mwWebApiResCode) >= 0 ) {
              
              debug('reaauth upload document invoked by: ', err);
              self.connCtrl_.auth(function(autherr) {
                if ( autherr ) {
                  // returning original err.
                  callback(err);
                  return;
                }
                self.uploadDocument_(parentFolderId, affectedFolderIds, filePath, fileName, rename, true, retried, callback);
              });
              return;
            }
            if ( RETRY_UPLOAD_DOCUMENT && ! retried &&
                 err.mwCode === mwe.E_MW_WEBAPI_ERROR ) {
              debug('retry upload document invoked by: ', err);
              self.uploadDocument_(parentFolderId, affectedFolderIds, filePath, fileName, rename, reauthed, true, callback);
              return;
            }
            callback(err);
            return;
          }
          // callback(null, documentId, parentFolderId, stamp);
          // to get file name.
          self.callWebApi('GET', '/documents/' + documentId, null, (err, data, status) => {
            if ( err ) {
              callback(err);
              return;
            }
            if (status !== 200) {
              callback(mwe.genWebApiError(
                mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'GET', '/documents/' + documentId,
                status, data));
              return;
            }
            if ( typeof data.entry_name !== 'string' ) {
              callback(mwe.genWebApiError(
                mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'entry_name is not set.', 'GET', '/documents/' + documentId,
                status, data));
              return;
            }
            if ( typeof data.entry_path !== 'string' ) {
              callback(mwe.genWebApiError(
                mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'entry_path is not set.', 'GET', '/documents/' + documentId,
                status, data));
              return;
            }
            var lsindex = data.entry_path.lastIndexOf('/');
            if ( lsindex < 0 ) {
              callback(mwe.genWebApiError(
                mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'entry_path does not contain "/".', 'GET', '/documents/' + documentId,
                status, data));
            }
            var parentFolderPath = data.entry_path.slice(0, lsindex);
            callback(null, documentId, parentFolderId, affectedFolderIds, stamp, data.entry_name, parentFolderPath);
          });
        });
      });
      return
    }
    
    this.createDocumentWithUploadableName_(parentFolderId, fileName, function (err, documentId){
      if (err) {
        callback(err);
        self.terminateTransferState_();
        return;
      }

      self.uploadFile_('PUT', '/documents/' + documentId + '/file', filePath, null, function(err, stamp) {
        if (err) {
          if ( REAUTH_UPLOAD_DOCUMENT && ! reauthed &&
               err.mwCode === mwe.E_MW_WEBAPI_UNEXPECTED_STATUS &&
               REAUTH_STATUSES.indexOf(err.mwWebApiResCode) >= 0 ) {
            
            debug('reaauth upload document invoked by: ', err);
            self.connCtrl_.auth(function(autherr) {
              if ( autherr ) {
                // returning original error.
                callback(err);
                return;
              }
              self.uploadDocument_(parentFolderId, affectedFolderIds, filePath, fileName, rename, true, retried, callback);
            });
            return;
          }
          if ( RETRY_UPLOAD_DOCUMENT && ! retried &&
               err.mwCode === mwe.E_MW_WEBAPI_ERROR ) {
            debug('retry upload document invoked by: ', err);
            self.uploadDocument_(parentFolderId, affectedFolderIds, filePath, fileName, rename, reauthed, true, callback);
            return;
          }
          callback(err);
          return;
        }
        callback(null, documentId, parentFolderId, affectedFolderIds, stamp);
      });
    });
  }

  /**
   * ドキュメントを作成する。
   * ただし、名前重複時には連番付きの名前でドキュメントを作成する。
   * 
   * @private
   * @param {string} parentFolderId 転送先フォルダのフォルダのID
   * @param {string} fileName 転送するドキュメントのファイル名
   * @param {function(?Error, documentId)} callback 
   */
  createDocumentWithUploadableName_(parentFolderId, fileName, callback) {
    // 使用可能なドキュメント名を取得する
    const self = this;
    this.getUploadableFileName_(parentFolderId, fileName, function(error, uploadableFileName){
      if (error) {
        callback(error);
        return;
      }

      // ドキュメントを作成する
      self.createDocument_(parentFolderId, uploadableFileName, callback);
    });
  }

  /**
   * アップロード先として、使用可能なファイル名を取得する
   * 
   * @private
   * @param {string} parentFolderId フォルダ作成先のフォルダのID
   * @param {string} fileName 作成するファイルの名前
   * @param {function(?Error, availableFileName)} callback 
   */
  getUploadableFileName_(parentFolderId, fileName, callback) {
    // 作成するドキュメントと同名のエントリが存在しないかを確認する
    const self = this;
    this.childEntryExists_(parentFolderId, fileName, function (error, exists, entryInfo){
      if (error) {
        callback(error);
        return;
      }

      if (!exists) {
        // 同名のエントリが存在しない場合
        callback(null, fileName);
        return;
      }

      // 同名のエントリが既に存在する場合

      // 指定されたファイル名に既に連番が含まれていた場合には、ベースのファイル名と拡張子を抜き出す
      //  例) "file (1).pdf"  ⇒ "file", ".pdf"
      //  例) "file(1) .pdf"  ⇒ null
      //  例) "file(1).pdf"   ⇒ null
      //  例) "file (01).pdf" ⇒ null
      let fileBaseName;
      let fileExt;
      let result = fileName.match(/^(.*) \([1-9][0-9]*\)(\..*)$/);
      if (result) {
        // ファイル名に連番が含まれていた場合
        fileBaseName = result[1];
        fileExt = result[2];
      }
      else {
        // ファイル名に連番が含まれていなかった場合
        //  例) "file.pdf"  ⇒ "file", ".pdf"
        result = fileName.match(/^(.*)(\..*)$/);
        fileBaseName = result[1];
        fileExt = result[2];
      }
      
      // 重複しない連番付きのフォルダ名を取得する
      self.getUploadableFileNameWithIndex_(parentFolderId, fileBaseName, fileExt, 1, callback);
    });
  }

  /**
   * アップロード先のファイル名が既存のファイル名やフォルダ名と重複した際に、連番付きのファイル名を作成する。
   * 
   * @private
   * @param {string} parentFolderId 転送先フォルダのフォルダのID
   * @param {string} fileBaseName 転送するドキュメントのファイル名
   * @param {string} fileExt 転送するドキュメントのファイルの拡張子
   * @param {string} index ファイル名に追加する番号
   * @param {function(?Error, fileName)} callback 
   */
  getUploadableFileNameWithIndex_(parentFolderId, fileBaseName, fileExt, index, callback) {
    // 連番付きのファイル名を用意する
    const fileName = fileBaseName + ' (' + index + ')' + fileExt;

    // 再帰的に未使用のファイル名を探す
    const self = this;
    this.childEntryExists_(parentFolderId, fileName, function (error, exists, entryInfo){
      if (error) {
        callback(error);
        return;
      }

      if (!exists) {
        // 同名のエントリが存在しない場合
        callback(null, fileName);
        return;
      }

      self.getUploadableFileNameWithIndex_(parentFolderId, fileBaseName, fileExt, ++index, callback);
    });
  }

  /**
   * ドキュメントを作成する。
   * "POST /documents"
   * 
   * @private
   * @param {string} parentFolderId フォルダ作成先のフォルダのID
   * @param {string} fileName 作成するドキュメントのファイル名
   * @param {function(?Error, documentId)} callback
   */
  createDocument_(parentFolderId, fileName, callback) {
    var param = {
      parent_folder_id: parentFolderId,
      file_name: fileName,
      document_source: ''
    };

    const self = this;
    this.callWebApi('POST', '/documents', param, function(err, data, status) {
      if ( err ) {
        callback(err);
        return;
      }

      if ( status === 200 ) {
        // ドキュメント作成に成功した場合
        const documentId = data.document_id;
        if ( typeof documentId !== 'string' ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.', 'POST', '/documents', status, data));
          return;
        }
        callback(null, documentId);
      }
      else {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'POST', '/documents', status, data));
        return;
      }
    });
  }

  /**
   * 指定されたフォルダパスに対して、デバイス上に存在しないフォルダを作成する。
   * 
   * @private
   * @param {string} folderPath 作成対象のフォルダパス
   * @param {function(?Error, folderId)} callback 
   */
  createFolderRecursively_(folderPath, callback) {

    if (typeof folderPath !== 'string') {
      throw new TypeError('folderPath must be a string');      
    }
    if (typeof callback !== 'function') {
      throw new TypeError('callback must be a function');      
    }
    
    let folderPathArray = folderPath.split('/');
    if (folderPathArray.length === 0 || folderPathArray[0] !== 'Document') {
      // フォルダパスは'Document/'で始まること
      throw new Error('invalid folderPath : ' + folderPath);      
    }
    if (folderPathArray[folderPathArray.length - 1] === '') {
      // フォルダパスの末尾が'/'の場合には末尾の要素を削除する
      folderPathArray.pop();
    }

    const dstFolderPath = folderPathArray.join('/');

    // フォルダパス上で存在するフォルダを探す
    const self = this;
    this.findFolderRecursively_(dstFolderPath, function(error, folder){
      if (error) {
        callback(error);
        return;
      }

      if (dstFolderPath === folder.path) {
        // dstFolderPath が既にデバイス上に存在するため作成する必要はない
        callback(null, folder.id);
        return;
      }

      // 未だ作成されていないフォルダのパスを抜き出す
      const childFolerPath = dstFolderPath.slice(folder.path.length);
      let childFolderPathArray = childFolerPath.split('/');
      if (childFolderPathArray[0] === '') {
        // フォルダパスの先頭が'/'の場合には先頭の要素を削除する
        childFolderPathArray.shift();
      }

      // 階層的に子フォルダを作成する
      let parentFolderIdArray = [folder.id];
      self.createChildFolderRecursively_(folder.id, childFolderPathArray, parentFolderIdArray, function(error, folderId){
        if (error) {
          callback(error);
          return;
        }
        callback(null, folderId, parentFolderIdArray);
      });
    });
  }

  /**
   * 階層的にアップロード先の子フォルダを作成する。
   *
   * @private
   * @param {string} parentFolderId フォルダ作成開始時のフォルダのID
   * @param {string} childFolderPathArray 階層化された子フォルダの名前の配列
   * @param {string} createdFolderIdArray 作成された子フォルダのIDの配列
   * @param {function(?Error, folderId)} callback 
   */
  createChildFolderRecursively_(parentFolderId, childFolderPathArray, createdFolderIdArray, callback) {
    // この階層で作成するフォルダ名を取り出す
    const folderName = childFolderPathArray.shift();

    // 再帰的に子フォルダを作成する
    const self = this;
    this.createFolderWithNewNameIfConflicted_(parentFolderId, folderName, function (error, folderId) {
      if (error) {
        callback(error);
        return;
      }
      createdFolderIdArray.push(folderId);

      if (childFolderPathArray.length === 0) {
        // 全てのフォルダの作成が完了した場合
        callback(null, folderId);
        return;
      }

      self.createChildFolderRecursively_(folderId, childFolderPathArray, createdFolderIdArray, callback);
    });
  }

  /**
   * アップロード先のフォルダを作成する。
   * ただし、名前重複時には連番付きのフォルダ名でフォルダを作成する。
   * 
   * @private
   * @param {string} parentFolderId フォルダ作成先のフォルダのID
   * @param {string} folderName 作成するフォルダの名前
   * @param {function(?Error, folderId)} callback 
   */
  createFolderWithNewNameIfConflicted_(parentFolderId, folderName, callback) {
    // アップロード先として使用可能なフォルダ名を取得する
    const self = this;
    this.getUploadableFolderName_(parentFolderId, folderName, function(error, uploadableFolderName, folderId){
      if (error) {
        callback(error);
        return;
      }

      if (folderId) {
        // 使用可能なフォルダが既に存在した場合には、そのフォルダを使用する
        callback(null, folderId);
        return;
      }

      // 新規にフォルダを作成する
      self.createFolder_(parentFolderId, uploadableFolderName, callback);
    });
  }

  /**
   * アップロード先として、使用可能なフォルダ名を取得する。
   * 
   * @private
   * @param {string} parentFolderId フォルダ作成先のフォルダのID
   * @param {string} folderName 作成するフォルダの名前
   * @param {function(?Error, folderName, folderId)} callback 
   */
  getUploadableFolderName_(parentFolderId, folderName, callback) {

    // 作成するフォルダと同名のファイルが存在しないかを確認する
    const self = this;
    this.childEntryExists_(parentFolderId, folderName, function (error, exists, entryInfo){
      if (error) {
        callback(error);
        return;
      }

      if (!exists) {
        // 同名のエントリが存在しない場合
        callback(null, folderName);
        return;
      }

      // 同名のエントリが既に存在する場合

      // 指定されたフォルダ名に既に連番が付いていた場合には、ベースのフォルダ名を抜き出す
      //  例) "folder (1)"  ⇒ "folder"
      //  例) "folder(1)"   ⇒ null
      //  例) "folder (01)" ⇒ nulll
      let folderBaseName = folderName;
      const result = folderName.match(/^(.*) \([1-9][0-9]*\)$/);
      if (result) {
        folderBaseName = result[1];
      }
      
      // 重複しない連番付きのフォルダ名を取得する
      self.getUploadableFolderNameWithIndex_(parentFolderId, folderBaseName, 1, callback);
    });
  }

  /**
   * アップロード先のフォルダ名が既存のファイル名と重複した際に、連番付きのフォルダ名を作成する。
   * 
   * @private
   * @param {string} parentFolderId フォルダ作成先のフォルダのID
   * @param {string} folderBaseName 作成するフォルダの名前
   * @param {string} index フォルダ名に追加する番号
   * @param {function(?Error, folderName, folderId)} callback 
   */
  getUploadableFolderNameWithIndex_(parentFolderId, folderBaseName, index, callback) {

    // 連番付きのフォルダ名を用意する
    const folderName = folderBaseName + ' (' + index + ')';

    // 再帰的に未使用のフォルダ名を探す
    const self = this;
    this.childEntryExists_(parentFolderId, folderName, function (error, exists, entryInfo){
      if (error) {
        callback(error);
        return;
      }

      if (!exists) {
        // 同名のエントリが存在しない場合
        callback(null, folderName);
        return;
      }

      if (entryInfo && entryInfo.entry_type === 'folder') {
        // 同名のフォルダが存在した場合には、そのフォルダを使用する
        callback(null, folderName, entryInfo.entry_id);
        return;
      }

      self.getUploadableFolderNameWithIndex_(parentFolderId, folderBaseName, ++index, callback);
    });
  }

  /**
   * フォルダを作成する。
   * "POST /folders"
   * 
   * @private
   * @param {string} parentFolderId フォルダ作成先のフォルダのID
   * @param {string} folderName 作成するフォルダの名前
   * @param {function(?Error, folderId)} callback 
   */
  createFolder_(parentFolderId, folderName, callback) {
    var param = {
      parent_folder_id: parentFolderId,
      folder_name: folderName
    };

    const self = this;
    this.callWebApi('POST', '/folders', param, function(err, data, status) {
      if ( err ) {
        callback(err);
        return;
      }

      if ( status === 200 ) {
        // フォルダ作成に成功した場合
        const folderId = data.folder_id;
        if ( typeof folderId !== 'string' ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.', 'POST', '/folders', status, data));
          return;
        }
        callback(null, folderId);
      }
      else {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'POST', '/folders', status, data));
        return;
      }
    });
  }

  /**
   * 指定されたフォルダパスから再帰的に階層を上って、デバイス上に存在するフォルダを探し、
   * そのフォルダのパスとIDを取得する。
   * 
   * @private
   * @param {string} folderPath 検索対象のフォルダのパス
   * @param {function(?error, folder} callback 
   */
  findFolderRecursively_(folderPath, callback) {
    const self = this;
    this.findFolder_(folderPath, function (error, isFound, folderId) {
      if (error) {
        callback(error);
        return;
      }
      if (isFound) {
        // デバイス上に folderPath が見つかった場合
        const folder = {id:folderId, path:folderPath};
        callback(null, folder);
        return;
      }

      // デバイス上に folderPath が見つからなかった場合
      //  ⇒ 繰り返し階層を上って、存在するフォルダを探す
      
      // 親フォルダのパスを取得する
      let folderPathArray = folderPath.split('/');
      folderPathArray.pop();
      if (folderPathArray.length === 0) {
        // フォルダパスは'Document/'で始まる必要がある
        callback(new Error('invalid folderPath : ' + folderPath));
        return;
      }
      const parentFolderPath = folderPathArray.join('/');

      // 再帰的に検索する
      self.findFolderRecursively_(parentFolderPath, callback);
    });
  }

  /**
   * フォルダパスから当該フォルダを探して、フォルダのIDを取得する。
   * "GET /resolve/entry/{path}" 
   * 
   * @private
   * @param {string} folderPath フォルダ作成先のフォルダのID
   * @param {function(?error, isFound, folderId)} callback 
   */
  findFolder_(folderPath, callback) {
    const encodedFolderPath = encodeURIComponent(folderPath);
    const self = this;
    this.callWebApi('GET', '/resolve/entry/' + encodedFolderPath, null, function(err, data, status) {
      if ( err ) {
        callback(err);
        return;
      }

      if (status === 200) {
        const isFound = (data.entry_type === 'folder');
        const entryId = data.entry_id;
        if ( typeof entryId !== 'string' ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.', 'GET', '/resolve/entry/' + folderPath, status, data));
          return;
        }
        callback(null, isFound, entryId);
        return;
      }
      else if (status === 404 && data.error_code === '40401') {
        const isFound = false;
        callback(null, isFound);
        return;        
      }
      else {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'GET', '/resolve/entry/' + folderPath, status, data));
        return;
      }
    });
  }

  /**
   * 親フォルダ内に、特定の名前の子エントリが存在するか否かを確認する。
   * 
   * @private
   * @param {string} parentFolderId 親フォルダのID
   * @param {string} childEntryName 子エントリの名前
   * @param {function(?error, exists, entryInfo)} callback 
   */
  childEntryExists_(parentFolderId, childEntryName, callback) {
    const self = this;
    this.getFolderPath_(parentFolderId, function (error, parentFolderPath){
      if (error) {
        callback(error);
        return;
      }

      const childEntryPath = parentFolderPath + childEntryName;
      self.entryExists_(childEntryPath, callback);
    });
  }

  /**
   * 親フォルダ内に、特定の名前の子フォルダが存在するか否かを確認する。
   * 
   * @private
   * @param {string} parentFolderId 親フォルダのID
   * @param {string} childFolderName 子フォルダの名前
   * @param {function(?error, exists)} callback
   */
  childFolderExists_(parentFolderId, childFolderName, callback) {
    const self = this;
    this.getFolderPath_(parentFolderId, function (error, parentFolderPath){
      if (error) {
        callback(error);
        return;
      }

      const childFolderPath = parentFolderPath + '/' + childFolderName;
      self.entryExists_(childFolderPath, function(error, entryInfo) {
        if (error) {
          callback(error);
          return;
        }
        callback(null, childFolderPath);
      });
    });
  }


  /**
   * フォルダのIDからフォルダのパスを取得する。
   * "GET /resolve/entry/{path}" 
   * 
   * @private
   * @param {string} folderId フォルダのID
   * @param {function(?error, folderPath)} callback 
   */
  getFolderPath_(folderId, callback) {
    const self = this;
    this.callWebApi('GET', '/folders/' + folderId, null, function(err, data, status) {
      if ( err ) {
        callback(err);
        return;
      }

      if (status === 200) {
        const folderPath = data.entry_path;
        if ( typeof folderPath !== 'string' ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.', 'GET', '/folders/' + folderId, status, data));
          return;
        }
        callback(null, folderPath);
        return;
      }
      else {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'GET', '/folders/' + folderId, status, data));
        return;
      }
    });
  }

  /**
   * ドキュメントまたはフォルダのパスから当該エントリの有無を確認する。
   * "GET /resolve/entry/{path}"
   *
   * @private
   * @param {string} entryPath ドキュメントまたはフォルダのパス
   * @param {function(?error, exists, entryInfo)} callback
   */
  entryExists_(entryPath, callback) {
    const encodedEntryPath = encodeURIComponent(entryPath);
    const self = this;
    this.callWebApi('GET', '/resolve/entry/' + encodedEntryPath, null, function(err, data, status) {
      if ( err ) {
        callback(err);
        return;
      }

      if (status === 200) {
        const exists = true;
        const entryInfo = data;
        if ( !entryInfo || typeof entryInfo.entry_type !== 'string') {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.', 'GET', '/resolve/entry/' + entryPath, status, data));
          return;
        }
        callback(null, exists, entryInfo);
        return;
      }
      else if (status === 404 && data.error_code === '40401') {
        const exists = false;
        callback(null, exists);
        return;
      }
      else {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'GET', '/resolve/entry/' + entryPath, status, data));
        return;
      }
    });
  }

  /**
   * Upload note template
   * 
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error)} callback The callback to get cert
   *   result. When failed to upload an Error object will be
   *   returned to first argument. The error code of the Error object
   *   are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに失敗した場合には、第
   *   一引数にErrorオブジェクトが返る。返る場合のあるエラーコードは次
   *   のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   */
  uploadNoteTemplate(filepath, filename, callback) {
    if ( typeof callback !== 'function' ) {
      callback = this.defaultCallback;
    }
    // var parentFolderId = this.currentFolderId_;

    // callWebApi(method, apipath, body, callback
    if ( typeof filename !== 'string') {
      filename = path.parse(filepath).base;
    }

    var req = { template_name: filename };

    var self = this;
    this.callWebApi('POST', '/viewer/configs/note_templates/', req, function(err, data, status) {
      // console.log('END with err: ', err, ', data:', data);
      if ( err ) {
        callback(err);
        // self.terminateTransferState_();
        return;
      }
      if ( status !== 200 ) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', 'POST', '/viewer/configs/note_templates/',
          status, data));
        // self.terminateTransferState_();
        return;
      }
      var ntId = data.note_template_id;
      if ( typeof ntId !== 'string' ) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.', 'POST', '/viewer/configs/note_templates/',
          status,  data));
        // self.terminateTransferState_();
        return;
      }

      self.uploadFile_('PUT', '/viewer/configs/note_templates/' + ntId + '/file', filepath, null, function(err, stamp) {
        if ( err ) {
          callback(err);
          // self.terminateTransferState_();
          return;
        }
        callback(null, ntId);
        // self.terminateTransferState_();
      });
    });
  }

  /**
   * Upload firmware
   * 
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error)} callback The callback to get cert
   *   result. When failed to upload an Error object will be
   *   returned to first argument. The error code of the Error object
   *   are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに失敗した場合には、第
   *   一引数にErrorオブジェクトが返る。返る場合のあるエラーコードは次
   *   のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   */
  uploadFirmware(filepath, filename, callback) {
    if ( typeof callback !== 'function' ) {
      callback = this.defaultCallback;
    }
    // var parentFolderId = this.currentFolderId_;

    // callWebApi(method, apipath, body, callback
    if ( typeof filename !== 'string') {
      filename = path.parse(filepath).base;
    }

    var self = this;
    this.uploadFile_('PUT', '/system/controls/update_firmware/file', filepath, null, function(err, stamp) {
      if ( err ) {
        callback(err);
        // self.terminateTransferState_();
        return;
      }
      callback(null);
      // self.terminateTransferState_();
    });
  }

  /**
   * Get cert content by filepath.
   * <br>
   * ファイルパスで証明書の内容を読み込む関数。
   *
   * @param {string} filepath The full path to the file to read.
   *   <br>
   *   読み込むファイルへのフルパス。
   *
   * @param {function(Error, data)} callback The callback to get cert
   *   result. When failed to read an Error object will be returned to
   *   first argument. When succeed, the base64 encoded data will be
   *   returned as 2nd argument.
   *   <br>
   *   結果を受け取るCallback関数。取得に失敗した場合には、第一引数に
   *   Errorオブジェクトが返る。成功した場合には、第二引数にbase64
   *   encodeされたデータが返る。
   */
  getCert(filepath, callback) {
    fs.readFile(filepath, 'binary', function(err, data) {
      if ( err ) {
        callback(mwe.genError(
          mwe.E_MW_FILE_READ_LOCAL_FAILED, 'Failed to read file.', err));
        return;
      }
      var encoded = btoa(data);
      callback(null, encoded);
      return;
    });
  }
    
  ///////////////////////////////////
  ///   Upload Download
  ///////////////////////////////////

  // [2016-07-14 21:41:32+09:00] kan.k: byteTotal_ と byteTransferred
  // および、Cancelは、ここより下のメソッド管理するState

  /**
   * @private
   *
   * @param {string} checkApiPath Nullの場合には、特にdataを返さない。
   */
  prepareForDownlod_(checkApiPath, length, callback) {
    if ( this.bytesTotal_ !== null ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'Transfer already running.'));
      return;
    }
    this.bytesTotal_ = length;
    this.bytesTransferred_ = 0;
    this.bytesTransferredCompleted_ = 0;
    var baseUrl = this.connCtrl_.getBaseUrl();
    if ( typeof baseUrl !== 'string' ) {
      callback(mwe.genError(mwe.E_MW_DEVICE_NOT_FOUND, 'Base URL is not a string.'));
      this.terminateTransferState_();
      return;
    }
    if ( checkApiPath === null ) {
      callback(null, null, null);
      return;
    }
    var self = this;
    this.callWebApi('GET', checkApiPath, null, function(err, data, status) {
      if ( err ) {
        callback(err);
        self.terminateTransferState_();
        return;
      }
      if ( status !== 200 ) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.',
          'GET', checkApiPath, status, data));
        self.terminateTransferState_();
        return;
      }
      // [2016-10-24 16:40:59+09:00] kan.k: status を返す必要があるの
      // か？
      callback(null, data, status);
    });
  }

  /**
   * @private
   *
   * @param {number} length 想定されるコンテンツのサイズ。もし設定され
   *   ている場合には、この長さまでファイルのダウンロードを試行する。
   *   また、Content-Rangeが取得できて正しくParseできた場合には、
   *   Content-Rangeの値とも比較を行い、指定したlengthと異なる数字を返
   *   した場合にはエラーとして終了させる。nullを設定した場合には、最
   *   初のHTTP Responseに存在する、Content-Rangeヘッダーの
   *   instance-lengthの値をlengthとして採用する。そして以後のHTTP
   *   Responseで、同instance-lengthの値が変化した場合にはエラーとして
   *   ダウンロードを中断する。
   */
  downloadFile_(method, apiPath, checkApiPath, length, filePath, callback) {
    var self = this;
    this.prepareForDownlod_(checkApiPath, length, function (err, data, status) {
      if (err) {
        callback(err);
        return;
      }

      var checkJson = data;
      fs.open(filePath, 'w', function (err, fd) {
        if (err) {
          callback(mwe.genError(
            mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to open write file.', err));
          self.terminateTransferState_();
          return;
        }
        self.downloadFilePartial_(method, apiPath, checkApiPath, checkJson, null, 0, length,
          function (buffer, isLast, callback) {
            fs.write(fd, buffer, 0, buffer.length, function (err) {
              if (err) {
                callback(mwe.genError(
                  mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to write file.', err));
                return;
              }
              callback(null);
            })
          },
          function (err, stamp) {
            fs.close(fd, function () {  // fs.close() のエラーは無視する
              if (err) {
                fs.unlink(filePath, function () {  // fs.unlink() のエラーは無視する
                  callback(err);
                  self.terminateTransferState_();
                });
                return;
              }
              callback(null, stamp, filePath);
              self.terminateTransferState_();
            });
          });
      });
    });
  }

  /**
   * @private
   */
  downloadFileAsBinary_(method, apiPath, checkApiPath, length, output, callback) {
    const self = this;
    this.prepareForDownlod_(checkApiPath, length, function (err, data, status) {
      if (err) {
        callback(err);
        return;
      }
      const checkJson = data;
      self.downloadFilePartial_(method, apiPath, checkApiPath, checkJson, null, 0, length,
      function (buffer, isLast, callback) {
        output(buffer, isLast);
        callback(null);
      },     
      function (err, stamp) {
        if (err) {
          if (err && err.mwCode === mwe.E_MW_CANCELLED) {
            callback(err);
            return;
          }
          callback(err);
          self.terminateTransferState_();
          return;
        }
        callback(null, stamp);
        self.terminateTransferState_();
      });
    });
  }

  /**
   * @private
   */
  downloadFilePartial_(method, apiPath, checkApiPath, checkJson, checkEtag, offset, length, output, callback) {
    if ( this.checkCancelling_(callback) ) {
      return;
    }
    var baseUrl = this.connCtrl_.getBaseUrl();
    if ( typeof baseUrl !== 'string' ) {
      callback(mwe.genError(mwe.E_MW_DEVICE_NOT_FOUND, 'Base URL is not a string.'));
      return;
    }
    var apiUrl = baseUrl + apiPath;
    var xhrReq = new XMLHttpRequest();
    xhrReq.timeout = XHR_TIMEOUT_TRANSFER;
    xhrReq.responseType = 'arraybuffer';
    xhrReq.open(method, apiUrl, true);
    var self = this;

    var callbackHandled = false;
    
    xhrReq.ontimeout = function(err) {
      if ( callbackHandled ) {
        return;
      }
      callbackHandled = true;
      
      self.xhrRequest_ = null;
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      callback(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_ERROR, 'XHR timeout occured.', method, apiPath, xhrReq.status, err));
      return;
    };
    
    xhrReq.onabort = function(err) {
      if ( callbackHandled ) {
        return;
      }
      callbackHandled = true;
      
      self.xhrRequest_ = null;
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      callback(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_ERROR, 'XHR abort occured.', method, apiPath, xhrReq.status, err));
      return;
    };
    
    xhrReq.onerror = function(err) {
      if ( callbackHandled ) {
        return;
      }
      callbackHandled = true;
      
      self.xhrRequest_ = null;
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      callback(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_ERROR, 'XHR error occured.', method, apiPath, xhrReq.status, err));
      return;
    };
    
    xhrReq.onprogress = function(ev) {
      if ( length === null ) {
        var contentRange = xhrReq.getResponseHeader('Content-Range');
        var contentRangeInstanceLength = self.parseContentRangeInstanceLength_(contentRange);
        if ( typeof contentRangeInstanceLength === 'number' ) {
          length = contentRangeInstanceLength;
          self.bytesTotal_ = length;
        }
      }
      
      // debugger;
      // self.bytesTransferred_ = self.bytesTransferredCompleted_ + ev.loaded;
      if ( ev.loaded > CHUNKLEN ) {
        self.bytesTransferred_ = self.bytesTransferredCompleted_ + CHUNKLEN;
      } else {
        self.bytesTransferred_ = self.bytesTransferredCompleted_ + ev.loaded;
      }
      if ( typeof self.bytesTotal_ === 'number' && self.bytesTransferred_ > self.bytesTotal_ ) {
        self.bytesTransferred_ = self.bytesTotal_;
      }
    }
    
    xhrReq.setRequestHeader('Range', 'bytes=' + offset.toString() + '-' + (offset + CHUNKLEN - 1).toString());
    
    xhrReq.onload = function() {
      if ( callbackHandled ) {
        return;
      }
      callbackHandled = true;
      
      self.xhrRequest_ = null;
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      
      if ( xhrReq.status !== 200 && xhrReq.status !== 206 ) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.',
          method, apiPath, xhrReq.status, xhrReq.response));
        return;
      }
      var len = parseInt(xhrReq.getResponseHeader('Content-Length'), 10);
      if ( isNaN(len) ) {
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Content-Length is not a number.',
          method, apiPath, xhrReq.status, xhrReq.response));
        return;
      }

      // Detect change of instance-length in Content-Range.
      // ex) 
      //   Content-Range: bytes 0-100/200
      //                              ^^^ this part.
      // When no valid Content-Range with 'bytes' founds, the values
      // will just be ignored. Will not be checked.
      var contentRange = xhrReq.getResponseHeader('Content-Range');
      var contentRangeInstanceLength = self.parseContentRangeInstanceLength_(contentRange);
      if ( typeof contentRangeInstanceLength === 'number' ) {
        if ( length === null ) {
          length = contentRangeInstanceLength;
          self.bytesTotal_ = length;
        } else if ( contentRangeInstanceLength !== length ) {
          callback(mwe.genError(
            mwe.E_MW_FILE_REMOTE_MODIFIED, 'File modified while downloading.',
            { originalHeader: { length: length }, modifiedHeader: { contentRange: contentRange } }));
          return;
        }
      }
      
      if ( length === null ) {
        callback(mwe.genError(
          mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Content-Range header could not be parsed',
          { header: { contentRange: contentRange } }));
        return;
      }
      
      var etag = xhrReq.getResponseHeader('ETag');
      if ( typeof checkEtag === 'string' ) {
        if ( etag !== checkEtag ) {
          callback(mwe.genError(
            mwe.E_MW_FILE_REMOTE_MODIFIED, 'ETag change detected. File modified while downloading.',
            { originalHeader: { ETag: checkEtag }, modifiedHeader: { ETag: etag } }));
          // [2016-09-08 19:06:43+09:00] kan.k: [TODO] following line may be removed.
          // self.terminateTransferState_();
          return;
        }
      } else {
        if ( typeof etag === 'string' ) {
          checkEtag = etag;
          // checking etag format against checkJson.file_revision.
          if ( checkJson && typeof checkJson.file_revision === 'string' ) {
            if ( self.fileRevisionFromEtag_(etag) !== checkJson.file_revision ) {
              callback(mwe.genError(
                mwe.E_MW_FILE_REMOTE_MODIFIED, 'ETag format does not match file_revision.',
                { originalHeader: { ETag: checkEtag }, modifiedHeader: { ETag: etag } }));
              return;
            }
          }
        }
      }

      const transferred = offset + len;
      self.bytesTransferred_ = transferred;
      self.bytesTransferredCompleted_ = transferred;
      var arrayBuf = xhrReq.response;
      var buf = Buffer.from(arrayBuf);

      if ( checkJson === null ) {
        const isLast = (transferred >= length);
        output(buf, isLast, function (err) {
          if (err) {
            callback(err);
            return;
          }
          if (isLast) {
            var stamp = null;
            if ( typeof etag === 'string' ) {
              stamp = self.fileRevisionFromEtag_(etag);
            }
            callback(null, stamp);
            return;
          }

          self.downloadFilePartial_(
            method, apiPath, checkApiPath, checkJson,
            checkEtag, transferred, length, output, callback);
        });
        return;
      }

      self.callWebApi('GET', checkApiPath, null, function(err, data, status) {
        if ( err ) {
          callback(err);
          return;
        }
        if ( status !== 200 ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.',
            'GET', checkApiPath, status, data));
          return;
        }
        if ( JSON.stringify(checkJson) !== JSON.stringify(data) ) {
          callback(mwe.genError(
            mwe.E_MW_FILE_REMOTE_MODIFIED, 'File modified while downloading.',
            { original: checkJson, modified: data }));
          return;
        }

        const isLast = (transferred >= length);
        output(buf, isLast, function (err) {
          if (err) {
            callback(err);
            return;
          }
          if (isLast) {
            var stamp = null;
            if ( data && typeof data.file_revision === 'string' ) {
              stamp = data.file_revision;
            }
            callback(null, stamp);
            return;
          }

          self.downloadFilePartial_(method, apiPath, checkApiPath, checkJson, checkEtag, transferred, length, output, callback);
        });
      });
    }
    
    xhrReq.setRequestHeader('Content-Type', 'application/json');
    this.xhrRequest_ = xhrReq;
    xhrReq.send();
  }

  parseContentRangeInstanceLength_(contentRange) {
    if ( typeof contentRange !== 'string' ) {
      return null;
    }
      
    if ( contentRange.indexOf('bytes ') !== 0 ) {
      return null;
    }
    
    var slashpos = contentRange.indexOf('/', 6);
    if ( slashpos < 0 ) {
      return null;
    }
    
    var contentRangeInstanceLength = parseInt(contentRange.slice(slashpos + 1));
    if ( isNaN(contentRangeInstanceLength) ) {
      return null;
    }
    
    return contentRangeInstanceLength;
    // if ( length === null ) {
    //   length = contentRangeInstanceLength;
    //   self.bytesTotal_ = length;
    // } else if ( contentRangeInstanceLength !== length ) {
    //   callback(mwe.genError(
    //     mwe.E_MW_FILE_REMOTE_MODIFIED, 'File modified while downloading.',
    //     { originalHeader: { length: length }, modifiedHeader: { contentRange: contentRange } }));
    //   return;
    // }
  }

  fileRevisionFromEtag_(etag) {
    if ( typeof etag !== 'string' ) {
      return null;
    }
    if ( etag.length < 4 ) {
      return null;
    }
    if ( etag[0] !== '"' ) {
      return null;
    }
    if ( etag[etag.length-1] !== '"' ) {
      return null;
    }
    
    if ( etag[1] !== 'R' ) {
      return null;
    }
    var hyphenIndex = etag.indexOf('-');
    if ( hyphenIndex < 0 ) {
      return null;
    }
    var rev = etag.slice(2,hyphenIndex);
    return rev;
  }

  /**
   * @private
   */
  uploadFile_(method, apiPath, filePath, stamp, callback) {
    if (this.bytesTotal_ !== null) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'Transfer already running.'));
      this.terminateTransferState_();
      return;
    }

    this.bytesTotal_ = 0;
    this.bytesTransferred_ = 0;
    this.bytesTransferredCompleted_ = 0;

    var baseUrl = this.connCtrl_.getBaseUrl();
    if (typeof baseUrl !== 'string') {
      callback(mwe.genError(mwe.E_MW_DEVICE_NOT_FOUND, 'Base URL is not a string.'));
      this.terminateTransferState_();
      return;
    }

    var self = this;
    var retryCount = 2;

    let runUpload = function (runUploadCallback) {
      self.bytesTotal_ = 0;
      self.bytesTransferred_ = 0;
      self.bytesTransferredCompleted_ = 0;

      fs.open(filePath, 'r', function (err, fd) {
        if (err) {
          runUploadCallback(mwe.genError(mwe.E_MW_FILE_READ_LOCAL_FAILED, 'Failed to read file.', err));
          return;
        }

        fs.stat(filePath, function (err, stat) {
          if (err) {
            fs.close(fd, function () {  // fs.close() のエラーは無視する
              runUploadCallback(mwe.genError(mwe.E_MW_FILE_READ_LOCAL_FAILED, 'Failed to read file.', err));
            });
            return;
          }

          self.bytesTotal_ = stat.size;
          self.uploadFilePartial_(method, apiPath, fd, 0, stat.size, stamp, false, function (err, stamp) {
            fs.close(fd, function () {  // fs.close() のエラーは無視する
              runUploadCallback(err, stamp);
            });
          });
        });
      });
    };

    let runUploadCallback = function (err, option) {
      if (!self.cancelling_) {  // キャンセルされていないことを確認
        if (err && err.cause && (err.cause.error_code === '40011')) {  // 40011: 分割アップロードにおけるパラメータが不整合
          if ((retryCount--) > 0) { 
            setTimeout(function () {
              //console.log('* Retry runUpload()');
              runUpload(runUploadCallback);
            }, 100);
            return;
          }
        }
      }

      callback(err, option);
      self.terminateTransferState_();
    };

    runUpload(runUploadCallback);
  }

  /**
   * @private
   */
  uploadFilePartial_(method, apiPath, fd, offset, length, stamp, reauthed, callback) {
    if ( this.checkCancelling_(callback) ) {
      return;
    }

    var baseUrl = this.connCtrl_.getBaseUrl();
    if ( typeof baseUrl !== 'string' ) {
      callback(mwe.genError(mwe.E_MW_DEVICE_NOT_FOUND, 'Base URL is not a string.'));
      return;
    }
    var apiUrl = baseUrl + apiPath;
    // // const Buffer = require('buffer');
    // const CHUNKLEN = 8 * 1024 * 1024;

    var self = this;
    var buf = Buffer.alloc(CHUNKLEN);
    fs.read(fd, buf, 0, CHUNKLEN, offset, function(err, bytesRead, buffer) {
      if ( err ) {
        callback(mwe.genError(
          mwe.E_MW_FILE_READ_LOCAL_FAILED, 'Failed to read file.', err));
        return;
      }
        
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      
      var form = new FormData();
      var ui8arr = new Uint8Array(buffer.buffer, buffer.byteOffset, bytesRead);
      var blob = new Blob([ui8arr]);
      // [2016-06-28 00:10:42+09:00] kan.k: [TODO] To change
      form.append('file', blob, 'altair.pdf');

      var queryPart = '?offset_bytes=' + offset.toString() + '&total_bytes=' + length.toString();

      if ( typeof stamp === 'string' ) {
        queryPart += '&target_revision=' + stamp;
      }

      // [2016-10-18 14:43:26+09:00] kan.k: [TODO] queryPart
      
      var xhrReq = new XMLHttpRequest();
      xhrReq.timeout = XHR_TIMEOUT_TRANSFER;
      xhrReq.responseType = 'json';
      xhrReq.open(method, apiUrl + queryPart, true);

      var callbackHandled = false;
      
      xhrReq.ontimeout = function(err) {
        // console.warn('xhrReq abort occures while uploading.', err);
        if ( callbackHandled ) {
          return;
        }
        callbackHandled = true;
        
        self.xhrRequest_ = null;
        if ( self.checkCancelling_(callback) ) {
          return;
        }
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_ERROR, 'XHR timeout occured.', method, apiPath + queryPart, xhrReq.status, err));
        return;
      };

      xhrReq.onabort = function(err) {
        // console.warn('xhrReq abort occures while uploading.', err);
        if ( callbackHandled ) {
          return;
        }
        callbackHandled = true;
        
        self.xhrRequest_ = null;
        if ( self.checkCancelling_(callback) ) {
          return;
        }
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_ERROR, 'XHR abort occured.', method, apiPath + queryPart, xhrReq.status, err));
        return;
      };

      xhrReq.onerror = function(err) {
        // console.warn('xhrReq error occures while uploading.', err);
        if ( callbackHandled ) {
          return;
        }
        callbackHandled = true;
        
        self.xhrRequest_ = null;
        if ( self.checkCancelling_(callback) ) {
          return;
        }
        callback(mwe.genWebApiError(
          mwe.E_MW_WEBAPI_ERROR, 'XHR error occured.', method, apiPath + queryPart, xhrReq.status, err));
        return;
      };
      
      xhrReq.upload.onprogress = function(ev) {
        // debugger;
        if ( ev.loaded > CHUNKLEN ) {
          self.bytesTransferred_ = self.bytesTransferredCompleted_ + CHUNKLEN;
        } else {
          self.bytesTransferred_ = self.bytesTransferredCompleted_ + ev.loaded;
        }
        // if ( self.bytesTransferred_ > self.bytesTotal_ ) {
        if ( typeof self.bytesTotal_ === 'number' && self.bytesTransferred_ > self.bytesTotal_ ) {
          self.bytesTransferred_ = self.bytesTotal_;
        }
      }
      
      xhrReq.onload = function() {
        // console.warn('xhrReq onload occures while uploading.');
        if ( callbackHandled ) {
          return;
        }
        callbackHandled = true;
        
        self.xhrRequest_ = null;
        if ( self.checkCancelling_(callback) ) {
          return;
        }
        
        if ( xhrReq.status !== 200 && xhrReq.status !== 206 ) {
          if ( REAUTH_UPLOAD_PARTIAL && REAUTH_STATUSES.indexOf(xhrReq.status) >= 0 && ! reauthed ) {
            // attempt to reauth.
            // [2016-10-19 11:24:17+09:00] kan.k: When error occured
            // for reauthentication, returning error is for original
            // error.
            debug('reauth upload partial invoked by: ', err);
            self.connCtrl_.auth(function(err) {
              if ( err ) {
                callback(mwe.genWebApiError(
                  mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', method, apiUrl + queryPart,
                  xhrReq.status, xhrReq.response));
                return;
              }
              self.uploadFilePartial_(method, apiPath, fd, offset, length, stamp, true, callback);
            });
            return;
          }
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', method, apiUrl + queryPart,
            xhrReq.status, xhrReq.response));
          return;
        }

        var res = xhrReq.response;
        var currentBytes = parseInt(res.current_bytes, 10);
        if ( isNaN(currentBytes) ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'current_bytes is not a number.',
            method, apiPath + queryPart, xhrReq.status, xhrReq.response));
          return;
        }
        var receivedBytes = parseInt(res.received_bytes, 10);
        if ( isNaN(receivedBytes) ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'received_bytes is not a number.',
            method, apiPath + queryPart, xhrReq.status, xhrReq.response));
          return;
        }
        if ( receivedBytes + offset !== currentBytes ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'received_bytes and current_bytes does not match.',
            method, apiUrl + queryPart, xhrReq.status,  xhrReq.response));
          return;
        }
        self.bytesTransferred_ = currentBytes;
        self.bytesTransferredCompleted_ = currentBytes;

        if ( currentBytes >= length ) {
          if ( res.completed !== 'yes' ) {
            callback(mwe.genWebApiError(
              mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'completed is not yes.', method, apiUrl + queryPart,
              xhrReq.status,  xhrReq.response));
            return;
          }
          
          console.log('File uploaded: ', 100 * currentBytes / length, ' % : ',  currentBytes, ' / ', length, ' [Bytes]');
          var resStamp = null;
          if ( xhrReq.response && typeof xhrReq.response.file_revision === 'string' ) {
            resStamp = xhrReq.response.file_revision;
          }
          callback(null, resStamp);
          return;
        }
        
        if ( res.completed !== 'no' ) {
          callback(mwe.genWebApiError(
            mwe.E_MW_WEBAPI_UNEXPECTED_VALUE, 'Unexpected value.', method, apiUrl + queryPart,
            xhrReq.status,  xhrReq.response));
          return;
        }

        console.log('File partial uploaded: ', 100 * currentBytes / length, ' % : ',  currentBytes, ' / ', length, ' [Bytes]');
        
        self.uploadFilePartial_(method, apiPath, fd, currentBytes, length, stamp, false, callback);
      }
      
      self.xhrRequest_ = xhrReq;
      xhrReq.send(form);
      console.log('File upload XHR called: ', queryPart);
    });
  }

  ///////////////////////////////////
  ///   Control Progress
  ///////////////////////////////////
  
  getBytesTransferred() {
    return this.bytesTransferred_;
  }

  /**
   * Get total byte length of current processing task.
   *
   * 現在処理中のタスクの全バイト数を取得する。
   *
   * @return {number} A byte length.
   */
  getBytesTotal() {
    return this.bytesTotal_;
  }

  /**
   * Cancel current transfer task.
   * <br>
   * 現在の転送タスクをキャンセルする。
   * 
   * @param {function(?Error)} callback The callback to get cert
   *   result. The callback will be called when cancellation is done.
   *   <br>
   *   結果を受け取るためのCallback。Callbackは、キャンセル処理が完了
   *   したときに呼び出される。
   */
  cancel(callback) {
    if ( this.cancelling_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'Already cancelling'));
      return;
    }
    this.cancelling_ = true;
    this.cancellingCallback_ = callback;
    if ( this.xhrRequest_ ) {
      this.xhrRequest_.abort();
      // this.xhrRequest_.onerror(mwe.genError(mwe.E_MW_CANCELLED, 'Cancelled'));
    } else {
      callback(null);
      return;
    }
    return;
  }

  /**
   * キャンセル状態のチェックのメソッド。
   *
   * Trueを返したら、Callback含めて処理済みなので、追加で処理を行わない。
   *
   * @note Cancel処理の基本は、Pollingで、この関数でチェックします。
   *   チェックすると同時に、引っかかった場合に、Callbackを呼び出して、
   *   処理を中断させるための、true を返します。trueが返ってきたら、キャ
   *   ンセルされたものと見なして、以後の処理を行わない。
   *
   * @note checkCancelling_ では、同時に、渡されたCallback関数に対して、
   *   Errorを先に呼び出している。
   */
  checkCancelling_(callback) {
    if ( ! this.cancelling_ ) {
      return false;
    }
    callback(mwe.genError(mwe.E_MW_CANCELLED, 'Cancelled'));

    this.bytesTotal_ = null;
    this.bytesTransferred_ = null;
    this.bytesTransferredCompleted_ = null;
    
    if ( ! this.cancelling_ ) {
      console.error('Invalid status');
      throw new Error('Invalid error');
    }
    
    this.cancellingCallback_(null);
    this.cancelling_ = false;
    this.cancellingCallback_ = null;
    return true;
  }

  /**
   * チェックポイント以外で、Cancel中に終了された場合に状態を戻すメソッ
   * ド。
   * 
   * @note 何のために呼び出す必要があるかというと、次の呼び出しに移行
   *   して、状態フラグをリセットしなければ行けない。平たく言うと
   *
   * @note checkCancelling_に渡されたcallbackの中から、こちらの関数を
   *   呼び出すと未定義状態になる。注意。
   *
   * @note たとえキャンセル中だったとしても処理が終わってしまうことが
   *   あって、その際にフラグをクリアする処理と、他の途中状態のための
   *   変数をクリアする処理とを行っている。
   */
  terminateTransferState_() {
    this.bytesTotal_ = null;
    this.bytesTransferred_ = null;
    this.bytesTransferredCompleted_ = null;
    if ( this.cancelling_ ) {
      this.cancellingCallback_(null);
      this.cancelling_ = false;
      this.cancellingCallback_ = null;
    }
  }

  ///////////////////////////////////
  ///   Common Web API
  ///////////////////////////////////
  
  /**
   * @private
   */
  callWebApi(method, apiPath, body, callback) {
    this.callWebApiWithRetry_(method, apiPath, body, false, false, callback);
  }

  /**
   * @private
   */
  callWebApiWithRetry_(method, apiPath, body, reauthed, retried, callback) {
    var baseUrl = this.connCtrl_.getBaseUrl();
    if ( typeof baseUrl !== 'string' ) {
      callback(mwe.genError(mwe.E_MW_DEVICE_NOT_FOUND, 'Base URL is not a string.'));
      return;
    }
    var xhrReq = new XMLHttpRequest();
    xhrReq.timeout = XHR_TIMEOUT;
    xhrReq.responseType = 'json';
    xhrReq.open(method, baseUrl + apiPath, true);
    var self = this;
    
    var callbackHandled = false;
    
    xhrReq.ontimeout = function(err) {
      if ( callbackHandled ) {
        return;
      }
      callbackHandled = true;
      
      self.xhrRequest_ = null;
      if (err && err.mwCode === mwe.E_MW_CANCELLED) {
        callback(err);
        return;
      }
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      if ( RETRY_CALL_WEBAPI_FOR_TIMEOUT && ! retried ) {
        // attempt to retry
        debug('retry call web api invoked for XHR error: ', err);
        self.callWebApiWithRetry_(method, apiPath, body, reauthed, true, callback);
        return;
      }
      callback(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_ERROR, 'XHR timeout occured.', method, apiPath, xhrReq.status, err));
      return;
    };
    
    xhrReq.onabort = function(err) {
      if ( callbackHandled ) {
        return;
      }
      callbackHandled = true;
      
      self.xhrRequest_ = null;
      if (err && err.mwCode === mwe.E_MW_CANCELLED) {
        callback(err);
        return;
      }
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      if ( RETRY_CALL_WEBAPI && ! retried ) {
        // attempt to retry
        debug('retry call web api invoked for XHR error: ', err);
        self.callWebApiWithRetry_(method, apiPath, body, reauthed, true, callback);
        return;
      }
      callback(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_ERROR, 'XHR abort occured.', method, apiPath, xhrReq.status, err));
      return;
    };
    
    xhrReq.onerror = function(err) {
      if ( callbackHandled ) {
        return;
      }
      callbackHandled = true;
      
      self.xhrRequest_ = null;
      if (err && err.mwCode === mwe.E_MW_CANCELLED) {
        callback(err);
        return;
      }
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      if ( RETRY_CALL_WEBAPI && ! retried ) {
        // attempt to retry
        debug('retry call web api invoked for XHR error: ', err);
        self.callWebApiWithRetry_(method, apiPath, body, reauthed, true, callback);
        return;
      }
      callback(mwe.genWebApiError(
        mwe.E_MW_WEBAPI_ERROR, 'XHR error occured.', method, apiPath, xhrReq.status, err));
      return;
    };
    
    xhrReq.onload = function() {
      if ( callbackHandled ) {
        return;
      }
      callbackHandled = true;
      
      self.xhrRequest_ = null;
      if ( self.checkCancelling_(callback) ) {
        return;
      }
      if ( REAUTH_CALL_WEBAPI &&
           REAUTH_STATUSES.indexOf(xhrReq.status) >= 0 && ! reauthed ) {
        // attempt to reauth.
        // [2016-10-19 11:24:17+09:00] kan.k: When error occured
        // for reauthentication, returning error is for original
        // error.
        debug('reauth upload partial invoked');
        self.connCtrl_.auth(function(autherr) {
          if ( autherr ) {
            // When failed to auth, returns original status, as it is.
            callback(null, xhrReq.response, xhrReq.status);
            // callback(mwe.genWebApiError(
            //   mwe.E_MW_WEBAPI_UNEXPECTED_STATUS, 'Unexpected status.', method, apiUrl + queryPart,
            //   xhrReq.status, xhrReq.response));
            return;
          }
          self.callWebApiWithRetry_(method, apiPath, body, true, retried, callback);
        });
        return;
      }
      
      callback(null, xhrReq.response, xhrReq.status);
    };
    if ( body !== null ) {
      xhrReq.setRequestHeader('Content-Type', 'application/json');
      body = JSON.stringify(body);
    }
    this.xhrRequest_ = xhrReq;
    xhrReq.send(body);
  }

}

