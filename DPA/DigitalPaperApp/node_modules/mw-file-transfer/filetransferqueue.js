/**
    filetransfer.js
    
    created:    [2016-06-10 11:49:08+09:00]
    modified:   [2016-10-18 17:37:24+09:00]
    description:
    File Transfer
*/

'use strict';

const mwe = require('mw-error');

// Use from Main Process
const electron = require('electron');

if ( typeof electron.remote === 'undefined' ) {
  throw new Error('This module must be loaded from Electron Renderer');
  // [2016-06-01 14:02:51+09:00] kan.k: このモジュールは、
  // RendererProcessで動作させる必要がある。理由はXHRを通じてRenderer
  // 側のHTTPSスタックを利用して通信するため。
}

const fs = require('fs');

const EventEmitter = require('events').EventEmitter;

const path = require('path');

// // [2016-06-20 18:36:35+09:00] kan.k: [TODO] This should be remote
// const fs = require('fs');
// // const fs = electron.remote.require('fs');

// // Chunk len for partial upload.
// const CHUNKLEN = 8 * 1024 * 1024;

const MAX_CERT_SIZE = 100 * 1024;

const mft = exports;

/**
 * Create fileTransfer instance.
 *
 * @param {object} connCtrl A connection control object that can be
 *   acquired via mw-conn-ctrl module.
 * @param {object} [options] A options.
 * @note options.taskAutoRun === false の場合はTaskを自動で実行しない
 *       呼び出し元がTaskの実行を呼び出す必要がある
 *       分割Uploadが並行実行できないが、複数の機能でfiletransferqueを作成し、使っている
 *       複数の機能のuploadを順次実行するためにはtaskAutoRunをfalseに設定し、
 *       順次手動で呼び出す必要がある
 * @note options.taskAutoRun === true または、未設定の場合はTaskは順次自動で実行される
 */
mft.createFileTransfer = function(connCtrl, options) {
  return new FileTransferQueue(connCtrl, options);
}

mft.TASK_TYPE_DOWNLOAD_DOCUMENT = 'TASK_DOWNLOAD_DOCUMENT';

mft.TASK_TYPE_DOWNLOAD_DOCUMENT_AS_BINARY = 'TASK_DOWNLOAD_DOCUMENT_AS_BINARY';

// mft.TASK_TYPE_DOWNLOAD_OVERWRITE_DOCUMENT = 'TASK_DOWNLOAD_OVERWRITE_DOCUMENT';

mft.TASK_TYPE_UPLOAD_DOCUMENT_BY_PATH = 'TASK_UPLOAD_DOCUMENT_BY_PATH';

mft.TASK_TYPE_UPLOAD_DOCUMENT_BY_ID = 'TASK_UPLOAD_DOCUMENT_BY_ID';

mft.TASK_TYPE_UPLOAD_OVERWRITE_DOCUMENT_BY_PATH = 'TASK_UPLOAD_OVERWRITE_DOCUMENT_BY_PATH';

mft.TASK_TYPE_UPLOAD_OVERWRITE_DOCUMENT_BY_ID = 'TASK_UPLOAD_OVERWRITE_DOCUMENT_BY_ID';

mft.TASK_TYPE_UPLOAD_FIRMWARE = 'TASK_UPLOAD_FIRMWARE';

mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE = 'TASK_UPLOAD_NOTE_TEMPLATE';

const ft = require('./lib/filetransfer');

/** 
 * Connection Control class for MilkyWay
 * @class
 */
class FileTransferQueue extends EventEmitter {
  constructor(connCtrl, options) {
    super();
    this.connCtrl_ = connCtrl;
    // this.currentFolderId_ = 'root';
    this.queue_ = [];
    this.fileTransfer_ = ft.createFileTransfer(connCtrl);
    this.singleTransfer_ = false;
    // if ( options && options.singleTransfer ) {
    //   this.singleTransfer_ = true;
    // }
    this.taskAutoRun_ = true;
    if ( options && options.taskAutoRun === false ) {
      this.taskAutoRun_ = false;
    }
  }

  ///////////////////////////////////
  ///   enqueue version
  ///////////////////////////////////

  /**
   * Download document.
   * <br>
   * ドキュメントをダウンロードする。
   *
   * renameフラグが設定されている場合ダウンロード先に同名のファイルが
   * 存在した場合には、別のファイル名に対してファイルをダウンロードす
   * る。
   *
   * @param {string} documentId The target document to download.
   *
   * @param {string} filepath A full path to download the file.
   *
   * @param {object} options
   *
   * @param {boolean} options.rename A switch to rename file when filename
   *   conflict found.
   *
   * @param {function(?Error)} callback
   *   The callback to get the file.
   *   When failed to download an Error object will be returned
   *   to first argument. The error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   - E_MW_FILE_WRITE_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。取得に失敗した場合には、第一引数に
   *   Errorオブジェクトが返る。返る場合のあるエラーコードは次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   - E_MW_FILE_WRITE_LOCAL_FAILED
   *   成功した場合には、第二引数に次のオブジェクトが返る:
   *   `{ stamp: '<ダウンロードしたファイルのstamp情報>' }`
   *
   * @note upload時との対称性のために、また、将来的に細部の動作の変更
   *   が必要な場合を想定して、renameの有効無効に対してoptionsの方式を
   *   採用している。
   */
  downloadDocument(documentId, filepath, options, callback) {
    if ( typeof callback !== 'function' ) {
      if ( typeof options === 'function' ) {
        // Only for transition. remove it after old call is eliminated.
        callback = options;
        options = { rename: true };
        console.warn('old interface is called');
      } else {
        throw new TypeError('callback must be a function');
      }
    }
    if ( this.singleTransfer_ && this.running_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
      return;
    }
    var task = {
      type: mft.TASK_TYPE_DOWNLOAD_DOCUMENT,
      documentId: documentId,
      filepath: filepath,
      rename: false,
      callback: callback
    };
    if ( options && typeof options.rename === 'boolean' ) {
      task.rename = options.rename
    }
    this.queue_.push(task);

    this.emit('taskAdded', task);
    if(this.taskAutoRun_) {
      this.checkStartTask_();
    }
  }


  // /**
  //  * Download document.
  //  * <br>
  //  * 上書きのためにドキュメントをダウンロードする。downloadDocumentと
  //  * の違いは、filepathに同名ファイルが存在した場合にも、重複解消の処
  //  * 理を行わない点。
  //  *
  //  * @param {string} documentId The target document to download.
  //  *
  //  * @param {string} filepath A full path to download the file.
  //  *
  //  * @param {function(?Error, ?filepath, stamp)} callback
  //  *   The callback to get the file.
  //  *   When failed to download an Error object will be returned
  //  *   to first argument. The error code of the Error object are:
  //  *   - E_MW_DEVICE_NOT_FOUND
  //  *   - E_MW_WEBAPI_ERROR
  //  *   - E_MW_WEBAPI_UNEXPECTED_STATUS
  //  *   - E_MW_WEBAPI_UNEXPECTED_VALUE
  //  *   - E_MW_FILE_REMOTE_MODIFIED
  //  *   - E_MW_FILE_WRITE_LOCAL_FAILED
  //  *   <br>
  //  *   結果を受け取るCallback関数。ダウンロードに成功下場合には、書き
  //  *   込んだローカルのファイルパスを第2引数に、リモートから取得した
  //  *   stamp情報が第3引数に返る。取得に失敗した場合には、第一引数に
  //  *   Errorオブジェクトが返る。返る場合のあるエラーコードは次のもの:
  //  *   - E_MW_DEVICE_NOT_FOUND
  //  *   - E_MW_WEBAPI_ERROR
  //  *   - E_MW_WEBAPI_UNEXPECTED_STATUS
  //  *   - E_MW_WEBAPI_UNEXPECTED_VALUE
  //  *   - E_MW_FILE_REMOTE_MODIFIED
  //  *   - E_MW_FILE_WRITE_LOCAL_FAILED
  //  */
  // downloadDocumentForOverwrite(documentId, filepath, callback) {
  //   if ( typeof callback !== 'function' ) {
  //     throw new TypeError('callback must be a function');
  //   }
  //   if ( this.singleTransfer_ && this.running_ ) {
  //     callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
  //     return;
  //   }
  //   var task = {
  //     type: mft.TASK_TYPE_DOWNLOAD_DOCUMENT_FOR_OVERWRITE,
  //     documentId: documentId,
  //     filepath: filepath,
  //     callback: callback
  //   };
  //   this.queue_.push(task);

  //   this.checkStartTask_();
  // }

  /**
   * Download document as binary.
   *
   * @param {string} documentId The target document to download.
   * @param {function(Buffer,boolean)} output
   * @param {function(?Error)} callback
   *   The callback to get the file.
   *   When failed to download an Error object will be returned
   *   to first argument. The error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   <br>
   *   結果を受け取るCallback関数。取得に失敗した場合には、第一引数に
   *   Errorオブジェクトが返る。返る場合のあるエラーコードは次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_REMOTE_MODIFIED
   */
  downloadDocumentAsBinary(documentId, output, callback) {
    if ( typeof output !== 'function' ) {
      throw new TypeError('output must be a function');
    }
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    if ( this.singleTransfer_ && this.running_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
      return;
    }
    var task = {
      type: mft.TASK_TYPE_DOWNLOAD_DOCUMENT_AS_BINARY,
      documentId: documentId,
      output: output,
      callback: callback
    };
    this.queue_.push(task);

    this.emit('taskAdded', task);
    if(this.taskAutoRun_) {
      this.checkStartTask_();
    }
  }

  /**
   * Upload document.
   *
   * @param {string} parentFolderId The target folder to upload file.
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error, documentId)} callback The callback to
   *   get cert result. When succeed the documentId for the document
   *   that created is passed as a second argument.  When failed to
   *   upload an Error object will be returned to first argument. The
   *   error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに失敗した場合には、第
   *   一引数にErrorオブジェクトが返る。返る場合のあるエラーコードは次
   *   のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   成功した場合には、第二引数に次のオブジェクトが返る:
   *   `{ documentId: '<新規に作成されたdocumentのID>',
   *      folderId: '<アップロードされた先のfolderのID>',
   *      stamp: '<アップロードしたファイルのstamp情報>' }`
   *
   * @note This API is currently not used. nor maintainanced.
   */
  uploadDocumentById(parentFolderId, filepath, filename, callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    if ( this.singleTransfer_ && this.running_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
      return;
    }
    var task = {
      type: mft.TASK_TYPE_UPLOAD_DOCUMENT_BY_ID,
      parentFolderId: parentFolderId,
      filepath: filepath,
      filename: filename,
      callback: callback
    };
    this.queue_.push(task);

    this.emit('taskAdded', task);
    if(this.taskAutoRun_) {
      this.checkStartTask_();
    }
  }
  
  /**
   * Upload document.
   * <br>
   * ドキュメントをアップロードする。
   *
   * renameフラグを設定していた場合には、アップロード先に同名のファイ
   * ルが存在するか確認して重複解消したファイル名に対してアップロード
   * を行う。
   *
   * @param {string} parentFolderPath The target folder path to upload
   *   file.
   *
   * @param {string} filepath The full path to the file to upload.
   *
   * @param {string} filename A filename to be put on opponent device.
   *
   * @param {object} options
   *
   * @param {boolean} options.rename A switch to rename file when
   *   filename conflict found.
   *
   * @param {function(?Error, documentId, parentFolderId, stamp)}
   *   callback The callback to get cert result. When succeed the
   *   documentId for the document that created is passed as a second
   *   argument.  When failed to upload an Error object will be
   *   returned to first argument. The error code of the Error object
   *   are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに失敗した場合には、
   *   第一引数にErrorオブジェクトが返る。返る場合のあるエラーコードは
   *   次のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   成功した場合には、第二引数に次のオブジェクトが返る:
   *   `{ documentId: '<新規に作成されたdocumentのID>',
   *      folderId: '<アップロードされた先のfolderのID>',
   *      stamp: '<アップロードしたファイルのstamp情報>' }`
   *
   * @note upload時には、実際には、フォルダの作成等も行っている。それ
   *   らの有効無効を将来的に切り替える必要性が生じたときも基本的なイ
   *   ンターフェースを変更しないようにするために、renameの有効無効に
   *   対してoptionsの方式を採用している。
   */
  uploadDocumentByPath(parentFolderPath, filepath, filename, options, callback) {
    if ( typeof parentFolderPath !== 'string') {
      throw new TypeError('parentFolderPath must be a string');
    }
    if ( typeof filepath !== 'string') {
      throw new TypeError('filepath must be a string');
    }
    if ( typeof callback !== 'function' ) {
      if ( typeof options === 'function' ) {
        // Only for transition. remove it after old call is eliminated.
        callback = options;
        options = { rename: true };
        console.warn('old interface is called');
      } else {
        throw new TypeError('callback must be a function');
      }
    }
    if ( this.singleTransfer_ && this.running_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
      return;
    }
    var task = {
      type: mft.TASK_TYPE_UPLOAD_DOCUMENT_BY_PATH,
      parentFolderPath: parentFolderPath,
      filepath: filepath,
      filename: filename,
      rename: false,
      callback: callback
    };
    if ( options && typeof options.rename === 'boolean' ) {
      task.rename = options.rename
    }
    this.queue_.push(task);

    this.emit('taskAdded', task);
    if(this.taskAutoRun_) {
      this.checkStartTask_();
    }
  }

  /**
   * Upload overwritting existing document.
   * <br>
   * 既存のドキュメントに対して上書きのUploadを行う。
   *
   * @param {string} documentId The documentId of target document to be overwritten.
   *   <br>
   *   アップロード先のドキュメントのドキュメントID
   *
   * @param {string} filepath The full path to the file to upload.
   *   <br>
   *   上書きアップロードする際の、アップロード元のファイルパス
   *
   * @param {string} stamp 上書きする前のFileのstamp情報。Deneb側の
   *   Stampがすでに更新されていた場合には、別経路でDeneb側でファイル
   *   がアップデートされたということを検出して、
   *   E_MW_FILE_REMOTE_MODIFIEDを返す。
   *
   * @param {function(?Error, documentId, stamp)} callback The callback to
   *   get cert result. When succeed the documentId for the document
   *   that created is passed as a second argument.  When failed to
   *   upload an Error object will be returned to first argument. The
   *   error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに失敗した場合には、第
   *   一引数にErrorオブジェクトが返る。返る場合のあるエラーコードは次
   *   のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   - E_MW_FILE_REMOTE_MODIFIED: Altair側で、DenebのAPIをチェックして、
   *     変更を検出できた場合。Deneb側で判断した場合は、WebAPIのStatus
   *     のエラーとして返す。
   *   成功した場合には、第二引数に次のオブジェクトが返る:
   *   `{ documentId: '<新規に作成されたdocumentのID>',
   *      stamp: '<アップロードしたファイルのstamp情報>' }`
   */
  uploadOverwriteDocumentById(documentId, filepath, stamp, callback) {
    if ( typeof documentId !== 'string' ) {
      throw new TypeError('documentId must be a function');
    }
    if ( typeof filepath !== 'string' ) {
      throw new TypeError('filepath must be a function');
    }
    if ( typeof stamp !== 'string' ) {
      throw new TypeError('stamp must be a function');
    }
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    if ( this.singleTransfer_ && this.running_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
      return;
    }
    var task = {
      type: mft.TASK_TYPE_UPLOAD_OVERWRITE_DOCUMENT_BY_ID,
      documentId: documentId,
      filepath: filepath,
      stamp: stamp,
      callback: callback
    };
    this.queue_.push(task);

    this.emit('taskAdded', task);
    if(this.taskAutoRun_) {
      this.checkStartTask_();
    }
  }
  
  /**
   * Upload overwritting existing document.
   * <br>
   * 既存のドキュメントに対して上書きのUploadを行う。
   *
   * @param {string} documentPath The target document path to
   *   overwritten.
   *   <br>
   *   上書きアップロードする際の、アップロード先のドキュメントのパス
   *
   * @param {string} filepath The full path to the file to upload.
   *   <br>
   *   上書きアップロードする際の、アップロード元のファイルパス
   *   
   * @param {string} stamp 上書きする前のFileのstamp情報。Deneb側の
   *   Stampがすでに更新されていた場合には、別経路でDeneb側でファイル
   *   がアップデートされたということを検出して、
   *   E_MW_FILE_REMOTE_MODIFIEDを返す。
   *
   * @param {function(?Error, documentId, parentFolderId, stamp)} callback The callback to
   *   get cert result. When succeed the documentId for the document
   *   that created is passed as a second argument.  When failed to
   *   upload an Error object will be returned to first argument. The
   *   error code of the Error object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに失敗した場合には、第
   *   一引数にErrorオブジェクトが返る。返る場合のあるエラーコードは次
   *   のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   - E_MW_FILE_REMOTE_MODIFIED
   *   成功した場合には、第二引数に次のオブジェクトが返る:
   *   `{ documentId: '<新規に作成されたdocumentのID>',
   *      folderId: '<アップロードされた先のfolderのID>',
   *      stamp: '<アップロードしたファイルのstamp情報>' }`
   */
  uploadOverwriteDocumentByPath(documentPath, filepath, stamp, callback) {
    if ( typeof documentPath !== 'string') {
      throw new TypeError('parentFolderPath must be a string');
    }
    if ( typeof filepath !== 'string') {
      throw new TypeError('filepath must be a string');
    }
    if ( typeof stamp !== 'string' ) {
      throw new TypeError('stamp must be a function');
    }
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    if ( this.singleTransfer_ && this.running_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
      return;
    }
    var parsed = path.parse(documentPath);
    
    var task = {
      type: mft.TASK_TYPE_UPLOAD_OVERWRITE_DOCUMENT_BY_PATH,
      parentFolderPath: parsed.dir,
      filepath: filepath,
      filename: parsed.base,
      stamp: stamp,
      callback: callback
    };
    this.queue_.push(task);

    this.emit('taskAdded', task);
    if(this.taskAutoRun_) {
      this.checkStartTask_();
    }
  }

  /**
   * Upload note template
   * 
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error, noteTemplateId)} callback The callback
   *   to get cert result. When failed to upload an Error object will
   *   be returned to first argument. The error code of the Error
   *   object are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに失敗した場合には、第
   *   一引数にErrorオブジェクトが返る。返る場合のあるエラーコードは次
   *   のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   */
  uploadNoteTemplate(filepath, filename, callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    if ( this.singleTransfer_ && this.running_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
      return;
    }
    var task = {
      type: mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE,
      filepath: filepath,
      filename: filename,
      callback: callback
    };
    this.queue_.push(task);

    this.emit('taskAdded', task);
    if(this.taskAutoRun_) {
      this.checkStartTask_();
    }
  }

  /**
   * Upload firmware
   * 
   * @param {string} filepath The full path to the file to upload.
   * @param {string} filename A filename to be put on opponent device.
   * @param {function(?Error)} callback The callback to get cert
   *   result. When failed to upload an Error object will be
   *   returned to first argument. The error code of the Error object
   *   are:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   <br>
   *   結果を受け取るCallback関数。アップロードに失敗した場合には、第
   *   一引数にErrorオブジェクトが返る。返る場合のあるエラーコードは次
   *   のもの:
   *   - E_MW_DEVICE_NOT_FOUND
   *   - E_MW_WEBAPI_ERROR
   *   - E_MW_WEBAPI_UNEXPECTED_STATUS
   *   - E_MW_WEBAPI_UNEXPECTED_VALUE
   *   - E_MW_FILE_READ_LOCAL_FAILED
   */
  uploadFirmware(filepath, filename, callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    if ( this.singleTransfer_ && this.running_ ) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'This instance only allow single file transfer.'));
      return;
    }
    var task = {
      type: mft.TASK_TYPE_UPLOAD_FIRMWARE,
      filepath: filepath,
      filename: filename,
      callback: callback
    };
    this.queue_.push(task);

    this.emit('taskAdded', task);
    if(this.taskAutoRun_) {
      this.checkStartTask_();
    }
  }

  /**
   * Taskを１個だけ実行する
   */
  runOneTask() {
    var task = this.queue_.shift();
    if ( typeof task === 'undefined' ) {
      this.currentTask_ = null;
      this.running_ = false;
      return;
    }
    this.running_ = true;
    this.currentTask_ = task;
    var self = this;

    if ( task.type === mft.TASK_TYPE_DOWNLOAD_DOCUMENT ) {
      this.emit('start', task);
      this.fileTransfer_.downloadDocument(task.documentId, task.filepath, task.rename, function(err, stamp, filePath) {
        self.running_ = false;
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.stamp = stamp;
          task.filepath = filePath;
          self.emit('end', task);
        }
        task.callback(err, task);
      });
    } else if ( task.type === mft.TASK_TYPE_DOWNLOAD_DOCUMENT_AS_BINARY ) {
      this.emit('start', task);
      this.fileTransfer_.downloadDocumentAsBinary(task.documentId, task.output, function(err, stamp) {
        self.running_ = false;
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.stamp = stamp;
          self.emit('end', task);
        }
        task.callback(err, task);
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_DOCUMENT_BY_ID ) {
      this.emit('start', task);
      this.fileTransfer_.uploadDocumentById(task.parentFolderId, task.filepath, task.filename, function(err, docId, folderId, stamp) {
        self.running_ = false;
		// [2016-11-07 22:48:14+09:00] kan.k: [TODO] requires collect file name?
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = docId;
          task.folderId = folderId;
          task.stamp = stamp;
          self.emit('end', task);
        }
        task.callback(err, task);
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_DOCUMENT_BY_PATH ) {
      this.emit('start', task);
      this.fileTransfer_.uploadDocumentByPath(task.parentFolderPath, task.filepath, task.filename, task.rename, function(err, docId, folderId, affectedFolderIds, stamp, filename, parentFolderPath) {
        self.running_ = false;
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = docId;
          task.folderId = folderId;
          task.affectedFolderIds = affectedFolderIds;
          task.stamp = stamp;
          task.filename = filename;
          task.parentFolderPath = parentFolderPath;
          self.emit('end', task);
        }
        task.callback(err, task);
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_OVERWRITE_DOCUMENT_BY_ID ) {
      this.emit('start', task);
      this.fileTransfer_.uploadOverwriteDocumentById(task.documentId, task.filepath, task.stamp, function(err, docId, stamp) {
        self.running_ = false;
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = docId;
          // task.folderId = folderId;
          task.stamp = stamp;
          self.emit('end', task);
        }
        task.callback(err, task);
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_OVERWRITE_DOCUMENT_BY_PATH ) {
      this.emit('start', task);
      this.fileTransfer_.uploadOverwriteDocumentByPath(task.parentFolderPath, task.filepath, task.filename, task.stamp, function(err, docId, folderId, stamp) {
        self.running_ = false;
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = docId;
          task.folderId = folderId;
          task.stamp = stamp;
          self.emit('end', task);
        }
        task.callback(err, task);
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE ) {
      this.emit('start', task);
      this.fileTransfer_.uploadNoteTemplate(task.filepath, task.filename, function(err, ntId) {
        self.running_ = false;
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = ntId;
          self.emit('end', task);
        }
        task.callback(err, task);
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_FIRMWARE ) {
      this.emit('start', task);
      this.fileTransfer_.uploadFirmware(task.filepath, task.filename, function(err) {
        self.running_ = false;
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          self.emit('end', task);
        }
        task.callback(err);
      });
    } else {
      self.running_ = false;
      console.error('unknown task id');
      this.emit('error', new Error('unknown task id'));
      task.callback(new Error('unknown task id'));
    }
  }

  /**
   * タスクを投入後に、タスクランナーがスタートしていなかったらスター
   * トするためのメソッド。タスクを投入後に呼び出す前提。
   *
   * @private
   */
  checkStartTask_() {
    if ( this.running_ ) {
      return;
    }
    this.running_ = true;
    this.runTask_();
  }

  /**
   * Indicates a task added.
   * <br>
   * タスクが追加されたことを示す。
   *
   * @event taskAdded
   *
   * @param {{type: string, ?documentId: string, ?parentFolderPath:
   *   string, filepath: string, ?filename: string}} task A object
   *   represents task. The object properties are `{type: string,
   *   ?documentId: string, ?parentFolderPath: string, filepath: string,
   *   ?filename: string}`.
   */

  /**
   * Indicates a task starting. Issued before starting actual
   * transfer.  When handling this event, and after this event
   * handling, getCurrent...() series will return status of this task.
   * <br>
   * タスクを開始する事を示す。実際の転送が開始される前に発行される。
   * このイベントをハンドルする間、およびイベントハンドラ以降は、
   * getCurrent...() は、このstartイベントで渡しているTaskの内容を返す。
   *
   * @event start
   *
   * @param {{type: string, ?documentId: string, ?parentFolderPath:
   *   string, filepath: string, ?filename: string}} task A object
   *   represents task. The object properties are `{type: string,
   *   ?documentId: string, ?parentFolderPath: string, filepath: string,
   *   ?filename: string}`.
   */

  /**
   * Indicates a task end successfully. Issued after actual transfer.
   * <br>
   * タスクが正常に完了したことを示す。実際の転送が完了した後に発行さ
   * れる。
   *
   * @event end
   *
   * @param {{type: string, ?documentId: string, ?parentFolderPath:
   *   string, filepath: string, ?filename: string}} task A object
   *   represents task. The object properties are `{type: string,
   *   ?documentId: string, ?parentFolderPath: string, filepath: string,
   *   ?filename: string}`.
   */

  /**
   * Indicates a task end with error. Issued after actual transfer
   * terminated.
   * <br>
   * タスクがエラーで停止したことを示す。実際の転送がエラーで中断され
   * た後に発行される。
   *
   * @event fail
   *
   * @param {{type: string, ?documentId: string, ?parentFolderPath:
   *   string, filepath: string, ?filename: string}} task A object
   *   represents task. The object properties are `{type: string,
   *   ?documentId: string, ?parentFolderPath: string, filepath: string,
   *   ?filename: string}`.
   */
  runTask_() {
    var task = this.queue_.shift();
    if ( typeof task === 'undefined' ) {
      this.currentTask_ = null;
      this.running_ = false;
      return;
    }
    this.currentTask_ = task;
    var self = this;

    if ( task.type === mft.TASK_TYPE_DOWNLOAD_DOCUMENT ) {
      this.emit('start', task);
      this.fileTransfer_.downloadDocument(task.documentId, task.filepath, task.rename, function(err, stamp, filePath) {
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.stamp = stamp;
          task.filepath = filePath;
          self.emit('end', task);
        }
        task.callback(err, task);
        self.runTask_();
      });
    } else if ( task.type === mft.TASK_TYPE_DOWNLOAD_DOCUMENT_AS_BINARY ) {
      this.emit('start', task);
      this.fileTransfer_.downloadDocumentAsBinary(task.documentId, task.output, function(err, stamp) {
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.stamp = stamp;
          self.emit('end', task);
        }
        task.callback(err, task);
        self.runTask_();
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_DOCUMENT_BY_ID ) {
      this.emit('start', task);
      this.fileTransfer_.uploadDocumentById(task.parentFolderId, task.filepath, task.filename, function(err, docId, folderId, stamp) {
		// [2016-11-07 22:48:14+09:00] kan.k: [TODO] requires collect file name?
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = docId;
          task.folderId = folderId;
          task.stamp = stamp;
          self.emit('end', task);
        }
        task.callback(err, task);
        self.runTask_();
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_DOCUMENT_BY_PATH ) {
      this.emit('start', task);
      this.fileTransfer_.uploadDocumentByPath(task.parentFolderPath, task.filepath, task.filename, task.rename, function(err, docId, folderId, affectedFolderIds, stamp, filename, parentFolderPath) {
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = docId;
          task.folderId = folderId;
          task.affectedFolderIds = affectedFolderIds;
          task.stamp = stamp;
          task.filename = filename;
          task.parentFolderPath = parentFolderPath;
          self.emit('end', task);
        }
        task.callback(err, task);
        self.runTask_();
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_OVERWRITE_DOCUMENT_BY_ID ) {
      this.emit('start', task);
      this.fileTransfer_.uploadOverwriteDocumentById(task.documentId, task.filepath, task.stamp, function(err, docId, stamp) {
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = docId;
          // task.folderId = folderId;
          task.stamp = stamp;
          self.emit('end', task);
        }
        task.callback(err, task);
        self.runTask_();
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_OVERWRITE_DOCUMENT_BY_PATH ) {
      this.emit('start', task);
      this.fileTransfer_.uploadOverwriteDocumentByPath(task.parentFolderPath, task.filepath, task.filename, task.stamp, function(err, docId, folderId, stamp) {
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = docId;
          task.folderId = folderId;
          task.stamp = stamp;
          self.emit('end', task);
        }
        task.callback(err, task);
        self.runTask_();
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE ) {
      this.emit('start', task);
      this.fileTransfer_.uploadNoteTemplate(task.filepath, task.filename, function(err, ntId) {
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          task.documentId = ntId;
          self.emit('end', task);
        }
        task.callback(err, task);
        self.runTask_();
      });
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_FIRMWARE ) {
      this.emit('start', task);
      this.fileTransfer_.uploadFirmware(task.filepath, task.filename, function(err) {
        if ( err ) {
          task.error = err;
          self.emit('fail', task);
        } else {
          self.emit('end', task);
        }
        task.callback(err);
        self.runTask_();
      });
    } else {
      console.error('unknown task id');
      this.emit('error', new Error('unknown task id'));
      task.callback(new Error('unknown task id'));
    }
  }

  /**
   * Task queue is running or not.
   */
  isRunning() {
    return this.running_ === true;
  }

  ///////////////////////////////////
  ///   Queue
  ///////////////////////////////////

  /**
   * Get waiting queue for download/upload.
   * <br>
   * ダウンロード/アップロードの待ち行列を取得する。
   *
   * @return {Array.<{type: string, ?documentId: string,
   *   ?parentFolderPath: string, filepath: string, ?filename: string}>}
   *   A list of waiting queue. Type of each object is {type: string,
   *   ?documentId: string, ?parentFolderPath: string, filepath: string,
   *   ?filename: string}.
   *   type is ether of:
   *   - mft.TASK_TYPE_DOWNLOAD_DOCUMENT
   *   - mft.TASK_TYPE_UPLOAD_DOCUMENT
   *   - mft.TASK_TYPE_UPLOAD_FIRMWARE
   *   - mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE
   *   <br>
   *   待ち行列のリスト。それぞれのオブジェクトの型は、`{type: string,
   *   ?documentId: string, ?parentFolderPath: string, filepath: string,
   *   ?filename: string}`になる。`type` 次のうちのいずれか: 
   *   - mft.TASK_TYPE_DOWNLOAD_DOCUMENT
   *   - mft.TASK_TYPE_UPLOAD_DOCUMENT
   *   - mft.TASK_TYPE_UPLOAD_FIRMWARE
   *   - mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE
   */
  getWaitingTaskList() {
    return this.queue_;
  }

  /**
   * Get count of current waiting queue.
   *
   * @return {number} A count.
   */
  getWaitingTaskCount() {
    return this.queue_.length;
  }

  /**
   * Get current processing task.
   * <br>
   * 現在処理中のタスクを取得する。
   *
   * @return {{type: string, ?documentId: string, ?parentFolderPath:
   *   string, filepath: string, ?filename: string}|null} A object
   *   represents current processing task. When no task is running,
   *   null will be returned. A type of an object is `{type: string,
   *   ?documentId: string, ?parentFolderPath: string, filepath: string,
   *   ?filename: string}`.  type is ether of:
   *   - mft.TASK_TYPE_DOWNLOAD_DOCUMENT
   *   - mft.TASK_TYPE_UPLOAD_DOCUMENT
   *   - mft.TASK_TYPE_UPLOAD_FIRMWARE
   *   - mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE
   *   <br>
   *   現在処理中のタスクを表すオブジェクト。実行中のタスクが無い場合
   *   には`null`が返る。タスクのオブジェクトの型は、`{type: string,
   *   ?documentId: string, ?parentFolderPath: string, filepath: string,
   *   ?filename: string}`になる。`type` 次のうちのいずれか:
   *   - mft.TASK_TYPE_DOWNLOAD_DOCUMENT
   *   - mft.TASK_TYPE_UPLOAD_DOCUMENT
   *   - mft.TASK_TYPE_UPLOAD_FIRMWARE
   *   - mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE
   */
  getCurrentTask() {
    return this.currentTask_;
  }
  
  /**
   * Get sent/received byte length of current processing task.
   *
   * 現在処理中のタスクの送信/受信済みバイト数を取得する。
   *
   * @return {number} A byte length.
   */
  getCurrentBytesTransferred() {
    return this.fileTransfer_.getBytesTransferred();
  }

  /**
   * Get total byte length of current processing task.
   *
   * 現在処理中のタスクの全バイト数を取得する。
   *
   * @return {number} A byte length.
   */
  getCurrentBytesTotal() {
    return this.fileTransfer_.getBytesTotal();
  }

  /**
   * Cancel current transfer task.
   * <br>
   * 現在の転送タスクをキャンセルする。
   * 
   * @param {function(?Error)} callback The callback to get cert
   *   result. The callback will be called when cancellation is done.
   *   <br>
   *   結果を受け取るためのCallback。Callbackは、キャンセル処理が完了
   *   したときに呼び出される。
   */
  cancelCurrent(callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    if ( ! this.currentTask_ ) {
      callback(mwe.genError(mwe.E_MW_TASK_NOT_FOUND));
      return;
    }
    
    return this.fileTransfer_.cancel(callback);
  }

  /**
   * Cancel designated download/upload whether already runing or in
   * waiting.
   *
   * 指定したダウンロード/アップロードを実行中かWaitingか関わらずキャ
   * ンセルする。
   *
   * @param {string} type A task type to cancel.
   *
   * @param {string} documentId A documentId to cancel download
   *   task. This parameter is only required to cancel downloading.
   *
   * @param {string} parentFolderPath A parentFolderPath to cancel
   *   uploading task. This parameter is only required to cancel
   *   uploading.
   *
   * @param {function(?Error)} callback The callback to get cert
   *   result. The callback will be called when cancellation is done.
   *   <br>
   *   結果を受け取るためのCallback。Callbackは、キャンセル処理が完了
   *   したときに呼び出される。
   */
  cancelTask(task, callback) {
    // [2016-07-13 15:24:28+09:00] kan.k: [TODO] Implement.
    console.warn('Not implemented');
  }

  validateTask_(task) {
    if ( task.type === mft.TASK_TYPE_DOWNLOAD_DOCUMENT ) {
      if ( typeof task.documentId !== 'string' ) {
        throw new TypeError('documentId must be set');
      }
      if ( typeof task.filepath !== 'string' ) {
        throw new TypeError('filepath must be set');
      }
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_DOCUMENT ) {
      if ( typeof task.parentFolderPath !== 'string' ) {
        throw new TypeError('parentFolderPath must be set');
      }
      if ( typeof task.filepath !== 'string' ) {
        throw new TypeError('filepath must be set');
      }
      if ( typeof task.filename !== 'string' ) {
        throw new TypeError('filename must be set');
      }
    } else if ( task.type === mft.TASK_TYPE_UPLOAD_FIRMWARE || task.type === mft.TASK_TYPE_UPLOAD_NOTE_TEMPLATE ) {
      if ( typeof task.filepath !== 'string' ) {
        throw new TypeError('filepath must be set');
      }
      if ( typeof task.filename !== 'string' ) {
        throw new TypeError('filename must be set');
      }
    }
    return true;
  }

  /**
   * Cancel designated download/upload.
   *
   * 指定したダウンロード/アップロードをキャンセルする。
   *
   * @param {string} type A task type to cancel.
   *
   * @param {string} documentId A documentId to cancel download
   *   task. This parameter is only required to cancel downloading.
   *
   * @param {string} parentFolderPath A parentFolderPath to cancel
   *   uploading task.  task. This parameter is only required to
   *   cancel uploading.
   *
   * @param {function(?Error)} callback The callback to get cert
   *   result. The callback will be called when cancellation is done.
   *   <br>
   *   結果を受け取るためのCallback。Callbackは、キャンセル処理が完了
   *   したときに呼び出される。
   */
  cancelWaitingTask(task, callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    // [2016-07-13 15:24:28+09:00] kan.k: [TODO] Implement.
    this.validateTask_(task);
    
    for ( var i in this.queue_ ) {
      var candidateTask = this.queue_[i];
    }
    
    console.warn('Not implemented');
  }

  /**
   * Cancel all waiting download/upload in this instance.
   *
   * このインスタンスで扱っている実行前のダウンロード/アップロードを全
   * てキャンセルする。
   *
   * @param {function(?Error)} callback The callback to get cert
   *   result. The callback will be called when cancellation is done.
   *   <br>
   *   結果を受け取るためのCallback。Callbackは、キャンセル処理が完了
   *   したときに呼び出される。
   */
  cancelAllWaitingTasks(callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }

    // var queue = this.getWaitingTaskList();

    var task = this.queue_.shift();

    while ( typeof task !== 'undefined' ) {
      task.callback(mwe.genError(mwe.E_MW_CANCELLED, 'Task cancelled'));
      task = this.queue_.shift();
    }

    callback(null);
    
    // for ( var i in queue ) {
    //   var task = queue[i];
    // }
    // console.warn('Not implemented');
    // [2016-07-13 15:24:28+09:00] kan.k: [TODO] All canceled.
  }

  /**
   * Cancel all download/upload in this instance.
   *
   * このインスタンスで扱っているダウンロード/アップロードを全てキャン
   * セルする。
   *
   * @param {function(?Error)} callback The callback to get cert
   *   result. The callback will be called when cancellation is done.
   *   <br>
   *   結果を受け取るためのCallback。Callbackは、キャンセル処理が完了
   *   したときに呼び出される。
   */
  cancelAllTasks(callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }

    this.cancelAllWaitingTasks((err) => {
      if ( err ) {
        callback(err);
        return;
      }

      this.cancelCurrent((err) => {
        if ( err ) {
          callback(err);
          return;
        }
        callback(null);
      });
    });
    // console.warn('Not implemented');
    // [2016-07-13 15:24:28+09:00] kan.k: [TODO] All canceled.
    // cancelAllWaitingTasks(function(err) {
    //   if ( err ) {
    //   }
    // });
  }

  ///////////////////////////////////
  ///   Utility Function
  ///////////////////////////////////
  
  /**
   * Get cert content by filepath.
   * <br>
   * ファイルパスで指定された証明書の内容を読み込む関数。
   *
   * @param {string} filepath The full path to the file to read.
   *   <br>
   *   読み込むファイルへのフルパス。
   *
   * @param {function(Error, data)} callback The callback to get cert
   *   result. When failed to read an Error object will be returned to
   *   first argument. When succeed, the base64 encoded data will be
   *   returned as 2nd argument. The error code of the Error object
   *   are:
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   - E_MW_FILE_SIZE_EXCEED
   *
   *   <br>
   *   結果を受け取るCallback関数。取得に失敗した場合には、第一引数に
   *   Errorオブジェクトが返る。成功した場合には、第二引数にbase64
   *   encodeされたデータが返る。返る場合のあるエラーコードは次のもの:
   *   - E_MW_FILE_READ_LOCAL_FAILED
   *   - E_MW_FILE_SIZE_EXCEED
   *   
   */
  getCert(filepath, callback) {
    if ( typeof callback !== 'function' ) {
      throw new TypeError('callback must be a function');
    }
    fs.stat(filepath, function(err, stat) {
      if ( err ) {
        callback(mwe.genError(
          mwe.E_MW_FILE_READ_LOCAL_FAILED, 'Failed to read file.', err));
        return;
      }
      if ( stat.size > MAX_CERT_SIZE ) {
        callback(mwe.genError(
          mwe.E_MW_FILE_SIZE_EXCEED_LIMIT, 'File size leach limit.'));
        return;
      }
      
      fs.readFile(filepath, 'binary', function(err, data) {
        if ( err ) {
          callback(mwe.genError(
            mwe.E_MW_FILE_READ_LOCAL_FAILED, 'Failed to read file.', err));
          // callback(err);
          return;
        }
        var encoded = btoa(data);
        callback(null, encoded);
        return;
      });
    });
  }

  /**
   * Helper function.
   * 
   * @private
   */
  callWebApi(method, apiPath, body, callback) {
    return this.fileTransfer_.callWebApi(method, apiPath, body, callback);
  }
}

