/**
 * Win/MacにUSB(RNDIS/CDC-ECM)で接続されたDPTの一覧を取り扱う。
 */

'use strict';

const log_error = require('debug')('mw-usb-initiator:dpt-usb-ethernet-enumerator:error');
const log_debug = require('debug')('mw-usb-initiator:dpt-usb-ethernet-enumerator:debug');

const DPT = require('./dpt-constants');
const UsbNicFinder = require('usb-ethernet-finder-mw');
const retry = require('retry');


class DptUsbEthernetEnumerator {

  /**
   * @constructor
   */
  constructor() {
    this.isRetrying_ = false;
    this.isRetryStopped_ = false;
    this.retryStopCallback = null;
  }

  /**
   * Win/MacにUSB(RNDIS/CDC-ECM)で接続されているDPTを列挙する。
   *
   * @param {Object:DptUSbDetector}
   *    USB接続されているDPTを検出するためのオブジェクト。
   * @param {function(error:Error, usbEthernetArray:Array.<Object>)} callback
   *    USB(RNDIS/CDC-ECM)の列挙結果通知用のcallback。
   */
  startEnumerating(usbDetector, callback) {
    log_debug('startEnumerating()');

    if (typeof callback !== 'function') {
      const err = new TypeError('[ERROR] callback !== function [' + typeof callback + ']');
      log_error(err);
      throw err;
    }

    // 既にリトライ中の場合には何もしない
    if (this.isRetrying_) {
      return;
    }
    this.isRetrying_ = true;
    this.isRetryStopped_ = false;

    // リトライの設定
    // 1秒間隔で最大10分間リトライする
    const operation = retry.operation({
      retries: 600,     // 最大600回再試行
      factor: 1,        // 待機時間を1倍ずつ更新
      minTimeout: 1000, // 最小1,000msec後に再試行
      maxTimeout: 1000  // 最大1,000msec後に再試行
    });

    const _self = this;
    operation.attempt(function () {
      if (_self.isRetryStopped_) {
        _self.retryStopCallback(null);
        return;
      }

      // DPTのUSB(Ethernet)を列挙する
      DptUsbEthernetEnumerator.enumOnce(usbDetector, function onEnum(error, dptIpArray) {
        if (!operation.retry(error)) {
          if (!error) {
            callback(null, dptIpArray);
          }
          else {
            // リトライしてもエラーだった場合 （USBの数と、NICの数とが合わない場合など）
            // Win/MacにUSB(RNDIS/CDC-ECM)で接続されたDPTの一覧をそのまま返す。          
            UsbNicFinder.find(DPT.VID_SONY, DPT.PID_ETHERNET, function (error, usbEthernetArray) {
              if (error) {
                log_error(error);
                callback(error);
                return;
              }
              if (!Array.isArray(usbEthernetArray)) {
                const err = new TypeError('[ERROR] usbEthernetArray is not Array : ' + usbEthernetArray);
                log_error(err);
                callback(err);
                return;
              }
              callback(null, usbEthernetArray);
            });
          }
          _self.isRetrying_ = false;
        }
      });
    });
  }

  /**
   * USB(RNDIS/CDC-ECM)で接続されているDPT列挙のリトライ処理を終了させる。
   * 
   * @param {function()} callback
   */
  stopEnumerating(callback) {
    log_debug('stopEnumerating()');

    if (typeof callback !== 'function') {
      const err = new TypeError('callback !== function  [' + typeof callback + ']');
      log_error(err);
      throw err;
    }

    if (!this.isRetrying_) {
      callback(null);
      return;
    }
    this.isRetryStopped_ = true;
    this.retryStopCallback = callback;
  }


  /**
   * Win/MacにUSB(RNDIS/CDC-ECM)で接続されたDPTを列挙する。
   *
   * @private
   * @param {function(error:Error, usbEthernetArray:Array.<Object>)} callback
   *    - USB(RNDIS/CDC-ECM)の列挙結果通知用のcallback。
   */
  static enumOnce(usbDetector, callback) {

    Promise.resolve()
      // 1. USB(RNDIS/CDC-ECM)の数をカウント
      .then(function onFullfilled() {
        return new Promise(function (resolve, reject) {
          log_debug('DptUsbDetector#countUsbEthernet()');
          usbDetector.countUsbEthernet(function onCount(error, count) {
            if (error) {
              log_error(error);
              reject(error);
              return;
            }
            log_debug('DptUsbDetector#countUsbEthernet() Count: ' + count);
            resolve(count);
          });
        });
      })
      // 2. DPTのNetworkAdpaterの列挙
      .then(function onFullfilled(count) {
        return new Promise(function (resolve, reject) {
          // DPTのUSB(Ethernet)の一覧を列挙する
          UsbNicFinder.find(DPT.VID_SONY, DPT.PID_ETHERNET, function (error, usbEthernetArray) {
            if (error) {
              log_error(error);
              reject(error);
              return;
            }
            if (!Array.isArray(usbEthernetArray)) {
              const err = new TypeError('[ERROR] usbEthernetArray is not Array : ' + usbEthernetArray);
              log_error(err);
              reject(err);
              return;
            }
            // IPv6 Address を持つUSB(Ethernet)のみを取り出す
            const ipV6UsbEtherArray = DptUsbEthernetEnumerator.extractUsbEthernetHasIpV6_(usbEthernetArray);
            if (count != ipV6UsbEtherArray.length) {
              const err = new Error('[ERROR] The number of USB(Ethernet) is invalid. USB:' + count + ' Ether:' + ipV6UsbEtherArray.length);
              log_error(err.message);
              reject(err);
              return;
            }
            resolve(ipV6UsbEtherArray);
          });
        });
      })
      // 3. 結果をcallbackする
      .then(function onFullfilled(usbEthernetArray) {
        callback(null, usbEthernetArray);
      }, function onRejected(error) {
        callback(error);
      });
  }
  
  /**
   * @private
   */
  static extractUsbEthernetHasIpV6_(usbEthernetArray) {
    let ipV6UsbEtherArray = [];
    for (let i = 0; i < usbEthernetArray.length; i++) {
      const usbEther = usbEthernetArray[i];
      if (DptUsbEthernetEnumerator.hasIpV6_(usbEther)) {
        ipV6UsbEtherArray.push(usbEther);
      }
    }
    return ipV6UsbEtherArray;
  }

  /**
   * @private
   */
  static hasIpV6_(usbEther) {
    if (!usbEther) {
      log_error(new Error('[ERROR] usbEther is illegal.'));
      return false;
    }
    if (!Array.isArray(usbEther.ipInfoArray)) {
      log_error(new Error('[ERROR] usbEther.ipInfoArray is not Array.'));
      return false;
    }
    
    for (let i = 0; i < usbEther.ipInfoArray.length; i++) {
      const ipInfo = usbEther.ipInfoArray[i];
      if (!ipInfo) {
        log_error(new Error('[ERROR] ipInfo is illegal.'));
        continue;
      }
      if (ipInfo.family === 'IPv6') {
        return true;
      }
    }
    return false;
  }
  
}

module.exports = DptUsbEthernetEnumerator;
