/**
    portfwdr.js
    
    created:    [2016-05-19 22:03:30+09:00]
    modified:   [2016-07-05 16:24:36+09:00]
    description:
    Port Forwarder interface and implementation.
*/

'use strict';


/** 
 * @exports portfwdr 
 *
 * @desc Port forwarder function to forward HTTP/HTTPS connection from
 *   Electron to Deneb.
 */
const portfwdr = exports;

const net = require('net');

const mwe = require('mw-error');

const debug = require('debug')('mw-port-fwdr');
const debugPortIncrement = require('debug')('port-increment');

var localHost = 'localhost';

const LOCAL_HTTP_PORT_BASE = process.env.MW_PORTFWDR_PORT_HTTP_FIRST;
const LOCAL_HTTP_PORT_LAST = process.env.MW_PORTFWDR_PORT_HTTP_LAST;

const LOCAL_HTTPS_PORT_BASE = process.env.MW_PORTFWDR_PORT_HTTPS_FIRST;
const LOCAL_HTTPS_PORT_LAST = process.env.MW_PORTFWDR_PORT_HTTPS_LAST;

const TIME_OUT = Number(process.env.MW_PORTFWDR_CONNECT_TIMEOUT);
// var portShift =0;

var nowUsingPortFwdrNum = 0;

/**
 * Create new PortFwdr instance.
 *
 * @return {PortFwdr}
 */
exports.createPortFwdr = function() {
  // portShift = (portShift + 1) % 100;
  return new PortFwdr();
};

/**
 * Port Forwarder for Altair.
 */
class PortFwdr {
  constructor(){
    this.httpForwarder = null;
    this.httpsForwarder = null;
    // this.localHttpPort_ = LOCAL_HTTP_PORT_BASE;
    // this.localHttpsPort_ = LOCAL_HTTPS_PORT_BASE;
    this.localHttpPort_ = null;
    this.localHttpsPort_ = null;
  }

  /**
   * Start port forwarders.
   * When port forwarder is already running, this call will restart port
   * forwarder.
   * Port numbers that returned by getHttpPort() and getHttpsPort()
   * will be set after this procedure. Or when this function is called
   * again these port number may be changed.
   * <br>
   * Port forwarder を開始する。
   * Port forwarder がすでに開始されている場合は、この呼び出しで、リス
   * タートする。
   * getHttpPort()や、getHttpsPort()で返ってくるPort番号は、この処理の
   * 後に設定される。また再度呼び出された場合にはポート番号は処理の後
   * に更新される場合がある。

   * @note When destination IP and/or port is not exists, this
   *   function will just success. In such case, a TCP connection to
   *   source IP and port will just be closed
   *   <br>
   *   転送先のIPやPortが存在しない場合でも、この関数は成功する。その
   *   場合には、転送元のIPとPortに対してTCP接続を貼ろうとした時点で接
   *   続を切断される。
   * 
   * @param {string} toIpAddr The destination IP address to forward
   *   connections.
   *   <br>
   *   接続転送時の、転送先のIPアドレス。
   *
   * @param {number} toPortHttp The destination port number to forward
   *   HTTP connection.
   *   <br>
   *   HTTP接続転送時の、転送先のPort番号。
   *
   * @param {number|null} toPortHttps The destination port number to
   *   forward HTTPS connections. When `null` is specified no HTTPS
   *   port forwarder will be setup.
   *   <br>
   *   HTTPS接続転送時の、転送先のPort番号。`null`が指定された場合には、
   *   HTTPSのPort Forwarderはセットアップされない。
   *
   * @param {function(?Error)} callback The function to be called when
   *   connect is port forwarder is prepared.. When failed to connect,
   *   the Error object will be passed as a first argument. The error code 
   *   can be returned are:
   *   - E_MW_PORTFWDR_PORT_UNAVAILABLE
   *   - E_MW_PORTFWDR_FAILED_TO_LISTEN_PORT
   *   <br>
   *   Port Forwarderが、準備できた際に呼び出されるCallback。失敗した
   *   場合には、第一引数にErrorオブジェクトが返る。Error codeは次のも
   *   のが返る:
   *   - E_MW_PORTFWDR_PORT_UNAVAILABLE
   *   - E_MW_PORTFWDR_FAILED_TO_LISTEN_PORT
   *
   */
  start(toIpAddr, toPortHttp, toPortHttps, callback) {

    if ( typeof toIpAddr !== 'string' ) {
      throw new TypeError('toIpAddr is not string');
    }
    if ( typeof toPortHttp !== 'number' ) {
      throw new TypeError('toPortHttp is not a number');
    }
    if ( typeof toPortHttps !== 'number' && toPortHttps !== null ) {
      throw new TypeError('toPortHttps is not a number');
    }
    if ( this.httpForwarder !== null ) {
      this.httpForwarder.close();
      this.httpForwarder = null;
    }
    if ( this.httpsForwarder !== null ) {
      this.httpsForwarder.close();
      this.httpsForwarder = null;
    }

    var self = this;

    nowUsingPortFwdrNum++;

    this.httpForwarder = this.startForwarder(
      toIpAddr, toPortHttp,
      localHost, LOCAL_HTTP_PORT_BASE, LOCAL_HTTP_PORT_LAST,function(err, fromHttpPort) {
        
        nowUsingPortFwdrNum--;

        if ( err ) {
          callback(err);
          return;
        }

        debug('local port fowarder for HTTP started from: ', fromHttpPort, ' to: ', toIpAddr, toPortHttp);
        self.localHttpPort_ = fromHttpPort;

        if ( toPortHttps === null ) {
          callback(null);
          return;
        }
        
        nowUsingPortFwdrNum++;

        self.httpsForwarder = self.startForwarder(
          toIpAddr, toPortHttps,
          localHost, LOCAL_HTTPS_PORT_BASE, LOCAL_HTTPS_PORT_LAST, function(err, fromHttpsPort) {
            
            nowUsingPortFwdrNum--;

            if ( err ) {
              callback(err);
              return;
            }

			debug('local port fowarder for HTTPS started from: ', fromHttpsPort, ' to: ', toIpAddr, toPortHttps);
            self.localHttpsPort_ = fromHttpsPort;
            callback(null);
          });
      });
  }

  /**
   * @private
   */
  startForwarder(toIpAddr, toPort, fromHost, fromPortBase, fromPortLast, callback) {

    // initialize.
    var fromPort = fromPortBase;
    
    var portForwarder = net.createServer(function(from) {
      var to = net.createConnection({
        host: toIpAddr,
        port: toPort});

      to.on('error', function(err) {
        debug('to.pip connection error: ', from.remotePort, err);
        // console.error('toerr: ', from.remotePort, err);
        from.end();
        from.destroy();
      });
      from.pipe(to);
      to.pipe(from);
    });

    // Change 'true' when callback.
    var handled = false;
    
    portForwarder.on('listening', function() {
      if ( handled ) {
        return;
      }

      // Initialize.
      fromPort = portForwarder.address().port;

      // Successful processing is done when connected.
      var client = net.createConnection(fromPort, fromHost, function(){

        client.end();
        client.destroy();

        debugPortIncrement('connect OK:', fromPort);

        callback(null, fromPort);
        handled = true;
      });
      
      client.setTimeout(TIME_OUT);

      client.on('timeout', function(){

        debugPortIncrement('timeout(firewall?):', fromPort);

        client.end();
        client.destroy();

        // Re try listen.
        // Increment.
        fromPort++;

        // Failure processing is done when fromPort is greater than fromPortLast.
        if ( fromPort > fromPortLast ) {
          debugPortIncrement('port range over...');
          callback(mwe.genError(mwe.E_MW_PORTFWDR_PORT_UNAVAILABLE, 'No available port.', null));
          handled = true;
          return;
        }

        // Close current port, and Listen on the new port.
        portForwarder.close(function(){
          portForwarder.listen(fromPort,fromHost);
        });
      });


      client.on('error', function(err){
        
        if(err.code === 'ETIMEDOUT'){
          debugPortIncrement('timeout[Occur ETIMEDOUT](firewall?):', fromPort);
        }
        else{
          debugPortIncrement("occur err",err);
        }

        client.end();
        client.destroy();

        // Re try listen.
        // Increment.
        fromPort++;

        // Failure processing is done when fromPort is greater than fromPortLast.
        if ( fromPort > fromPortLast ) {
          debugPortIncrement('port range over...');
          callback(mwe.genError(mwe.E_MW_PORTFWDR_PORT_UNAVAILABLE, 'No available port.', err));
          handled = true;
          return;
        }

        // Close current port, and Listen on the new port.
        portForwarder.close(function(){
          portForwarder.listen(fromPort,fromHost);
        });
      });
    });
    
    portForwarder.on('error', function(err) {

      if ( err.code === 'EADDRINUSE' || err.code === 'EACCES' ) {
        debug('fromPort looks in use. trying to listen another port: ', fromPort, err);
        
        // Re try listen.
        // Increment.
        fromPort++;

        // Failure processing is done when fromPort is greater than fromPortLast.
        if ( fromPort > fromPortLast ) {
          debugPortIncrement('port range over...');
          callback(mwe.genError(mwe.E_MW_PORTFWDR_PORT_UNAVAILABLE, 'No available port.', err));
          handled = true;
          return;
        }

        // Close current port, and Listen on the new port.
        portForwarder.close(function(){
          portForwarder.listen(fromPort,fromHost);
        });
        return;
      }

      callback(mwe.genError(mwe.E_MW_PORTFWDR_FAILED_TO_LISTEN_PORT, 'Failed to open local port', err));
      handled = true;
    });

    var ret = portForwarder.listen(fromPort, fromHost);
    
    return portForwarder;
  }

  /**
   * Get host name of forwarding source.
   * <br>
   * 転送元のHost名を取得する。
   *
   * @return {string}
   */
  getHost() {
    return localHost;
  }

  /**
   * Get from port to forward HTTP connections.
   * This port number is selected automatically when port forwarder
   * starts. Before port forwarder successfully initialized, this may
   * return null.
   * <br>
   * HTTP転送時の転送元のPort番号を取得する。
   * このPort番号は、Port Forwarder開始時に自動的に選択される。
   * Port Forwarderが初期化されるまでは、この関数はnullを返す場合がある。
   *
   * @return {number|null} Selected port number for HTTP.
   *   <br>
   *   HTTPのために選択されたPort番号
   */
  getHttpPort() {
    return this.localHttpPort_;
  }

  /**
   * Get from port to forward HTTPS connections.
   * This port number is selected automatically when port forwarder
   * starts.
   * <br>
   * HTTPS転送時の転送元のPort番号を取得する。
   * このPort番号は、Port Forwarder開始時に自動的に選択される。
   *
   * @return {number|null} Selected port number for HTTPS.
   *   <br>
   *   HTTPSのために選択されたPort番号
   */
  getHttpsPort() {
    return this.localHttpsPort_;
  }

  /**
   * Update from ports and restart port forwarder.
   * <br>
   * 転送元のPort番号を更新して、Port Forwarderを再開する。
   * @depelecated
   */
  // updateSourcePort(callback) {
  //    // throw new Error('Not implemented');
  // }
  
  /**
   * Close all port forwarders in this instance. This must be called
   * before releasing this instance. If the application is just
   * terminating, it is not necessary.
   * <br>
   * このInstanceで扱っているport forwarderを全部閉じる。このインスタ
   * ンスを解放される前に呼ぶ必要がある。 ただし明示的にアプリケーショ
   * ンが終了する場合にはその必要はない。
   */
  close() {
    if ( this.httpForwarder !== null ) {
      this.httpForwarder.close();
      this.httpForwarder = null;
    }
    if ( this.httpsForwarder !== null ) {
      this.httpsForwarder.close();
      this.httpsForwarder = null;
    }
  }
}


exports.PortFwdr = PortFwdr;

// Connection Recovery用(ExplorerBaseView)
// PortForwaderを使用している場合: true
// 以外:false
portfwdr.isNowUsing = function(){
  debug('nowUsingPortFwdrNum:', nowUsingPortFwdrNum);
  return nowUsingPortFwdrNum != 0;
}