'use strict';

const log_error = require('debug')('mw-automagic-client:update-info-parser:error');
const log_debug = require('debug')('mw-automagic-client:update-info-parser:debug');

const AutoMagic = require('./automagic');
const request = require('request');
const xml2js = require('xml2js');
const fs = require('fs');
const md5 = require('./md5');
const osVersion = require('./os-info').version();
const defaultComparator = require('./default-comparator');
const versionComparator = require('./version-comparator');
const mwe = require('mw-error');



const RULE_TYPE_SYSTEM = 'System';
const RULE_KEY_FIRM_VERSION = 'FirmwareVersion';
const RULE_KEY_OS_VERSION = 'OSVersion';
const RULE_KEY_MODEL = 'Model';

const RULE_OP_EQUAL = 'Equal';
const RULE_OP_NOT_EQUAL = 'NotEqual';
const RULE_OP_LESS_THAN = 'LessThan';
const RULE_OP_LESS_THAN_EQUAL = 'LessThanEqual';
const RULE_OP_GREATER_THAN = 'GreaterThan';
const RULE_OP_GREATER_THAN_EQUAL = 'GreaterThanEqual';

const DISTRIBUTION_INSTALL_TYPE_BIN = 'binary';
const DISTRIBUTION_INSTALL_TYPE_EXE = 'exe';
const DISTRIBUTION_INSTALL_TYPE_MSI = 'msi';
const DISTRIBUTION_INSTALL_TYPE_EULA = 'EULA';
const DISTRIBUTION_INSTALL_TYPE_DISCLAIMER = 'notice';



class UpdateInfoParser {

  /**
   * 「アップデート情報ファイル」を検証し、XML部分を抽出する。
   * 
   * @param {string} data       文字列形式の「アップデート情報ファイル」
   * @param {string} categoryId Category ID
   * @param {string} serviceId  Service ID
   * @param {function} callback 処理結果通知用のcallback関数
   */
  static verify(data, categoryId, serviceId, callback) {
    log_debug('parse()');

    if (typeof data !== 'string') {
      const err = new TypeError('[ERROR] data must be a string. (' + typeof data + ')');
      log_error(err);
      throw err;
    }

    if (typeof callback !== 'function') {
      const err = new TypeError('[ERROR] callback must be a function. (' + typeof callback + ')');
      log_error(err);
      throw err;
    }

    // Header と Body(XML) とを分離する
    let start = 0;
    let end = data.indexOf('\n', start);
    const eaid = data.slice(start, end);
    start = end + 1;
    end = data.indexOf('\n', start);
    const daid = data.slice(start, end);
    start = end + 1;
    end = data.indexOf('\n', start);
    const digest = data.slice(start, end);
    start = end + 2;
    const xml = data.slice(start);

    // Header Part を検証する
    if (eaid !== 'eaid:ENC0001') {
      callback(mwe.genError(mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE,
      'eaid must be ENC0001. (' + eaid + ')'));
      return;
    }

    if (daid !== 'daid:HAS0002') {
      const err = new Error('[ERROR] daid must be HAS0002. (' + daid + ')');
      callback(mwe.genError(mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE,
      'daid must be HAS0002. (' + daid + ')'));
      return;
    }

    const digestCheck = digest.match(/(digest:)(.*)/);
    if (!digestCheck || !digestCheck[2]) {
      callback(mwe.genError(mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE,
      'Invalid digest. (' + digest + ')'));
      return;
    }

    // MD5 で「アップデート情報ファイル」を検証する
    const specifiedMd5 = digestCheck[2];
    const calculatedMd5 = md5.md5Text(md5.md5Text(xml) + serviceId + categoryId);
    if (specifiedMd5 !== calculatedMd5) {
      callback(mwe.genError(mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE,
      'MD5 verification failed. (' + specifiedMd5 + ', ' + calculatedMd5 + ')'));
      return;
    }

    callback(null, xml);
  }


  /**
   * 「アップデート情報ファイル」のXML部分を解析する。
   *
   * @param {string} xml       文字列形式の「アップデート情報ファイル」
   * @param {function} callback 処理結果通知用のcallback関数
   */
  static parse(xml, callback) {
    log_debug('parse()');

    if (typeof xml !== 'string') {
      const err = new TypeError('[ERROR] xml must be a string. (' + typeof xml + ')');
      log_error(err);
      throw err;
    }

    if (typeof callback !== 'function') {
      const err = new TypeError('[ERROR] callback must be a function. (' + typeof callback + ')');
      log_error(err);
      throw err;
    }

    const parser = new xml2js.Parser({ trim: true });
    parser.parseString(xml, function (err, result) {
      if (err) {
        callback(mwe.genError(mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE, 'Parse failed.', err));
        return;
      }

      const updateInfoArray = [];
      try {
        // 無効化(Noop)の確認
        if (result.InformationFile.$.Noop === 'true') {
          callback(mwe.genError(mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE,
          'This information file is disabled'));
          return;
        }

        // 適用条件の取得
        const applyConditionArray = result.InformationFile.ApplyConditions[0].ApplyCondition;
        for (let i = 0; i < applyConditionArray.length; i++) {
          const ruleArray = applyConditionArray[i].Rules[0].Rule;
          const distributionArray = applyConditionArray[i].Distributions[0].Distribution;
          const descriptions = applyConditionArray[i].Descriptions[0];
          updateInfoArray.push({
            rules: ruleArray,
            distributions: distributionArray,
            descriptions: descriptions
          });
        }
      }
      catch (e) {
        let err = e;
        if (!(err instanceof Error)) {
          err = new Error('Error: ' + e);
        }
        callback(mwe.genError(mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE, 'Parse failed.', err));
        return;
      }

      callback(null, updateInfoArray);
    });
  }

  /**
   * アプリのアップデートを確認する。
   *
   * @param {string} appVersion       アプリのバージョン
   * @param {string} languageCode     アプリの表示言語（Auto Magic 言語コード）
   * @param {string} updateInfoArray  アップデートの適用条件
   * @param {function} callback       処理結果通知用のcallback関数
   */
  static checkForAppUpdate(
    appVersion,
    languageCode,
    updateInfoArray,
    callback
  ) {
    log_debug('checkForAppUpdate()');

    NEXT_TARGET: for (let i = 0; i < updateInfoArray.length; i++) {
      try {
        const updateInfo = updateInfoArray[i];

        // アップデート適用条件を確認する
        for (let j = 0; j < updateInfo.rules.length; j++) {
          const rule = updateInfo.rules[j];

          // Type: System
          if (rule.$.Type !== RULE_TYPE_SYSTEM) {
            throw new Error('Unsupported Type is found. (' + rule.$.Type + ')');
          }

          // Key: FirmwareVersion or OSVersion
          let current = null;
          let comparator = null;
          switch (rule.$.Key) {
            case RULE_KEY_FIRM_VERSION:
              current = appVersion;
              comparator = versionComparator;
              break;

            case RULE_KEY_OS_VERSION:
              current = osVersion;
              comparator = versionComparator;
              break;

            default:
              throw new Error('Unsupported Key is found. (' + rule.$.Key + ')');
          }

          // Value
          const value = rule.$.Value;
          if (!value) {
            throw new Error('Invalid Value is found. (' + value + ')');
          }

          // Operator
          if (!this.compare(rule.$.Operator, current, value, comparator)) {
            continue NEXT_TARGET;
          }
        }

        // アップデートの適用条件を満たしている場合

        // 「配布物」の一覧を取得する
        const distributions = this.parseDistributions(updateInfo.distributions);
        distributions.updater.oldVersion = appVersion;

        // 「アップデート内容」を取得する
        const descriptions = this.parseDescriptions(updateInfo.descriptions);

        // アプリの表示言語に合った文言を探す
        let description = null;
        if (languageCode) {
          description = descriptions.map.get(languageCode);
        }
        if (!description) {
          description = descriptions.map.get(descriptions.defaultLang);
        }

        // 「配布物」「アップデート内容」をcallbackする
        callback(null, {
          updater: distributions.updater,
          description: description,
          disclaimer: distributions.disclaimer,
          eula: distributions.eula
        });
        return;
      }
      catch (error) {
        log_error(error);
      }
    }

    // アップデートが見つからなかった場合
    callback(null, null);
  }
      
  /**
   * デバイスのアップデートを確認する。
   *
   * @param {string} deviceVersion    デバイスのバージョン
   * @param {string} deviceModel      デバイスのモデル名
   * @param {string} languageCode     アプリの表示言語（Auto Magic 言語コード）
   * @param {string} updateInfoArray  アップデートの適用条件
   * @param {function} callback       処理結果通知用のcallback関数
   */
  static checkForDeviceUpdate(
    deviceVersion,
    deviceModel,
    languageCode,
    updateInfoArray,
    callback
  ) {
    log_debug('checkForDeviceUpdate()');

    NEXT_TARGET: for (let i = 0; i < updateInfoArray.length; i++) {
      try {
        const updateInfo = updateInfoArray[i];

        // アップデート適用条件を確認する
        for (let j = 0; j < updateInfo.rules.length; j++) {
          const rule = updateInfo.rules[j];

          // Type: System
          if (rule.$.Type !== RULE_TYPE_SYSTEM) {
            throw new Error('Unsupported Type is found. (' + rule.$.Type + ')');
          }

          // Key: FirmwareVersion
          let current = null;
          let comparator = null;
          switch (rule.$.Key) {
            case RULE_KEY_FIRM_VERSION:
              current = deviceVersion;
              comparator = versionComparator;
              break;

            case RULE_KEY_MODEL:
              current = deviceModel;
              comparator = defaultComparator;
              break;

            default:
              throw new Error('Unsupported Key is found. (' + rule.$.Key + ')');
          }

          // Value
          const value = rule.$.Value;
          if (!value) {
            throw new Error('Invalid Value is found. (' + value + ')');
          }

          // Operator
          if (!this.compare(rule.$.Operator, current, value, comparator)) {
            continue NEXT_TARGET;
          }
        }

        // アップデートの適用条件を満たしている場合

        // 「配布物」の一覧を取得する
        const distributions = this.parseDistributions(updateInfo.distributions);
        distributions.updater.oldVersion = deviceVersion;

        // 「アップデート内容」を取得する
        const descriptions = this.parseDescriptions(updateInfo.descriptions);

        // アプリの表示言語に合った文言を探す
        let description = null;
        if (languageCode) {
          description = descriptions.map.get(languageCode);
        }
        if (!description) {
          description = descriptions.map.get(descriptions.defaultLang);
        }

        // 「配布物」「アップデート内容」をcallbackする
        callback(null, {
          updater: distributions.updater,
          description: description,
          disclaimer: distributions.disclaimer,
          eula: distributions.eula
        });
        return;
      }
      catch (error) {
        log_error(error);
      }
    }

    // アップデートが見つからなかった場合
    callback(null, null);
  }

  /**
   * 「アップデート情報ファイル」の<Rules>の値を実際の値と比較する。
   *    /InformationFile/ApplyConditions/ApplyCondition/Rules
   *
   * @param {string} operator
   * @param {string} left
   * @param {string} right
   * @param {object} comparator
   * @return {boolean}
   * @private
   */
  static compare(
    operator,
    left,
    right,
    comparator
  ){
    switch (operator) {
      case RULE_OP_EQUAL:
        return comparator.equal(left, right);

      case RULE_OP_NOT_EQUAL:
        return comparator.notEqual(left, right);

      case RULE_OP_LESS_THAN:
        return comparator.lessThan(left, right);

      case RULE_OP_LESS_THAN_EQUAL:
        return comparator.lessThanEqaul(left, right);

      case RULE_OP_GREATER_THAN:
        return comparator.greaterThan(left, right);

      case RULE_OP_GREATER_THAN_EQUAL:
        return comparator.greaterThanEqual(left, right);

      default:
        throw new Error('Unsupported Operator is found. (' + operator + ')');
    }
  }


  /**
   * 「アップデート情報ファイル」の<Distributions>を解析する。
   *    /InformationFile/ApplyConditions/ApplyCondition/Distributions
   *
   * @param {object} distributions
   * @return {object}
   * @private
   */
  static parseDistributions(
    distributions
  ) {
    log_debug('parseDistributions()');

    let updater = null;
    let eula = null;
    let disclaimer = null;

    for (let i = 0; i < distributions.length; i++) {
      const distribution = distributions[i];

      // Version
      const contentVersion = distribution.$.Version;
      if (!contentVersion) {
        throw new Error('Invalid Version is found. (' + contentVersion + ')');
      }

      // URI
      const contentUrl = distribution.$.URI;
      if (!contentUrl) {
        throw new Error('Invalid URI is found. (' + contentUrl + ')');
      }

      // MAC
      const contentHash = distribution.$.MAC;
      if (!contentHash) {
        throw new Error('Invalid MAC is found. (' + contentHash + ')');
      }

      // Size
      const contentSize = parseInt(distribution.$.Size, 10);
      if (contentSize <= 0) {
        throw new Error('Invalid Size is found. (' + contentSize + ')');
      }

      // object に格納する
      const content = {
        url: contentUrl,
        md5: contentHash,
        size: contentSize
      };

      // InstallType
      switch (distribution.$.InstallType) {
        case DISTRIBUTION_INSTALL_TYPE_BIN:
        case DISTRIBUTION_INSTALL_TYPE_EXE:
        case DISTRIBUTION_INSTALL_TYPE_MSI:
          updater = content;
          updater.newVersion = contentVersion;
          break;

        case DISTRIBUTION_INSTALL_TYPE_EULA:
          eula = content;
          break;

        case DISTRIBUTION_INSTALL_TYPE_DISCLAIMER:
          disclaimer = content;
          break;

        default:
          throw new Error('Unsupported InstallType is found. (' + distribution.$.InstallType + ')');
      }
    }

    if (updater === null) {
      throw new Error('updater is not found.');
    }

    if (eula === null) {
      throw new Error('eula is not found.');
    }

    if (disclaimer === null) {
      throw new Error('disclaimer is not found.');
    }

    return {updater: updater, eula: eula, disclaimer: disclaimer};
  }

  /**
   * 「アップデート情報ファイル」の<Descriptions>を解析する。
   *    /InformationFile/ApplyConditions/ApplyCondition/Descriptions
   *
   * @param {object} descriptions
   * @return {object}
   * @private
   */
  static parseDescriptions(
    descriptions
  ) {
    log_debug('parseDescriptions()');

    const descriptionMap = new Map();
    const descriptionArray = descriptions.Description;
    for (let i = 0; i < descriptionArray.length; i++) {
      const description = descriptionArray[i];

      const language = description.$.Lang.toUpperCase();
      if (!language) {
        throw new Error('Invalid Lang is found. (' + language + ')');
      }

      const strings = description._;
      if (!strings) {
        throw new Error('Invalid TEXT is found. (' + strings + ')');
      }

      descriptionMap.set(language, strings);
    }

    const defaultLang = descriptions.$.DefaultLang.toUpperCase();
    if (!descriptionMap.has(defaultLang)) {
      throw new Error('Invalid DefaultLang is found. (' + defaultLang + ')');
    }

    return {map: descriptionMap, defaultLang: defaultLang};
  }

}

module.exports = UpdateInfoParser;
