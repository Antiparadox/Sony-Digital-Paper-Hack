'use strict';

const log_error = require('debug')('mw-automagic-client:file-system-util:error');
const log_debug = require('debug')('mw-automagic-client:file-system-util:debug');

const fs = require('fs');
const path = require('path');
const mwe = require('mw-error');



class FileSystemUtil {

  /**
   * Win/Mac上にディクレトリを階層的に作成する
   *
   * @param {string} dirPath 作成対象のディクレトリパス
   * @param {function(?Error, dstDirPath)} callback
   */
  static makeDirRecursively(
    dirPath,
    callback
  ) {
    if (typeof dirPath !== 'string') {
      throw new TypeError('dirPath must be a string');
    }
    if (typeof callback !== 'function') {
      throw new TypeError('callback must be a function');
    }

    // [Note] Node.js の path.parse() を使用してディレクトリパスを分割したいが、
    // '\\xxx.exapmel.com'のようなUNC形式のパスが正しく分割できない。
    // （Node.js v6.1.0 にて確認）
    //
    //     > path.parse('\\\\xxx.example.com\\test');
    //     { root: '\\\\xxx.example.com\\test',
    //       dir: '\\\\xxx.example.com\\test',
    //       base: '',
    //       ext: '',
    //       name: '' }
    //
    // Windowsの場合にもファイルパスに'/'が含まれていた場合には、POSIXの流儀にあわせて
    // これを区切り文字として扱う。そのために、以下でパス内の'/'を'\'に変換する。
    if (process.platform === 'win32') {
      dirPath = dirPath.replace(/\//, path.sep);
    }

    let dirPathArray = dirPath.split(path.sep);
    if (dirPathArray.length === 0) {
      throw new Error('invalid dirPath : ' + dirPath);
    }
    if (dirPathArray[dirPathArray.length - 1] === '') {
      // フォルダパスの末尾がseparatorの場合には末尾の要素を削除する
      dirPathArray.pop();
    }

    // ルートディクレトリの取得
    //  例) ['', 'Users'] ⇒ '\Users'
    //  例) ['', '', 'xxx.example.com'] ⇒ '\\xxx.exapmel.com'
    let rootDir = dirPathArray.shift();
    if (rootDir === '') {
      rootDir = path.sep + dirPathArray.shift();
      if (rootDir === path.sep) {
        rootDir += path.sep + dirPathArray.shift();
      }
    }

    const self = this;
    this.makeChildDirRecursively(rootDir, dirPathArray, function (error, dstDirPath) {
      if (error) {
        callback(error);
        return;
      }
      callback(null, dstDirPath);
    });
  }


  /**
   * 階層的に子ディレクトリを作成する。
   *
   * @param {string} parentDirPath ディレクトリ作成先のパス
   * @param {string} childDirPathArray 階層化された子ディレクトリの名前の配列
   * @param {function(?Error, dirPath)} callback
   * @private
   */
  static makeChildDirRecursively(
    parentDirPath,
    childDirPathArray,
    callback
  ) {
    // この階層で作成するフォルダ名を取り出す
    const dirName = childDirPathArray.shift();

    // 再帰的に子フォルダを作成する
    const self = this;
    this.makeDirWithNewNameIfConflicted(parentDirPath, dirName, function (error, dstDirName) {
      if (error) {
        callback(error);
        return;
      }

      const dstDirPath = path.join(parentDirPath, dstDirName);

      if (childDirPathArray.length === 0) {
        // 全てのフォルダの作成が完了した場合
        callback(null, dstDirPath);
        return;
      }

      self.makeChildDirRecursively(dstDirPath, childDirPathArray, callback);
    });
  }

  /**
   * ディレクトリを作成する。
   * ただし、名前重複時には連番付きのディレクトリ名でディレクトリを作成する。
   *
   * @param {string} parentDirPath ディレクトリ作成先のパス
   * @param {string} dirName 作成するディレクトリの名前
   * @param {function(?Error, dirName)} callback
   * @private
   */
  static makeDirWithNewNameIfConflicted(
    parentDirPath,
    dirName,
    callback
  ) {
    // 利用可能なディレクトリ名を取得する
    const self = this;
    this.getAvailableDirName(parentDirPath, dirName, function (error, dstDirName, alreadyExists) {
      if (error) {
        callback(error);
        return;
      }

      if (alreadyExists) {
        // 利用可能なディクレトリが既に存在した場合には、そのディクレトリを使用する
        callback(null, dstDirName);
        return;
      }

      // 新規にディクレトリを作成する
      const dirPath = path.join(parentDirPath, dstDirName);
      fs.mkdir(dirPath, function (error) {
        if (error) {
          callback(mwe.genError(
            mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to create directory.', error));
          return;
        }
        callback(null, dstDirName);
      });
    });
  }

  /**
   * 利用可能なディレクトリ名を取得する。
   *
   * @param {string} parentDirPath ディレクトリ作成先のパス
   * @param {string} dirName 作成するディレクトリの名前
   * @param {function(?Error, dirName, alreadyExists)} callback
   * @private
   */
  static getAvailableDirName(
    parentDirPath,
    dirName,
    callback
  ) {
    const dirPath = path.join(parentDirPath, dirName);

    // 作成するディレクトリと同名のファイルが存在しないかを確認する
    const self = this;
    fs.stat(dirPath, function (error, stats) {
      if (error && error.code === 'ENOENT') {
        // 同名のエントリが存在しない場合
        callback(null, dirName);
        return;
      }
      if (error) {
        callback(mwe.genError(
          mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to read directory.', error));
        return;
      }

      if (stats.isDirectory()) {
        // 同名のディレクトリが存在した場合には、そのディレクトリを使用する
        const alreadyExists = true;
        callback(null, dirName, alreadyExists);
        return;
      }

      // 同名のエントリが既に存在する場合

      // 指定されたディレクトリ名に既に連番が付いていた場合には、ベースのディレクトリ名を抜き出す
      //  例) "dir (1)"  ⇒ "dir"
      //  例) "dir(1)"   ⇒ null
      //  例) "dir (01)" ⇒ nulll
      let dirBaseName = dirName;
      const result = dirName.match(/^(.*) \([1-9][0-9]*\)$/);
      if (result) {
        dirBaseName = result[1];
      }

      // 重複しない連番付きのディレクトリ名を取得する
      self.getAvailableDirNameWithIndex(parentDirPath, dirBaseName, 1, callback);
    });
  }

  /**
   * ディレクトリ名が既存のファイル名と重複した際に、連番付きのディレクトリ名を作成する。
   *
   * @param {string} parentDirPath ディレクトリ作成先のパス
   * @param {string} dirBaseName 作成するディレクトリの名前
   * @param {string} index ディレクトリ名に追加する番号
   * @param {function(?Error, dirName, alreadyExists)} callback
   * @private
   */
  static getAvailableDirNameWithIndex(
    parentDirPath,
    dirBaseName,
    index,
    callback
  ) {
    // 連番付きのディレクトリ名を用意する
    const dirName = dirBaseName + ' (' + index + ')';

    // 再帰的に未使用のディレクトリ名を探す
    const self = this;
    const dirPath = path.join(parentDirPath, dirName);
    fs.stat(dirPath, function (error, stats) {
      if (error && error.code === 'ENOENT') {
        // 同名のエントリが存在しない場合
        const alreadyExists = false;
        callback(null, dirName, alreadyExists);
        return;
      }
      if (error) {
        callback(mwe.genError(
          mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to read directory.', error));
        return;
      }

      if (stats.isDirectory()) {
        // 同名のディレクトリが存在した場合には、そのフォルダを使用する
        const alreadyExists = true;
        callback(null, dirName, alreadyExists);
        return;
      }

      self.getAvailableDirNameWithIndex(parentDirPath, dirBaseName, ++index, callback);
    });
  }


  /**
   * 新規ファイル作成時に、利用可能なファイル名を取得する。
   *
   * @param {string} parentDirPath ディレクトリのパス
   * @param {string} fileName 新規作成するファイルの名前
   * @param {function(?Error, fileName)} callback
   */
  static getAvailableFileName(
    parentDirPath,
    fileName,
    callback
  ) {
    // ファイルの作成先に同名ファイルが存在しないか確認する
    const self = this;
    const filePath = path.join(parentDirPath, fileName);
    fs.stat(filePath, function (error, stats) {
      if (error && error.code === 'ENOENT') {
        // 同名のエントリが存在しない場合
        callback(null, fileName);
        return;
      }
      if (error) {
        // エラーが発生した場合には、別のファイル名を用意する
        log_error(error);
      }

      // 同名のエントリが既に存在する場合

      // 指定されたファイル名に既に連番が含まれていた場合には、ベースのファイル名と拡張子を抜き出す
      //  例) "file (1).pdf"  ⇒ "file", ".pdf"
      //  例) "file(1) .pdf"  ⇒ null
      //  例) "file(1).pdf"   ⇒ null
      //  例) "file (01).pdf" ⇒ null
      let fileBaseName;
      let fileExt;
      let result = fileName.match(/^(.*) \([1-9][0-9]*\)(\..*)$/);
      if (result) {
        // ファイル名に連番が含まれていた場合
        fileBaseName = result[1];
        fileExt = result[2];
      }
      else {
        // ファイル名に連番が含まれていなかった場合
        //  例) "file.pdf"  ⇒ "file", ".pdf"
        result = fileName.match(/^(.*)(\..*)$/);
        fileBaseName = result[1];
        fileExt = result[2];
      }

      // 重複しない連番付きのファイル名を取得する
      self.getAvailableFileNameWithIndex(parentDirPath, fileBaseName, fileExt, 1, callback);
    });
  }

	/**
   * 新規ファイル作成時に、そのファイル名が既存のファイル名やディクレトリ名と
   * 重複した場合には、連番付きのファイル名を作成する。
   *
   * @param {string} parentDirPath ディレクトリのパス
   * @param {string} fileBaseName ファイル名
   * @param {string} fileExt ファイルの拡張子
   * @param {string} index ファイル名に追加する番号
   * @param {function(?Error, fileName)} callback
   * @private
   */
  static getAvailableFileNameWithIndex(
    parentDirPath,
    fileBaseName,
    fileExt,
    index,
    callback
  ) {
    // 連番付きのファイル名を用意する
    const fileName = fileBaseName + ' (' + index + ')' + fileExt;
    const filePath = path.join(parentDirPath, fileName);

    // 再帰的に未使用のファイル名を探す
    const self = this;
    fs.stat(filePath, function (error, stats) {
      if (error && error.code === 'ENOENT') {
        // 同名のエントリが存在しない場合
        callback(null, fileName);
        return;
      }
      if (error) {
        callback(mwe.genError(
          mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to read directory.', error));
        return;
      }

      self.getAvailableFileNameWithIndex(parentDirPath, fileBaseName, fileExt, ++index, callback);
    });
  }
}


module.exports = FileSystemUtil;
