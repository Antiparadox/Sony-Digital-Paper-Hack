'use strict';

const log_error = require('debug')('mw-automagic-client:downloader:error');
const log_debug = require('debug')('mw-automagic-client:downloader:debug');

const AutoMagic = require('./automagic');
const request = require('request');
const crypto = require('crypto');
const fs = require('fs');
const md5 = require('./md5');
const mwe = require('mw-error');
const proxyResolver = require('proxy-resolver-mw');

const HTTP_REQUEST_TIMEOUT = 60 * 1000;


class Downloader {

  constructor() {
    this.current = 0;
    this.total = 0;
    this.isRunning = false;
    this.isCancelled = false;
  }

  /**
   * ファイルをダウンロードする。
   *
   * @param {string} srcFileUrl
   * @param {string} dstFilePath
   * @param {string} userAgent
   * @param {string} md5Hash
   * @param {number} fileSize
   * @param {function(?Error)} callback
   */
  downloadFile(
    srcFileUrl,
    dstFilePath,
    userAgent,
    md5Hash,
    fileSize,
    callback
  ) {
    log_debug('downloadFile(' + srcFileUrl + ', ' + dstFilePath + ')');

    if (typeof srcFileUrl !== 'string') {
      const err = new TypeError('[ERROR] srcFileUrl must be a string. (' + typeof srcFileUrl + ')');
      log_error(err);
      throw err;
    }
    if (typeof dstFilePath !== 'string') {
      const err = new TypeError('[ERROR] dstFilePath must be a string. (' + typeof dstFilePath + ')');
      log_error(err);
      throw err;
    }
    if (typeof userAgent !== 'string') {
      const err = new TypeError('[ERROR] userAgent must be a string. (' + typeof userAgent + ')');
      log_error(err);
      throw err;
    }
    if (typeof callback !== 'function') {
      const err = new TypeError('[ERROR] callback must be a function. ()' + typeof callback + ')');
      log_error(err);
      throw err;
    }

    if (this.isRunning) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'Downloader already running.'));
      return;
    }

    this.current = 0;
    this.total = fileSize;
    this.isRunning = true;
    this.isCancelled = false;

    const md5 = crypto.createHash('md5');

    const self = this;
    let writeStream = null;
    Promise.resolve()
      // HTTPのプロキシ設定を取得する
      .then(function () {
        return new Promise(function (resolve, reject) {
          proxyResolver.getProxy(
            srcFileUrl,
            userAgent,
            function (err, proxy) {
              let httpProxy = null;
              if (!err && proxy) {
                httpProxy = 'http://' + proxy;
              }
              log_debug('Proxy: ' + httpProxy);
              resolve(httpProxy);
            });
        });
      })
      // ファイルをダウンロードする
      .then(function (httpProxy) {
        return new Promise(function (resolve, reject) {
          const options = {
            url: srcFileUrl,
            proxy: httpProxy,
            timeout: HTTP_REQUEST_TIMEOUT,
            headers: {
              'User-Agent': userAgent
            }
          };

          // ダウンロード先のファイルストリームを用意する
          let writeError = null;
          writeStream = fs.createWriteStream(dstFilePath);
          writeStream.on('error', function(err) {
            log_error(err);
            writeError = mwe.genError(
                mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to write file.', err);
          });
          writeStream.on('close', function() {
            log_debug('close');
            writeStream = null;
            if (!alreadyRejected) {
              // WriteStreamがcloseされるのを待ってから次の処理へ進む
              resolve();
            }
          });

          // ファイルをダウンロードする
          let error = null;
          let statusCode = null;
          let alreadyRejected = false;
          request.get(options)
            .on('data', function (data) {
              // data が download される度に繰り返し呼び出される

              // MD5 の計算
              md5.update(data, 'binary');

              // 進捗の計算
              self.current += data.length;
            })
            .on('response', function (response) {
              // レスポンスの確認
              statusCode = response.statusCode;
              // const contentLength = parseInt(response.headers['content-length'], 10);
              if (response.statusCode !== 200) {
                // HTTP Status が 200 (OK) 以外はエラーとする
                error = mwe.genWebApiError(
                  mwe.E_MW_EXT_HTTP_UNEXPECTED_STATUS, 'Unexpected HTTP status code : ' + statusCode,
                  'GET', srcFileUrl, statusCode);
                response.destroy();
              }
              // else if (contentLength !== fileSize) {
              //   // content-length が 期待値と異なる場合にはエラーとする
              //   error = mwe.genWebApiError(
              //     mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE, 'Unexpected content-length : ' + contentLength,
              //     'GET', srcFileUrl, statusCode);
              //   response.destroy();
              // }

              response.on('data', function (data) {
                // data が download される度に繰り返し呼び出される
                if (self.isCancelled) {
                  // キャンセルされた場合
                  error = mwe.genError(mwe.E_MW_CANCELLED, 'Cancelled');
                  response.destroy();
                  return;
                }
                if (writeError) {
                  // 書き込みでエラーが発生した場合
                  error = writeError;
                  response.destroy();
                  return;
                }
              });
            })
            .on('end', function () {
              // request の処理終了時に呼び出される
              // エラー発生時やキャンセル時にも呼び出される
              if (!error) {
                // MD5 のチェック
                const digetst = md5.digest('hex');
                if (md5Hash !== digetst) {
                  error = mwe.genWebApiError(
                    mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE, 'MD5 verification failed.',
                    'GET', srcFileUrl, statusCode);
                }
              }
              if (error) {
                if (!alreadyRejected) {
                  reject(error);
                  alreadyRejected = true;
                }
              }
              // サーバーからデータ取得が完了しても、
              // WriteStreamへの書き込みが完了するまで次へ進まない
            })
            .on('error', function (err) {
              // エラーが発生した際に呼び出される
              log_error(err);
              error = mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_ERROR, 'request failed.', 'GET', srcFileUrl, statusCode, err);
              if (!alreadyRejected) {
                reject(error);
                alreadyRejected = true;
              }
            })
            .pipe(writeStream);
        });
      })
      // ファイルサイズを確認する
      .then(function () {
        return new Promise(function (resolve, reject) {
          fs.stat(dstFilePath, function (err, stats) {
            if (err) {
              const error = mwe.genError(
                mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Failed to access to the file.', err);
              reject(error);
              return;
            }
            if (stats.size !== fileSize) {
              const error = mwe.genError(
                mwe.E_MW_FILE_WRITE_LOCAL_FAILED, 'Unexpected file size: ' + stats.size);
              reject(error);
              return;
            }
            resolve();
          });
        });
      })
      // 結果をcallbackする
      .then(
      function () {
        return Promise.resolve(null);
      },
      function (error) {
        return new Promise(function (resolve, reject) {
          // HTTPの通信でエラーが発生した際に、WindowsではWriteStreamがcloseされない
          if (writeStream) {
            writeStream.on('close', function () {
              // WriteStreamがcloseされるのを待ってから次の処理へ進む
              log_debug('close');
              writeStream = null;
              resolve(error);
            });
            // end を呼び出してWriteStreamをcloseする
            writeStream.end(function () {
              log_debug('end');
            });
          } else {
            resolve(error);
          }
        });
      })
      // 結果をcallbackし、状態を初期化する
      .then(function (error) {
        callback(error);
        self.isRunning = false;
        self.current = 0;
        self.total = 0;
      });
    }

  /**
   * ダウンロード中か確認する。
   */
  isDownloading() {
    return this.isRunning;
  }

  /**
   * ダウンロードの進捗を取得する。
   *
   * @return {object}
   */
  getDownloadProgress() {
    return { current: this.current, total: this.total };
  }

  /**
   * ダウンロードを中断する。
   */
  cancelDownload() {
    this.isCancelled = true;
  }

  /**
   * 「アップデート情報ファイル」をダウンロードする。
   * 
   * @param {string} fileUrl
   * @param {string} userAgent
   * @param {function(?Error, string)} callback
   */
  static downloadUpdateInfoFile(
    fileUrl,
    userAgent,
    callback
  ) {
    log_debug('downloadUpdateInfoFile(' + fileUrl + ')');

    if (typeof fileUrl !== 'string') {
      const err = new TypeError('[ERROR] fileUrl must be a string. (' + typeof fileUrl + ')');
      log_error(err);
      throw err;
    }

    if (typeof callback !== 'function') {
      const err = new TypeError('[ERROR] callback must be a function. ()' + typeof callback + ')');
      log_error(err);
      throw err;
    }

    // プロキシ設定を取得する
    let httpProxy = null;
    proxyResolver.getProxy(
      fileUrl,
      userAgent,
      function (error, proxy) {
        if (!error && proxy) {
          httpProxy = 'http://' + proxy;
        }
        log_debug('Proxy: ' + httpProxy);

        const options = {
          url: fileUrl,
          proxy: httpProxy,
          timeout: HTTP_REQUEST_TIMEOUT,
          headers: {
            'User-Agent': userAgent
          }
        };

        // HTTP のリクエストを発行する
        request(
          options,
          function (error, response, body) {
            if (error) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_ERROR, 'request failed.', 'GET', fileUrl, null, error));
              return;
            }

            if (!response) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_ERROR, 'response is not passed.', 'GET', fileUrl, null));
              return;
            }

            if (response.statusCode !== 200) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_UNEXPECTED_STATUS, 'Unexpected HTTP status code : ' + response.statusCode,
                'GET', fileUrl, response.statusCode));
              return;
            }

            if (!body) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_ERROR, 'body is not passed.', 'GET', fileUrl, response.statusCode));
              return;
            }

            callback(null, body);
          });
      });
  }

  /**
   * 「EULA」「免責」のXMLファイルをダウンロードする。
   *
   * @param {string} fileUrl
   * @param {string} userAgent
   * @param {string} md5Hash
   * @param {number} fileSize
   * @param {function(?Error, string)} callback
   */
  static downloadDocumentXml(
    fileUrl,
    userAgent,
    md5Hash,
    fileSize,
    callback
  ) {
    log_debug('downloadXml(' + fileUrl + ')');

    if (typeof fileUrl !== 'string') {
      const err = new TypeError('[ERROR] fileUrl must be a string. (' + typeof fileUrl + ')');
      log_error(err);
      throw err;
    }

    if (typeof callback !== 'function') {
      const err = new TypeError('[ERROR] callback must be a function. ()' + typeof callback + ')');
      log_error(err);
      throw err;
    }

    // プロキシ設定を取得する
    let httpProxy = null;
    proxyResolver.getProxy(
      fileUrl,
      userAgent,
      function (error, proxy) {
        if (!error && proxy) {
          httpProxy = 'http://' + proxy;
        }
        log_debug('Proxy: ' + httpProxy);

        const options = {
          url: fileUrl,
          proxy: httpProxy,
          timeout: HTTP_REQUEST_TIMEOUT,
          headers: {
            'User-Agent': userAgent
          }
        };

        // HTTP のリクエストを発行する
        request(
          options,
          function (error, response, body) {
            if (error) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_ERROR, 'request failed.', 'GET', fileUrl, null, error));
              return;
            }

            if (!response) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_ERROR, 'response is not passed.', 'GET', fileUrl, null));
              return;
            }

            if (response.statusCode !== 200) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_UNEXPECTED_STATUS, 'Unexpected HTTP status code : ' + response.statusCode,
                'GET', fileUrl, response.statusCode));
              return;
            }

            // const contentLength = parseInt(response.headers['content-length'], 10);
            // if (contentLength !== fileSize) {
            //   callback(mwe.genWebApiError(
            //     mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE, 'Unexpected content-length : ' + contentLength,
            //     'GET', fileUrl, response.statusCode));
            //   return;
            // }

            if (!body) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_ERROR, 'body is not passed.', 'GET', fileUrl, response.statusCode));
              return;
            }

            const specifiedMd5 = md5Hash;
            const calculatedMd5 = md5.md5Text(body);
            if (specifiedMd5 !== calculatedMd5) {
              callback(mwe.genWebApiError(
                mwe.E_MW_EXT_HTTP_UNEXPECTED_VALUE, 'MD5 verification failed. (' + specifiedMd5 + ', ' + calculatedMd5 + ')',
                'GET', fileUrl, response.statusCode));
              return;
            }

            callback(null, body);
          });
      });
  }

}

module.exports = Downloader;
