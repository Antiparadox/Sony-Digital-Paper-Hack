'use strict';

const log_error = require('debug')('mw-automagic-client:update-downloader:error');
const log_debug = require('debug')('mw-automagic-client:update-downloader:debug');

const AutoMagic = require('./automagic');
const Downloader = require('./downloader');
const FsUtil = require('./file-system-util');
const mwe = require('mw-error');
const url = require('url');
const path = require('path');
const fs = require('fs');

const UPDATER_TEMP_FILE_EXT = '.tmp';



class UpdateDownloader {

  constructor() {
    this.downloader = new Downloader();
    this.isRunning = false;
    this.isCancelled = false;
    this.cancelCallback = null;
  }

  /**
   * アプリのアップデーターをダウンロードする。
   *
   * @param {object} updater
   * @param {string} dstDirPath
   * @param {function(?Error, string)} callback
   */
  downloadAppUpdater(
    updater,
    dstDirPath,
    callback
  ) {
    this.verifyUpdater(updater);
    const userAgent = AutoMagic.getUserAgentForAppUpdate(updater.oldVersion, updater.newVersion);
    this.downloadUpdater(updater, dstDirPath, userAgent, callback);
  }

  /**
   * デバイスのアップデーターをダウンロードする。
   *
   * @param {object} updater
   * @param {string} dstDirPath
   * @param {function(?Error, string)} callback
   */
  downloadDeviceUpdater(
    updater,
    dstDirPath,
    callback
  ) {
    this.verifyUpdater(updater);
    const userAgent = AutoMagic.getUserAgentForDeviceUpdate(updater.oldVersion, updater.newVersion);
    this.downloadUpdater(updater, dstDirPath, userAgent, callback);
  }

  /**
   * アップデーターをダウンロードする。
   *
   * @param {object} updater
   * @param {string} dstDirPath
   * @param {string} userAgent
   * @param {function(?Error, string)} callback
   * @private
   */
  downloadUpdater(
    updater,
    dstDirPath,
    userAgent,
    callback
  ) {
    this.verifyUpdater(updater);
    this.verifyCallback(callback);

    // 既に処理を実行中の場合にはエラーを返す
    if (this.isRunning) {
      callback(mwe.genError(mwe.E_MW_ALREADY_RUNNING, 'Downloader already running.'));
      return;
    }

    this.isRunning = true;
    this.isCancelled = false;
    this.cancelCallback = null;

    const self = this;
    let downloadDirPath = null;
    let srcFileName = null;
    let tmpFilePath = null;
    let dstFilePath = null;
    Promise.resolve()
      // ダウンロード先ディレクトリを作成する
      .then(function () {
        return new Promise(function (resolve, reject) {
          if (self.isCancelled) {
            reject(mwe.genError(mwe.E_MW_CANCELLED, 'Cancelled'));
            return;
          }
          FsUtil.makeDirRecursively(
            dstDirPath,
            function (error, dirPath) {
              if (error) {
                log_error(error);
                reject(error);
                return;
              }
              resolve(dirPath);
            });
        });
      })
      // ダウンロード先のファイルパスを用意する
      .then(function (dirPath) {
        return new Promise(function (resolve, reject) {
          if (self.isCancelled) {
            reject(mwe.genError(mwe.E_MW_CANCELLED, 'Cancelled'));
            return;
          }
          // ダウンロード先ディレクトリのパスを保存する
          downloadDirPath = dirPath;

          // ダウンロード元の URL からファイル名を抜き出す
          const urlPathName = url.parse(updater.url).pathname;
          srcFileName = path.parse(urlPathName).base;

          // ダウンロード先の一時ファイル名を用意する
          const tmpFileName = path.parse(urlPathName).name + UPDATER_TEMP_FILE_EXT;

          // ダウンロード先として利用可能なファイル名を用意する
          FsUtil.getAvailableFileName(
            downloadDirPath,
            tmpFileName,
            function (error, fileName) {
              if (error) {
                log_error(error);
                reject(error);
                return;
              }
              // ダウンロード先の一時ファイルのパスを作成する
              tmpFilePath = path.join(downloadDirPath, fileName);
              resolve(tmpFilePath);
            });
        });
      })
      // アップデーターをダウンロードする
      .then(function (tmpFilePath) {
        return new Promise(function (resolve, reject) {
          if (self.isCancelled) {
            reject(mwe.genError(mwe.E_MW_CANCELLED, 'Cancelled'));
            return;
          }
          self.downloader.downloadFile(
            updater.url,
            tmpFilePath,
            userAgent,
            updater.md5,
            updater.size,
            function (error) {
              if (error) {
                log_error(error);
                reject(error);
                return;
              }
              resolve(null);
            });
        });
      })
      // ダウンロードしたファイルのリネーム先のファイル名を用意する
      .then(function () {
        return new Promise(function (resolve, reject) {
          if (self.isCancelled) {
            reject(mwe.genError(mwe.E_MW_CANCELLED, 'Cancelled'));
            return;
          }

          // リネーム先として利用可能なファイル名を用意する
          FsUtil.getAvailableFileName(
            downloadDirPath,
            srcFileName,
            function (error, fileName) {
              if (error) {
                log_error(error);
                reject(error);
                return;
              }
              // リネーム先のファイルのパスを作成する
              dstFilePath = path.join(downloadDirPath, fileName);
              resolve(dstFilePath);
            });
        });
      })
      // ダウンロードしたファイルをリネームする
      .then(function () {
        return new Promise(function (resolve, reject) {
          if (self.isCancelled) {
            reject(mwe.genError(mwe.E_MW_CANCELLED, 'Cancelled'));
            return;
          }
          fs.rename(tmpFilePath, dstFilePath, function (error) {
            if (error) {
              log_error(error);
              reject(error);
              return;
            }
            resolve(null);
          });
        });
      })
      // エラー発生時に一時ファイルが残っていたら削除する
      .catch(function onRejected(error) {
        return new Promise(function (resolve, reject) {
          if (tmpFilePath) {
            fs.unlink(tmpFilePath, function () {
              resolve(error);
            });
            return;
          }
          resolve(error);
        });
      })
      // 結果をcallbackする
      .then(function onFullfilled(error) {
        if (error) {
          callback(error);
        } else {
          callback(null, dstFilePath);
        }
        if (self.cancelCallback) {
          self.cancelCallback();
          self.cancelCallback = null;
        }
        self.isCancelled = false;
        self.isRunning = false;
      });
  }

  /**
   * ダウンロード中か否かを確認する。
   *
   * @return {boolean} ダウンロード中の場合にtrue
   */
  isDownloading() {
    return this.isRunning;
  }

  /**
   * ダウンロードの進捗を取得する。
   *
   * @return {object} ダウンロード中の進捗
   */
  getDownloadProgress() {
    return this.downloader.getDownloadProgress();
  }

  /**
   * ダウンロードを中断する。
   *
   * @param {function} 中断完了時にcallbackされる関数。
   */
  cancelDownload(callback) {
    if (!this.isRunning) {
      callback();
      return;
    }
    this.isCancelled = true;
    this.cancelCallback = callback;
    this.downloader.cancelDownload();
  }

  /**
   * 指定されたcallbackが適切なfunctionか否かを確認する。
   *
   * @param {function} callback コールバック先のfunction
   * @private
   */
  verifyCallback(callback) {
    if (typeof callback !== 'function') {
      const error = new TypeError('[ERROR] callback must be a function. (' + typeof callback + ')');
      log_error(error);
      throw error;
    }
  }

  /**
   * 指定された updater が適切な object か否かを確認する。
   *
   * @param {object} updater アップデーターのobject
   * @private
   */
  verifyUpdater(updater) {
    if (typeof updater !== 'object') {
      const error = new TypeError('[ERROR] updater must be a object. (' + typeof updater + ')');
      log_error(error);
      throw error;
    }
    if (typeof updater.oldVersion !== 'string') {
      const error = new TypeError('[ERROR] updater.newVersion must be a object. (' + typeof updater.newVersion + ')');
      log_error(error);
      throw error;
    }
    if (typeof updater.newVersion !== 'string') {
      const error = new TypeError('[ERROR] updater.newVersion must be a object. (' + typeof updater.newVersion + ')');
      log_error(error);
      throw error;
    }
    if (typeof updater.url !== 'string') {
      const error = new TypeError('[ERROR] updater.url must be a object. (' + typeof updater.url + ')');
      log_error(error);
      throw error;
    }
    if (typeof updater.md5 !== 'string') {
      const error = new TypeError('[ERROR] updater.md5 must be a object. (' + typeof updater.md5 + ')');
      log_error(error);
      throw error;
    }
    if (typeof updater.size !== 'number') {
      const error = new TypeError('[ERROR] updater.size must be a object. (' + typeof updater.size + ')');
      log_error(error);
      throw error;
    }
  }

}

/**
 * @export UpdateDownloader
 */
module.exports = UpdateDownloader;
